{"ast":null,"code":"import moment from 'moment'; // Formats which are correctly parsed to time (supported by momentjs)\n\nvar STRICT_FORMATS = ['YYYY-MM-DDTHH:mm:ss.SSSZ', 'X',\n// Unix timestamp\n'x' // Unix ms timestamp\n];\n/**\n * Time cell validator\n *\n * @private\n * @validator TimeValidator\n * @param {*} value - Value of edited cell\n * @param {Function} callback - Callback called with validation result\n */\n\nexport default function timeValidator(value, callback) {\n  var timeFormat = this.timeFormat || 'h:mm:ss a';\n  var valid = true;\n  var valueToValidate = value;\n  if (valueToValidate === null) {\n    valueToValidate = '';\n  }\n  valueToValidate = /^\\d{3,}$/.test(valueToValidate) ? parseInt(valueToValidate, 10) : valueToValidate;\n  var twoDigitValue = /^\\d{1,2}$/.test(valueToValidate);\n  if (twoDigitValue) {\n    valueToValidate += ':00';\n  }\n  var date = moment(valueToValidate, STRICT_FORMATS, true).isValid() ? moment(valueToValidate) : moment(valueToValidate, timeFormat);\n  var isValidTime = date.isValid(); // is it in the specified format\n\n  var isValidFormat = moment(valueToValidate, timeFormat, true).isValid() && !twoDigitValue;\n  if (this.allowEmpty && valueToValidate === '') {\n    isValidTime = true;\n    isValidFormat = true;\n  }\n  if (!isValidTime) {\n    valid = false;\n  }\n  if (!isValidTime && isValidFormat) {\n    valid = true;\n  }\n  if (isValidTime && !isValidFormat) {\n    if (this.correctFormat === true) {\n      // if format correction is enabled\n      var correctedValue = date.format(timeFormat);\n      var row = this.instance.runHooks('unmodifyRow', this.row);\n      var column = this.instance.runHooks('unmodifyCol', this.col);\n      this.instance.setDataAtCell(row, column, correctedValue, 'timeValidator');\n      valid = true;\n    } else {\n      valid = false;\n    }\n  }\n  callback(valid);\n}","map":{"version":3,"names":["moment","STRICT_FORMATS","timeValidator","value","callback","timeFormat","valid","valueToValidate","test","parseInt","twoDigitValue","date","isValid","isValidTime","isValidFormat","allowEmpty","correctFormat","correctedValue","format","row","instance","runHooks","column","col","setDataAtCell"],"sources":["C:/Users/mrezy/VSCode/internships-master/node_modules/handsontable/es/validators/timeValidator.js"],"sourcesContent":["import moment from 'moment'; // Formats which are correctly parsed to time (supported by momentjs)\n\nvar STRICT_FORMATS = ['YYYY-MM-DDTHH:mm:ss.SSSZ', 'X', // Unix timestamp\n'x' // Unix ms timestamp\n];\n/**\n * Time cell validator\n *\n * @private\n * @validator TimeValidator\n * @param {*} value - Value of edited cell\n * @param {Function} callback - Callback called with validation result\n */\n\nexport default function timeValidator(value, callback) {\n  var timeFormat = this.timeFormat || 'h:mm:ss a';\n  var valid = true;\n  var valueToValidate = value;\n\n  if (valueToValidate === null) {\n    valueToValidate = '';\n  }\n\n  valueToValidate = /^\\d{3,}$/.test(valueToValidate) ? parseInt(valueToValidate, 10) : valueToValidate;\n  var twoDigitValue = /^\\d{1,2}$/.test(valueToValidate);\n\n  if (twoDigitValue) {\n    valueToValidate += ':00';\n  }\n\n  var date = moment(valueToValidate, STRICT_FORMATS, true).isValid() ? moment(valueToValidate) : moment(valueToValidate, timeFormat);\n  var isValidTime = date.isValid(); // is it in the specified format\n\n  var isValidFormat = moment(valueToValidate, timeFormat, true).isValid() && !twoDigitValue;\n\n  if (this.allowEmpty && valueToValidate === '') {\n    isValidTime = true;\n    isValidFormat = true;\n  }\n\n  if (!isValidTime) {\n    valid = false;\n  }\n\n  if (!isValidTime && isValidFormat) {\n    valid = true;\n  }\n\n  if (isValidTime && !isValidFormat) {\n    if (this.correctFormat === true) {\n      // if format correction is enabled\n      var correctedValue = date.format(timeFormat);\n      var row = this.instance.runHooks('unmodifyRow', this.row);\n      var column = this.instance.runHooks('unmodifyCol', this.col);\n      this.instance.setDataAtCell(row, column, correctedValue, 'timeValidator');\n      valid = true;\n    } else {\n      valid = false;\n    }\n  }\n\n  callback(valid);\n}"],"mappings":"AAAA,OAAOA,MAAM,MAAM,QAAQ,CAAC,CAAC;;AAE7B,IAAIC,cAAc,GAAG,CAAC,0BAA0B,EAAE,GAAG;AAAE;AACvD,GAAG,CAAC;AAAA,CACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,SAASC,aAAa,CAACC,KAAK,EAAEC,QAAQ,EAAE;EACrD,IAAIC,UAAU,GAAG,IAAI,CAACA,UAAU,IAAI,WAAW;EAC/C,IAAIC,KAAK,GAAG,IAAI;EAChB,IAAIC,eAAe,GAAGJ,KAAK;EAE3B,IAAII,eAAe,KAAK,IAAI,EAAE;IAC5BA,eAAe,GAAG,EAAE;EACtB;EAEAA,eAAe,GAAG,UAAU,CAACC,IAAI,CAACD,eAAe,CAAC,GAAGE,QAAQ,CAACF,eAAe,EAAE,EAAE,CAAC,GAAGA,eAAe;EACpG,IAAIG,aAAa,GAAG,WAAW,CAACF,IAAI,CAACD,eAAe,CAAC;EAErD,IAAIG,aAAa,EAAE;IACjBH,eAAe,IAAI,KAAK;EAC1B;EAEA,IAAII,IAAI,GAAGX,MAAM,CAACO,eAAe,EAAEN,cAAc,EAAE,IAAI,CAAC,CAACW,OAAO,EAAE,GAAGZ,MAAM,CAACO,eAAe,CAAC,GAAGP,MAAM,CAACO,eAAe,EAAEF,UAAU,CAAC;EAClI,IAAIQ,WAAW,GAAGF,IAAI,CAACC,OAAO,EAAE,CAAC,CAAC;;EAElC,IAAIE,aAAa,GAAGd,MAAM,CAACO,eAAe,EAAEF,UAAU,EAAE,IAAI,CAAC,CAACO,OAAO,EAAE,IAAI,CAACF,aAAa;EAEzF,IAAI,IAAI,CAACK,UAAU,IAAIR,eAAe,KAAK,EAAE,EAAE;IAC7CM,WAAW,GAAG,IAAI;IAClBC,aAAa,GAAG,IAAI;EACtB;EAEA,IAAI,CAACD,WAAW,EAAE;IAChBP,KAAK,GAAG,KAAK;EACf;EAEA,IAAI,CAACO,WAAW,IAAIC,aAAa,EAAE;IACjCR,KAAK,GAAG,IAAI;EACd;EAEA,IAAIO,WAAW,IAAI,CAACC,aAAa,EAAE;IACjC,IAAI,IAAI,CAACE,aAAa,KAAK,IAAI,EAAE;MAC/B;MACA,IAAIC,cAAc,GAAGN,IAAI,CAACO,MAAM,CAACb,UAAU,CAAC;MAC5C,IAAIc,GAAG,GAAG,IAAI,CAACC,QAAQ,CAACC,QAAQ,CAAC,aAAa,EAAE,IAAI,CAACF,GAAG,CAAC;MACzD,IAAIG,MAAM,GAAG,IAAI,CAACF,QAAQ,CAACC,QAAQ,CAAC,aAAa,EAAE,IAAI,CAACE,GAAG,CAAC;MAC5D,IAAI,CAACH,QAAQ,CAACI,aAAa,CAACL,GAAG,EAAEG,MAAM,EAAEL,cAAc,EAAE,eAAe,CAAC;MACzEX,KAAK,GAAG,IAAI;IACd,CAAC,MAAM;MACLA,KAAK,GAAG,KAAK;IACf;EACF;EAEAF,QAAQ,CAACE,KAAK,CAAC;AACjB"},"metadata":{},"sourceType":"module"}