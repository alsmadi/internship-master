{"ast":null,"code":"function _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n    return arr2;\n  }\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nimport { Parser, ERROR_REF, error as isFormulaError } from 'hot-formula-parser';\nimport { arrayEach, arrayMap } from '../../helpers/array';\nimport localHooks from '../../mixins/localHooks';\nimport { getTranslator } from '../../utils/recordTranslator';\nimport { mixin } from '../../helpers/object';\nimport CellValue from './cell/value';\nimport CellReference from './cell/reference';\nimport { isFormulaExpression, toUpperCaseFormula } from './utils';\nimport Matrix from './matrix';\nimport AlterManager from './alterManager';\nvar STATE_UP_TO_DATE = 1;\nvar STATE_NEED_REBUILD = 2;\nvar STATE_NEED_FULL_REBUILD = 3;\n/**\n * Sheet component responsible for whole spreadsheet calculations.\n *\n * @class Sheet\n * @util\n */\n\nvar Sheet = /*#__PURE__*/\nfunction () {\n  function Sheet(hot, dataProvider) {\n    var _this = this;\n    _classCallCheck(this, Sheet);\n\n    /**\n     * Handsontable instance.\n     *\n     * @type {Core}\n     */\n    this.hot = hot;\n    /**\n     * Record translator for translating visual records into psychical and vice versa.\n     *\n     * @type {RecordTranslator}\n     */\n\n    this.t = getTranslator(this.hot);\n    /**\n     * Data provider for sheet calculations.\n     *\n     * @type {DataProvider}\n     */\n\n    this.dataProvider = dataProvider;\n    /**\n     * Instance of {@link https://github.com/handsontable/formula-parser}.\n     *\n     * @type {Parser}\n     */\n\n    this.parser = new Parser();\n    /**\n     * Instance of {@link Matrix}.\n     *\n     * @type {Matrix}\n     */\n\n    this.matrix = new Matrix(this.t);\n    /**\n     * Instance of {@link AlterManager}.\n     *\n     * @type {AlterManager}\n     */\n\n    this.alterManager = new AlterManager(this);\n    /**\n     * Cell object which indicates which cell is currently processing.\n     *\n     * @private\n     * @type {null}\n     */\n\n    this._processingCell = null;\n    /**\n     * State of the sheet.\n     *\n     * @type {Number}\n     * @private\n     */\n\n    this._state = STATE_NEED_FULL_REBUILD;\n    this.parser.on('callCellValue', function () {\n      return _this._onCallCellValue.apply(_this, arguments);\n    });\n    this.parser.on('callRangeValue', function () {\n      return _this._onCallRangeValue.apply(_this, arguments);\n    });\n    this.alterManager.addLocalHook('afterAlter', function () {\n      return _this._onAfterAlter.apply(_this, arguments);\n    });\n  }\n  /**\n   * Recalculate sheet.\n   */\n\n  _createClass(Sheet, [{\n    key: \"recalculate\",\n    value: function recalculate() {\n      switch (this._state) {\n        case STATE_NEED_FULL_REBUILD:\n          this.recalculateFull();\n          break;\n        case STATE_NEED_REBUILD:\n          this.recalculateOptimized();\n          break;\n        default:\n          break;\n      }\n    }\n    /**\n     * Recalculate sheet using optimized methods (fast recalculation).\n     */\n  }, {\n    key: \"recalculateOptimized\",\n    value: function recalculateOptimized() {\n      var _this2 = this;\n      var cells = this.matrix.getOutOfDateCells();\n      arrayEach(cells, function (cellValue) {\n        var value = _this2.dataProvider.getSourceDataAtCell(cellValue.row, cellValue.column);\n        if (isFormulaExpression(value)) {\n          _this2.parseExpression(cellValue, value.substr(1));\n        }\n      });\n      this._state = STATE_UP_TO_DATE;\n      this.runLocalHooks('afterRecalculate', cells, 'optimized');\n    }\n    /**\n     * Recalculate whole table by building dependencies from scratch (slow recalculation).\n     */\n  }, {\n    key: \"recalculateFull\",\n    value: function recalculateFull() {\n      var _this3 = this;\n      var cells = this.dataProvider.getSourceDataByRange();\n      this.matrix.reset();\n      arrayEach(cells, function (rowData, row) {\n        arrayEach(rowData, function (value, column) {\n          if (isFormulaExpression(value)) {\n            _this3.parseExpression(new CellValue(row, column), value.substr(1));\n          }\n        });\n      });\n      this._state = STATE_UP_TO_DATE;\n      this.runLocalHooks('afterRecalculate', cells, 'full');\n    }\n    /**\n     * Set predefined variable name which can be visible while parsing formula expression.\n     *\n     * @param {String} name Variable name.\n     * @param {*} value Variable value.\n     */\n  }, {\n    key: \"setVariable\",\n    value: function setVariable(name, value) {\n      this.parser.setVariable(name, value);\n    }\n    /**\n     * Get variable name.\n     *\n     * @param {String} name Variable name.\n     * @returns {*}\n     */\n  }, {\n    key: \"getVariable\",\n    value: function getVariable(name) {\n      return this.parser.getVariable(name);\n    }\n    /**\n     * Apply changes to the sheet.\n     *\n     * @param {Number} row Physical row index.\n     * @param {Number} column Physical column index.\n     * @param {*} newValue Current cell value.\n     */\n  }, {\n    key: \"applyChanges\",\n    value: function applyChanges(row, column, newValue) {\n      // Remove formula description for old expression\n      // TODO: Move this to recalculate()\n      this.matrix.remove({\n        row: row,\n        column: column\n      }); // TODO: Move this to recalculate()\n\n      if (isFormulaExpression(newValue)) {\n        // ...and create new for new changed formula expression\n        this.parseExpression(new CellValue(row, column), newValue.substr(1));\n      }\n      var deps = this.getCellDependencies.apply(this, _toConsumableArray(this.t.toVisual(row, column)));\n      arrayEach(deps, function (cellValue) {\n        cellValue.setState(CellValue.STATE_OUT_OFF_DATE);\n      });\n      this._state = STATE_NEED_REBUILD;\n    }\n    /**\n     * Parse and evaluate formula for provided cell.\n     *\n     * @param {CellValue|Object} cellValue Cell value object.\n     * @param {String} formula Value to evaluate.\n     */\n  }, {\n    key: \"parseExpression\",\n    value: function parseExpression(cellValue, formula) {\n      cellValue.setState(CellValue.STATE_COMPUTING);\n      this._processingCell = cellValue;\n      var _this$parser$parse = this.parser.parse(toUpperCaseFormula(formula)),\n        error = _this$parser$parse.error,\n        result = _this$parser$parse.result;\n      if (isFormulaExpression(result)) {\n        this.parseExpression(cellValue, result.substr(1));\n      } else {\n        cellValue.setValue(result);\n        cellValue.setError(error);\n        cellValue.setState(CellValue.STATE_UP_TO_DATE);\n      }\n      this.matrix.add(cellValue);\n      this._processingCell = null;\n    }\n    /**\n     * Get cell value object at specified physical coordinates.\n     *\n     * @param {Number} row Physical row index.\n     * @param {Number} column Physical column index.\n     * @returns {CellValue|undefined}\n     */\n  }, {\n    key: \"getCellAt\",\n    value: function getCellAt(row, column) {\n      return this.matrix.getCellAt(row, column);\n    }\n    /**\n     * Get cell dependencies at specified physical coordinates.\n     *\n     * @param {Number} row Physical row index.\n     * @param {Number} column Physical column index.\n     * @returns {Array}\n     */\n  }, {\n    key: \"getCellDependencies\",\n    value: function getCellDependencies(row, column) {\n      return this.matrix.getDependencies({\n        row: row,\n        column: column\n      });\n    }\n    /**\n     * Listener for parser cell value.\n     *\n     * @private\n     * @param {Object} cellCoords Cell coordinates.\n     * @param {Function} done Function to call with valid cell value.\n     */\n  }, {\n    key: \"_onCallCellValue\",\n    value: function _onCallCellValue(_ref, done) {\n      var row = _ref.row,\n        column = _ref.column;\n      var cell = new CellReference(row, column);\n      if (!this.dataProvider.isInDataRange(cell.row, cell.column)) {\n        throw Error(ERROR_REF);\n      }\n      this.matrix.registerCellRef(cell);\n      this._processingCell.addPrecedent(cell);\n      var cellValue = this.dataProvider.getRawDataAtCell(row.index, column.index);\n      if (isFormulaError(cellValue)) {\n        var computedCell = this.matrix.getCellAt(row.index, column.index);\n        if (computedCell && computedCell.hasError()) {\n          throw Error(cellValue);\n        }\n      }\n      if (isFormulaExpression(cellValue)) {\n        var _this$parser$parse2 = this.parser.parse(cellValue.substr(1)),\n          error = _this$parser$parse2.error,\n          result = _this$parser$parse2.result;\n        if (error) {\n          throw Error(error);\n        }\n        done(result);\n      } else {\n        done(cellValue);\n      }\n    }\n    /**\n     * Listener for parser cells (range) value.\n     *\n     * @private\n     * @param {Object} startCell Cell coordinates (top-left corner coordinate).\n     * @param {Object} endCell Cell coordinates (bottom-right corner coordinate).\n     * @param {Function} done Function to call with valid cells values.\n     */\n  }, {\n    key: \"_onCallRangeValue\",\n    value: function _onCallRangeValue(_ref2, _ref3, done) {\n      var _this4 = this;\n      var startRow = _ref2.row,\n        startColumn = _ref2.column;\n      var endRow = _ref3.row,\n        endColumn = _ref3.column;\n      var cellValues = this.dataProvider.getRawDataByRange(startRow.index, startColumn.index, endRow.index, endColumn.index);\n      var mapRowData = function mapRowData(rowData, rowIndex) {\n        return arrayMap(rowData, function (cellData, columnIndex) {\n          var rowCellCoord = startRow.index + rowIndex;\n          var columnCellCoord = startColumn.index + columnIndex;\n          var cell = new CellReference(rowCellCoord, columnCellCoord);\n          if (!_this4.dataProvider.isInDataRange(cell.row, cell.column)) {\n            throw Error(ERROR_REF);\n          }\n          _this4.matrix.registerCellRef(cell);\n          _this4._processingCell.addPrecedent(cell);\n          var newCellData = cellData;\n          if (isFormulaError(newCellData)) {\n            var computedCell = _this4.matrix.getCellAt(cell.row, cell.column);\n            if (computedCell && computedCell.hasError()) {\n              throw Error(newCellData);\n            }\n          }\n          if (isFormulaExpression(newCellData)) {\n            var _this4$parser$parse = _this4.parser.parse(newCellData.substr(1)),\n              error = _this4$parser$parse.error,\n              result = _this4$parser$parse.result;\n            if (error) {\n              throw Error(error);\n            }\n            newCellData = result;\n          }\n          return newCellData;\n        });\n      };\n      var calculatedCellValues = arrayMap(cellValues, function (rowData, rowIndex) {\n        return mapRowData(rowData, rowIndex);\n      });\n      done(calculatedCellValues);\n    }\n    /**\n     * On after alter sheet listener.\n     *\n     * @private\n     */\n  }, {\n    key: \"_onAfterAlter\",\n    value: function _onAfterAlter() {\n      this.recalculateOptimized();\n    }\n    /**\n     * Destroy class.\n     */\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.hot = null;\n      this.t = null;\n      this.dataProvider.destroy();\n      this.dataProvider = null;\n      this.alterManager.destroy();\n      this.alterManager = null;\n      this.parser = null;\n      this.matrix.reset();\n      this.matrix = null;\n    }\n  }]);\n  return Sheet;\n}();\nmixin(Sheet, localHooks);\nexport default Sheet;","map":{"version":3,"names":["_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","Object","prototype","toString","call","Array","from","isArray","i","arr2","length","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","Parser","ERROR_REF","error","isFormulaError","arrayEach","arrayMap","localHooks","getTranslator","mixin","CellValue","CellReference","isFormulaExpression","toUpperCaseFormula","Matrix","AlterManager","STATE_UP_TO_DATE","STATE_NEED_REBUILD","STATE_NEED_FULL_REBUILD","Sheet","hot","dataProvider","_this","t","parser","matrix","alterManager","_processingCell","_state","on","_onCallCellValue","apply","arguments","_onCallRangeValue","addLocalHook","_onAfterAlter","value","recalculate","recalculateFull","recalculateOptimized","_this2","cells","getOutOfDateCells","cellValue","getSourceDataAtCell","row","column","parseExpression","substr","runLocalHooks","_this3","getSourceDataByRange","reset","rowData","setVariable","name","getVariable","applyChanges","newValue","remove","deps","getCellDependencies","toVisual","setState","STATE_OUT_OFF_DATE","formula","STATE_COMPUTING","_this$parser$parse","parse","result","setValue","setError","add","getCellAt","getDependencies","_ref","done","cell","isInDataRange","Error","registerCellRef","addPrecedent","getRawDataAtCell","index","computedCell","hasError","_this$parser$parse2","_ref2","_ref3","_this4","startRow","startColumn","endRow","endColumn","cellValues","getRawDataByRange","mapRowData","rowIndex","cellData","columnIndex","rowCellCoord","columnCellCoord","newCellData","_this4$parser$parse","calculatedCellValues","destroy"],"sources":["C:/Users/mrezy/VSCode/internships-master/node_modules/handsontable/es/plugins/formulas/sheet.js"],"sourcesContent":["import \"core-js/modules/es.symbol\";\nimport \"core-js/modules/es.symbol.description\";\nimport \"core-js/modules/es.symbol.iterator\";\nimport \"core-js/modules/es.array.from\";\nimport \"core-js/modules/es.array.iterator\";\nimport \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.regexp.to-string\";\nimport \"core-js/modules/es.string.iterator\";\nimport \"core-js/modules/web.dom-collections.iterator\";\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport { Parser, ERROR_REF, error as isFormulaError } from 'hot-formula-parser';\nimport { arrayEach, arrayMap } from '../../helpers/array';\nimport localHooks from '../../mixins/localHooks';\nimport { getTranslator } from '../../utils/recordTranslator';\nimport { mixin } from '../../helpers/object';\nimport CellValue from './cell/value';\nimport CellReference from './cell/reference';\nimport { isFormulaExpression, toUpperCaseFormula } from './utils';\nimport Matrix from './matrix';\nimport AlterManager from './alterManager';\nvar STATE_UP_TO_DATE = 1;\nvar STATE_NEED_REBUILD = 2;\nvar STATE_NEED_FULL_REBUILD = 3;\n/**\n * Sheet component responsible for whole spreadsheet calculations.\n *\n * @class Sheet\n * @util\n */\n\nvar Sheet =\n/*#__PURE__*/\nfunction () {\n  function Sheet(hot, dataProvider) {\n    var _this = this;\n\n    _classCallCheck(this, Sheet);\n\n    /**\n     * Handsontable instance.\n     *\n     * @type {Core}\n     */\n    this.hot = hot;\n    /**\n     * Record translator for translating visual records into psychical and vice versa.\n     *\n     * @type {RecordTranslator}\n     */\n\n    this.t = getTranslator(this.hot);\n    /**\n     * Data provider for sheet calculations.\n     *\n     * @type {DataProvider}\n     */\n\n    this.dataProvider = dataProvider;\n    /**\n     * Instance of {@link https://github.com/handsontable/formula-parser}.\n     *\n     * @type {Parser}\n     */\n\n    this.parser = new Parser();\n    /**\n     * Instance of {@link Matrix}.\n     *\n     * @type {Matrix}\n     */\n\n    this.matrix = new Matrix(this.t);\n    /**\n     * Instance of {@link AlterManager}.\n     *\n     * @type {AlterManager}\n     */\n\n    this.alterManager = new AlterManager(this);\n    /**\n     * Cell object which indicates which cell is currently processing.\n     *\n     * @private\n     * @type {null}\n     */\n\n    this._processingCell = null;\n    /**\n     * State of the sheet.\n     *\n     * @type {Number}\n     * @private\n     */\n\n    this._state = STATE_NEED_FULL_REBUILD;\n    this.parser.on('callCellValue', function () {\n      return _this._onCallCellValue.apply(_this, arguments);\n    });\n    this.parser.on('callRangeValue', function () {\n      return _this._onCallRangeValue.apply(_this, arguments);\n    });\n    this.alterManager.addLocalHook('afterAlter', function () {\n      return _this._onAfterAlter.apply(_this, arguments);\n    });\n  }\n  /**\n   * Recalculate sheet.\n   */\n\n\n  _createClass(Sheet, [{\n    key: \"recalculate\",\n    value: function recalculate() {\n      switch (this._state) {\n        case STATE_NEED_FULL_REBUILD:\n          this.recalculateFull();\n          break;\n\n        case STATE_NEED_REBUILD:\n          this.recalculateOptimized();\n          break;\n\n        default:\n          break;\n      }\n    }\n    /**\n     * Recalculate sheet using optimized methods (fast recalculation).\n     */\n\n  }, {\n    key: \"recalculateOptimized\",\n    value: function recalculateOptimized() {\n      var _this2 = this;\n\n      var cells = this.matrix.getOutOfDateCells();\n      arrayEach(cells, function (cellValue) {\n        var value = _this2.dataProvider.getSourceDataAtCell(cellValue.row, cellValue.column);\n\n        if (isFormulaExpression(value)) {\n          _this2.parseExpression(cellValue, value.substr(1));\n        }\n      });\n      this._state = STATE_UP_TO_DATE;\n      this.runLocalHooks('afterRecalculate', cells, 'optimized');\n    }\n    /**\n     * Recalculate whole table by building dependencies from scratch (slow recalculation).\n     */\n\n  }, {\n    key: \"recalculateFull\",\n    value: function recalculateFull() {\n      var _this3 = this;\n\n      var cells = this.dataProvider.getSourceDataByRange();\n      this.matrix.reset();\n      arrayEach(cells, function (rowData, row) {\n        arrayEach(rowData, function (value, column) {\n          if (isFormulaExpression(value)) {\n            _this3.parseExpression(new CellValue(row, column), value.substr(1));\n          }\n        });\n      });\n      this._state = STATE_UP_TO_DATE;\n      this.runLocalHooks('afterRecalculate', cells, 'full');\n    }\n    /**\n     * Set predefined variable name which can be visible while parsing formula expression.\n     *\n     * @param {String} name Variable name.\n     * @param {*} value Variable value.\n     */\n\n  }, {\n    key: \"setVariable\",\n    value: function setVariable(name, value) {\n      this.parser.setVariable(name, value);\n    }\n    /**\n     * Get variable name.\n     *\n     * @param {String} name Variable name.\n     * @returns {*}\n     */\n\n  }, {\n    key: \"getVariable\",\n    value: function getVariable(name) {\n      return this.parser.getVariable(name);\n    }\n    /**\n     * Apply changes to the sheet.\n     *\n     * @param {Number} row Physical row index.\n     * @param {Number} column Physical column index.\n     * @param {*} newValue Current cell value.\n     */\n\n  }, {\n    key: \"applyChanges\",\n    value: function applyChanges(row, column, newValue) {\n      // Remove formula description for old expression\n      // TODO: Move this to recalculate()\n      this.matrix.remove({\n        row: row,\n        column: column\n      }); // TODO: Move this to recalculate()\n\n      if (isFormulaExpression(newValue)) {\n        // ...and create new for new changed formula expression\n        this.parseExpression(new CellValue(row, column), newValue.substr(1));\n      }\n\n      var deps = this.getCellDependencies.apply(this, _toConsumableArray(this.t.toVisual(row, column)));\n      arrayEach(deps, function (cellValue) {\n        cellValue.setState(CellValue.STATE_OUT_OFF_DATE);\n      });\n      this._state = STATE_NEED_REBUILD;\n    }\n    /**\n     * Parse and evaluate formula for provided cell.\n     *\n     * @param {CellValue|Object} cellValue Cell value object.\n     * @param {String} formula Value to evaluate.\n     */\n\n  }, {\n    key: \"parseExpression\",\n    value: function parseExpression(cellValue, formula) {\n      cellValue.setState(CellValue.STATE_COMPUTING);\n      this._processingCell = cellValue;\n\n      var _this$parser$parse = this.parser.parse(toUpperCaseFormula(formula)),\n          error = _this$parser$parse.error,\n          result = _this$parser$parse.result;\n\n      if (isFormulaExpression(result)) {\n        this.parseExpression(cellValue, result.substr(1));\n      } else {\n        cellValue.setValue(result);\n        cellValue.setError(error);\n        cellValue.setState(CellValue.STATE_UP_TO_DATE);\n      }\n\n      this.matrix.add(cellValue);\n      this._processingCell = null;\n    }\n    /**\n     * Get cell value object at specified physical coordinates.\n     *\n     * @param {Number} row Physical row index.\n     * @param {Number} column Physical column index.\n     * @returns {CellValue|undefined}\n     */\n\n  }, {\n    key: \"getCellAt\",\n    value: function getCellAt(row, column) {\n      return this.matrix.getCellAt(row, column);\n    }\n    /**\n     * Get cell dependencies at specified physical coordinates.\n     *\n     * @param {Number} row Physical row index.\n     * @param {Number} column Physical column index.\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getCellDependencies\",\n    value: function getCellDependencies(row, column) {\n      return this.matrix.getDependencies({\n        row: row,\n        column: column\n      });\n    }\n    /**\n     * Listener for parser cell value.\n     *\n     * @private\n     * @param {Object} cellCoords Cell coordinates.\n     * @param {Function} done Function to call with valid cell value.\n     */\n\n  }, {\n    key: \"_onCallCellValue\",\n    value: function _onCallCellValue(_ref, done) {\n      var row = _ref.row,\n          column = _ref.column;\n      var cell = new CellReference(row, column);\n\n      if (!this.dataProvider.isInDataRange(cell.row, cell.column)) {\n        throw Error(ERROR_REF);\n      }\n\n      this.matrix.registerCellRef(cell);\n\n      this._processingCell.addPrecedent(cell);\n\n      var cellValue = this.dataProvider.getRawDataAtCell(row.index, column.index);\n\n      if (isFormulaError(cellValue)) {\n        var computedCell = this.matrix.getCellAt(row.index, column.index);\n\n        if (computedCell && computedCell.hasError()) {\n          throw Error(cellValue);\n        }\n      }\n\n      if (isFormulaExpression(cellValue)) {\n        var _this$parser$parse2 = this.parser.parse(cellValue.substr(1)),\n            error = _this$parser$parse2.error,\n            result = _this$parser$parse2.result;\n\n        if (error) {\n          throw Error(error);\n        }\n\n        done(result);\n      } else {\n        done(cellValue);\n      }\n    }\n    /**\n     * Listener for parser cells (range) value.\n     *\n     * @private\n     * @param {Object} startCell Cell coordinates (top-left corner coordinate).\n     * @param {Object} endCell Cell coordinates (bottom-right corner coordinate).\n     * @param {Function} done Function to call with valid cells values.\n     */\n\n  }, {\n    key: \"_onCallRangeValue\",\n    value: function _onCallRangeValue(_ref2, _ref3, done) {\n      var _this4 = this;\n\n      var startRow = _ref2.row,\n          startColumn = _ref2.column;\n      var endRow = _ref3.row,\n          endColumn = _ref3.column;\n      var cellValues = this.dataProvider.getRawDataByRange(startRow.index, startColumn.index, endRow.index, endColumn.index);\n\n      var mapRowData = function mapRowData(rowData, rowIndex) {\n        return arrayMap(rowData, function (cellData, columnIndex) {\n          var rowCellCoord = startRow.index + rowIndex;\n          var columnCellCoord = startColumn.index + columnIndex;\n          var cell = new CellReference(rowCellCoord, columnCellCoord);\n\n          if (!_this4.dataProvider.isInDataRange(cell.row, cell.column)) {\n            throw Error(ERROR_REF);\n          }\n\n          _this4.matrix.registerCellRef(cell);\n\n          _this4._processingCell.addPrecedent(cell);\n\n          var newCellData = cellData;\n\n          if (isFormulaError(newCellData)) {\n            var computedCell = _this4.matrix.getCellAt(cell.row, cell.column);\n\n            if (computedCell && computedCell.hasError()) {\n              throw Error(newCellData);\n            }\n          }\n\n          if (isFormulaExpression(newCellData)) {\n            var _this4$parser$parse = _this4.parser.parse(newCellData.substr(1)),\n                error = _this4$parser$parse.error,\n                result = _this4$parser$parse.result;\n\n            if (error) {\n              throw Error(error);\n            }\n\n            newCellData = result;\n          }\n\n          return newCellData;\n        });\n      };\n\n      var calculatedCellValues = arrayMap(cellValues, function (rowData, rowIndex) {\n        return mapRowData(rowData, rowIndex);\n      });\n      done(calculatedCellValues);\n    }\n    /**\n     * On after alter sheet listener.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_onAfterAlter\",\n    value: function _onAfterAlter() {\n      this.recalculateOptimized();\n    }\n    /**\n     * Destroy class.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.hot = null;\n      this.t = null;\n      this.dataProvider.destroy();\n      this.dataProvider = null;\n      this.alterManager.destroy();\n      this.alterManager = null;\n      this.parser = null;\n      this.matrix.reset();\n      this.matrix = null;\n    }\n  }]);\n\n  return Sheet;\n}();\n\nmixin(Sheet, localHooks);\nexport default Sheet;"],"mappings":"AAUA,SAASA,kBAAkB,CAACC,GAAG,EAAE;EAAE,OAAOC,kBAAkB,CAACD,GAAG,CAAC,IAAIE,gBAAgB,CAACF,GAAG,CAAC,IAAIG,kBAAkB,EAAE;AAAE;AAEpH,SAASA,kBAAkB,GAAG;EAAE,MAAM,IAAIC,SAAS,CAAC,iDAAiD,CAAC;AAAE;AAExG,SAASF,gBAAgB,CAACG,IAAI,EAAE;EAAE,IAAIC,MAAM,CAACC,QAAQ,IAAIC,MAAM,CAACH,IAAI,CAAC,IAAIG,MAAM,CAACC,SAAS,CAACC,QAAQ,CAACC,IAAI,CAACN,IAAI,CAAC,KAAK,oBAAoB,EAAE,OAAOO,KAAK,CAACC,IAAI,CAACR,IAAI,CAAC;AAAE;AAEjK,SAASJ,kBAAkB,CAACD,GAAG,EAAE;EAAE,IAAIY,KAAK,CAACE,OAAO,CAACd,GAAG,CAAC,EAAE;IAAE,KAAK,IAAIe,CAAC,GAAG,CAAC,EAAEC,IAAI,GAAG,IAAIJ,KAAK,CAACZ,GAAG,CAACiB,MAAM,CAAC,EAAEF,CAAC,GAAGf,GAAG,CAACiB,MAAM,EAAEF,CAAC,EAAE,EAAE;MAAEC,IAAI,CAACD,CAAC,CAAC,GAAGf,GAAG,CAACe,CAAC,CAAC;IAAE;IAAE,OAAOC,IAAI;EAAE;AAAE;AAErK,SAASE,eAAe,CAACC,QAAQ,EAAEC,WAAW,EAAE;EAAE,IAAI,EAAED,QAAQ,YAAYC,WAAW,CAAC,EAAE;IAAE,MAAM,IAAIhB,SAAS,CAAC,mCAAmC,CAAC;EAAE;AAAE;AAExJ,SAASiB,iBAAiB,CAACC,MAAM,EAAEC,KAAK,EAAE;EAAE,KAAK,IAAIR,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGQ,KAAK,CAACN,MAAM,EAAEF,CAAC,EAAE,EAAE;IAAE,IAAIS,UAAU,GAAGD,KAAK,CAACR,CAAC,CAAC;IAAES,UAAU,CAACC,UAAU,GAAGD,UAAU,CAACC,UAAU,IAAI,KAAK;IAAED,UAAU,CAACE,YAAY,GAAG,IAAI;IAAE,IAAI,OAAO,IAAIF,UAAU,EAAEA,UAAU,CAACG,QAAQ,GAAG,IAAI;IAAEnB,MAAM,CAACoB,cAAc,CAACN,MAAM,EAAEE,UAAU,CAACK,GAAG,EAAEL,UAAU,CAAC;EAAE;AAAE;AAE5T,SAASM,YAAY,CAACV,WAAW,EAAEW,UAAU,EAAEC,WAAW,EAAE;EAAE,IAAID,UAAU,EAAEV,iBAAiB,CAACD,WAAW,CAACX,SAAS,EAAEsB,UAAU,CAAC;EAAE,IAAIC,WAAW,EAAEX,iBAAiB,CAACD,WAAW,EAAEY,WAAW,CAAC;EAAE,OAAOZ,WAAW;AAAE;AAEtN,SAASa,MAAM,EAAEC,SAAS,EAAEC,KAAK,IAAIC,cAAc,QAAQ,oBAAoB;AAC/E,SAASC,SAAS,EAAEC,QAAQ,QAAQ,qBAAqB;AACzD,OAAOC,UAAU,MAAM,yBAAyB;AAChD,SAASC,aAAa,QAAQ,8BAA8B;AAC5D,SAASC,KAAK,QAAQ,sBAAsB;AAC5C,OAAOC,SAAS,MAAM,cAAc;AACpC,OAAOC,aAAa,MAAM,kBAAkB;AAC5C,SAASC,mBAAmB,EAAEC,kBAAkB,QAAQ,SAAS;AACjE,OAAOC,MAAM,MAAM,UAAU;AAC7B,OAAOC,YAAY,MAAM,gBAAgB;AACzC,IAAIC,gBAAgB,GAAG,CAAC;AACxB,IAAIC,kBAAkB,GAAG,CAAC;AAC1B,IAAIC,uBAAuB,GAAG,CAAC;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIC,KAAK,GACT;AACA,YAAY;EACV,SAASA,KAAK,CAACC,GAAG,EAAEC,YAAY,EAAE;IAChC,IAAIC,KAAK,GAAG,IAAI;IAEhBpC,eAAe,CAAC,IAAI,EAAEiC,KAAK,CAAC;;IAE5B;AACJ;AACA;AACA;AACA;IACI,IAAI,CAACC,GAAG,GAAGA,GAAG;IACd;AACJ;AACA;AACA;AACA;;IAEI,IAAI,CAACG,CAAC,GAAGf,aAAa,CAAC,IAAI,CAACY,GAAG,CAAC;IAChC;AACJ;AACA;AACA;AACA;;IAEI,IAAI,CAACC,YAAY,GAAGA,YAAY;IAChC;AACJ;AACA;AACA;AACA;;IAEI,IAAI,CAACG,MAAM,GAAG,IAAIvB,MAAM,EAAE;IAC1B;AACJ;AACA;AACA;AACA;;IAEI,IAAI,CAACwB,MAAM,GAAG,IAAIX,MAAM,CAAC,IAAI,CAACS,CAAC,CAAC;IAChC;AACJ;AACA;AACA;AACA;;IAEI,IAAI,CAACG,YAAY,GAAG,IAAIX,YAAY,CAAC,IAAI,CAAC;IAC1C;AACJ;AACA;AACA;AACA;AACA;;IAEI,IAAI,CAACY,eAAe,GAAG,IAAI;IAC3B;AACJ;AACA;AACA;AACA;AACA;;IAEI,IAAI,CAACC,MAAM,GAAGV,uBAAuB;IACrC,IAAI,CAACM,MAAM,CAACK,EAAE,CAAC,eAAe,EAAE,YAAY;MAC1C,OAAOP,KAAK,CAACQ,gBAAgB,CAACC,KAAK,CAACT,KAAK,EAAEU,SAAS,CAAC;IACvD,CAAC,CAAC;IACF,IAAI,CAACR,MAAM,CAACK,EAAE,CAAC,gBAAgB,EAAE,YAAY;MAC3C,OAAOP,KAAK,CAACW,iBAAiB,CAACF,KAAK,CAACT,KAAK,EAAEU,SAAS,CAAC;IACxD,CAAC,CAAC;IACF,IAAI,CAACN,YAAY,CAACQ,YAAY,CAAC,YAAY,EAAE,YAAY;MACvD,OAAOZ,KAAK,CAACa,aAAa,CAACJ,KAAK,CAACT,KAAK,EAAEU,SAAS,CAAC;IACpD,CAAC,CAAC;EACJ;EACA;AACF;AACA;;EAGElC,YAAY,CAACqB,KAAK,EAAE,CAAC;IACnBtB,GAAG,EAAE,aAAa;IAClBuC,KAAK,EAAE,SAASC,WAAW,GAAG;MAC5B,QAAQ,IAAI,CAACT,MAAM;QACjB,KAAKV,uBAAuB;UAC1B,IAAI,CAACoB,eAAe,EAAE;UACtB;QAEF,KAAKrB,kBAAkB;UACrB,IAAI,CAACsB,oBAAoB,EAAE;UAC3B;QAEF;UACE;MAAM;IAEZ;IACA;AACJ;AACA;EAEE,CAAC,EAAE;IACD1C,GAAG,EAAE,sBAAsB;IAC3BuC,KAAK,EAAE,SAASG,oBAAoB,GAAG;MACrC,IAAIC,MAAM,GAAG,IAAI;MAEjB,IAAIC,KAAK,GAAG,IAAI,CAAChB,MAAM,CAACiB,iBAAiB,EAAE;MAC3CrC,SAAS,CAACoC,KAAK,EAAE,UAAUE,SAAS,EAAE;QACpC,IAAIP,KAAK,GAAGI,MAAM,CAACnB,YAAY,CAACuB,mBAAmB,CAACD,SAAS,CAACE,GAAG,EAAEF,SAAS,CAACG,MAAM,CAAC;QAEpF,IAAIlC,mBAAmB,CAACwB,KAAK,CAAC,EAAE;UAC9BI,MAAM,CAACO,eAAe,CAACJ,SAAS,EAAEP,KAAK,CAACY,MAAM,CAAC,CAAC,CAAC,CAAC;QACpD;MACF,CAAC,CAAC;MACF,IAAI,CAACpB,MAAM,GAAGZ,gBAAgB;MAC9B,IAAI,CAACiC,aAAa,CAAC,kBAAkB,EAAER,KAAK,EAAE,WAAW,CAAC;IAC5D;IACA;AACJ;AACA;EAEE,CAAC,EAAE;IACD5C,GAAG,EAAE,iBAAiB;IACtBuC,KAAK,EAAE,SAASE,eAAe,GAAG;MAChC,IAAIY,MAAM,GAAG,IAAI;MAEjB,IAAIT,KAAK,GAAG,IAAI,CAACpB,YAAY,CAAC8B,oBAAoB,EAAE;MACpD,IAAI,CAAC1B,MAAM,CAAC2B,KAAK,EAAE;MACnB/C,SAAS,CAACoC,KAAK,EAAE,UAAUY,OAAO,EAAER,GAAG,EAAE;QACvCxC,SAAS,CAACgD,OAAO,EAAE,UAAUjB,KAAK,EAAEU,MAAM,EAAE;UAC1C,IAAIlC,mBAAmB,CAACwB,KAAK,CAAC,EAAE;YAC9Bc,MAAM,CAACH,eAAe,CAAC,IAAIrC,SAAS,CAACmC,GAAG,EAAEC,MAAM,CAAC,EAAEV,KAAK,CAACY,MAAM,CAAC,CAAC,CAAC,CAAC;UACrE;QACF,CAAC,CAAC;MACJ,CAAC,CAAC;MACF,IAAI,CAACpB,MAAM,GAAGZ,gBAAgB;MAC9B,IAAI,CAACiC,aAAa,CAAC,kBAAkB,EAAER,KAAK,EAAE,MAAM,CAAC;IACvD;IACA;AACJ;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACD5C,GAAG,EAAE,aAAa;IAClBuC,KAAK,EAAE,SAASkB,WAAW,CAACC,IAAI,EAAEnB,KAAK,EAAE;MACvC,IAAI,CAACZ,MAAM,CAAC8B,WAAW,CAACC,IAAI,EAAEnB,KAAK,CAAC;IACtC;IACA;AACJ;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDvC,GAAG,EAAE,aAAa;IAClBuC,KAAK,EAAE,SAASoB,WAAW,CAACD,IAAI,EAAE;MAChC,OAAO,IAAI,CAAC/B,MAAM,CAACgC,WAAW,CAACD,IAAI,CAAC;IACtC;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACD1D,GAAG,EAAE,cAAc;IACnBuC,KAAK,EAAE,SAASqB,YAAY,CAACZ,GAAG,EAAEC,MAAM,EAAEY,QAAQ,EAAE;MAClD;MACA;MACA,IAAI,CAACjC,MAAM,CAACkC,MAAM,CAAC;QACjBd,GAAG,EAAEA,GAAG;QACRC,MAAM,EAAEA;MACV,CAAC,CAAC,CAAC,CAAC;;MAEJ,IAAIlC,mBAAmB,CAAC8C,QAAQ,CAAC,EAAE;QACjC;QACA,IAAI,CAACX,eAAe,CAAC,IAAIrC,SAAS,CAACmC,GAAG,EAAEC,MAAM,CAAC,EAAEY,QAAQ,CAACV,MAAM,CAAC,CAAC,CAAC,CAAC;MACtE;MAEA,IAAIY,IAAI,GAAG,IAAI,CAACC,mBAAmB,CAAC9B,KAAK,CAAC,IAAI,EAAEhE,kBAAkB,CAAC,IAAI,CAACwD,CAAC,CAACuC,QAAQ,CAACjB,GAAG,EAAEC,MAAM,CAAC,CAAC,CAAC;MACjGzC,SAAS,CAACuD,IAAI,EAAE,UAAUjB,SAAS,EAAE;QACnCA,SAAS,CAACoB,QAAQ,CAACrD,SAAS,CAACsD,kBAAkB,CAAC;MAClD,CAAC,CAAC;MACF,IAAI,CAACpC,MAAM,GAAGX,kBAAkB;IAClC;IACA;AACJ;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDpB,GAAG,EAAE,iBAAiB;IACtBuC,KAAK,EAAE,SAASW,eAAe,CAACJ,SAAS,EAAEsB,OAAO,EAAE;MAClDtB,SAAS,CAACoB,QAAQ,CAACrD,SAAS,CAACwD,eAAe,CAAC;MAC7C,IAAI,CAACvC,eAAe,GAAGgB,SAAS;MAEhC,IAAIwB,kBAAkB,GAAG,IAAI,CAAC3C,MAAM,CAAC4C,KAAK,CAACvD,kBAAkB,CAACoD,OAAO,CAAC,CAAC;QACnE9D,KAAK,GAAGgE,kBAAkB,CAAChE,KAAK;QAChCkE,MAAM,GAAGF,kBAAkB,CAACE,MAAM;MAEtC,IAAIzD,mBAAmB,CAACyD,MAAM,CAAC,EAAE;QAC/B,IAAI,CAACtB,eAAe,CAACJ,SAAS,EAAE0B,MAAM,CAACrB,MAAM,CAAC,CAAC,CAAC,CAAC;MACnD,CAAC,MAAM;QACLL,SAAS,CAAC2B,QAAQ,CAACD,MAAM,CAAC;QAC1B1B,SAAS,CAAC4B,QAAQ,CAACpE,KAAK,CAAC;QACzBwC,SAAS,CAACoB,QAAQ,CAACrD,SAAS,CAACM,gBAAgB,CAAC;MAChD;MAEA,IAAI,CAACS,MAAM,CAAC+C,GAAG,CAAC7B,SAAS,CAAC;MAC1B,IAAI,CAAChB,eAAe,GAAG,IAAI;IAC7B;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACD9B,GAAG,EAAE,WAAW;IAChBuC,KAAK,EAAE,SAASqC,SAAS,CAAC5B,GAAG,EAAEC,MAAM,EAAE;MACrC,OAAO,IAAI,CAACrB,MAAM,CAACgD,SAAS,CAAC5B,GAAG,EAAEC,MAAM,CAAC;IAC3C;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDjD,GAAG,EAAE,qBAAqB;IAC1BuC,KAAK,EAAE,SAASyB,mBAAmB,CAAChB,GAAG,EAAEC,MAAM,EAAE;MAC/C,OAAO,IAAI,CAACrB,MAAM,CAACiD,eAAe,CAAC;QACjC7B,GAAG,EAAEA,GAAG;QACRC,MAAM,EAAEA;MACV,CAAC,CAAC;IACJ;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDjD,GAAG,EAAE,kBAAkB;IACvBuC,KAAK,EAAE,SAASN,gBAAgB,CAAC6C,IAAI,EAAEC,IAAI,EAAE;MAC3C,IAAI/B,GAAG,GAAG8B,IAAI,CAAC9B,GAAG;QACdC,MAAM,GAAG6B,IAAI,CAAC7B,MAAM;MACxB,IAAI+B,IAAI,GAAG,IAAIlE,aAAa,CAACkC,GAAG,EAAEC,MAAM,CAAC;MAEzC,IAAI,CAAC,IAAI,CAACzB,YAAY,CAACyD,aAAa,CAACD,IAAI,CAAChC,GAAG,EAAEgC,IAAI,CAAC/B,MAAM,CAAC,EAAE;QAC3D,MAAMiC,KAAK,CAAC7E,SAAS,CAAC;MACxB;MAEA,IAAI,CAACuB,MAAM,CAACuD,eAAe,CAACH,IAAI,CAAC;MAEjC,IAAI,CAAClD,eAAe,CAACsD,YAAY,CAACJ,IAAI,CAAC;MAEvC,IAAIlC,SAAS,GAAG,IAAI,CAACtB,YAAY,CAAC6D,gBAAgB,CAACrC,GAAG,CAACsC,KAAK,EAAErC,MAAM,CAACqC,KAAK,CAAC;MAE3E,IAAI/E,cAAc,CAACuC,SAAS,CAAC,EAAE;QAC7B,IAAIyC,YAAY,GAAG,IAAI,CAAC3D,MAAM,CAACgD,SAAS,CAAC5B,GAAG,CAACsC,KAAK,EAAErC,MAAM,CAACqC,KAAK,CAAC;QAEjE,IAAIC,YAAY,IAAIA,YAAY,CAACC,QAAQ,EAAE,EAAE;UAC3C,MAAMN,KAAK,CAACpC,SAAS,CAAC;QACxB;MACF;MAEA,IAAI/B,mBAAmB,CAAC+B,SAAS,CAAC,EAAE;QAClC,IAAI2C,mBAAmB,GAAG,IAAI,CAAC9D,MAAM,CAAC4C,KAAK,CAACzB,SAAS,CAACK,MAAM,CAAC,CAAC,CAAC,CAAC;UAC5D7C,KAAK,GAAGmF,mBAAmB,CAACnF,KAAK;UACjCkE,MAAM,GAAGiB,mBAAmB,CAACjB,MAAM;QAEvC,IAAIlE,KAAK,EAAE;UACT,MAAM4E,KAAK,CAAC5E,KAAK,CAAC;QACpB;QAEAyE,IAAI,CAACP,MAAM,CAAC;MACd,CAAC,MAAM;QACLO,IAAI,CAACjC,SAAS,CAAC;MACjB;IACF;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACD9C,GAAG,EAAE,mBAAmB;IACxBuC,KAAK,EAAE,SAASH,iBAAiB,CAACsD,KAAK,EAAEC,KAAK,EAAEZ,IAAI,EAAE;MACpD,IAAIa,MAAM,GAAG,IAAI;MAEjB,IAAIC,QAAQ,GAAGH,KAAK,CAAC1C,GAAG;QACpB8C,WAAW,GAAGJ,KAAK,CAACzC,MAAM;MAC9B,IAAI8C,MAAM,GAAGJ,KAAK,CAAC3C,GAAG;QAClBgD,SAAS,GAAGL,KAAK,CAAC1C,MAAM;MAC5B,IAAIgD,UAAU,GAAG,IAAI,CAACzE,YAAY,CAAC0E,iBAAiB,CAACL,QAAQ,CAACP,KAAK,EAAEQ,WAAW,CAACR,KAAK,EAAES,MAAM,CAACT,KAAK,EAAEU,SAAS,CAACV,KAAK,CAAC;MAEtH,IAAIa,UAAU,GAAG,SAASA,UAAU,CAAC3C,OAAO,EAAE4C,QAAQ,EAAE;QACtD,OAAO3F,QAAQ,CAAC+C,OAAO,EAAE,UAAU6C,QAAQ,EAAEC,WAAW,EAAE;UACxD,IAAIC,YAAY,GAAGV,QAAQ,CAACP,KAAK,GAAGc,QAAQ;UAC5C,IAAII,eAAe,GAAGV,WAAW,CAACR,KAAK,GAAGgB,WAAW;UACrD,IAAItB,IAAI,GAAG,IAAIlE,aAAa,CAACyF,YAAY,EAAEC,eAAe,CAAC;UAE3D,IAAI,CAACZ,MAAM,CAACpE,YAAY,CAACyD,aAAa,CAACD,IAAI,CAAChC,GAAG,EAAEgC,IAAI,CAAC/B,MAAM,CAAC,EAAE;YAC7D,MAAMiC,KAAK,CAAC7E,SAAS,CAAC;UACxB;UAEAuF,MAAM,CAAChE,MAAM,CAACuD,eAAe,CAACH,IAAI,CAAC;UAEnCY,MAAM,CAAC9D,eAAe,CAACsD,YAAY,CAACJ,IAAI,CAAC;UAEzC,IAAIyB,WAAW,GAAGJ,QAAQ;UAE1B,IAAI9F,cAAc,CAACkG,WAAW,CAAC,EAAE;YAC/B,IAAIlB,YAAY,GAAGK,MAAM,CAAChE,MAAM,CAACgD,SAAS,CAACI,IAAI,CAAChC,GAAG,EAAEgC,IAAI,CAAC/B,MAAM,CAAC;YAEjE,IAAIsC,YAAY,IAAIA,YAAY,CAACC,QAAQ,EAAE,EAAE;cAC3C,MAAMN,KAAK,CAACuB,WAAW,CAAC;YAC1B;UACF;UAEA,IAAI1F,mBAAmB,CAAC0F,WAAW,CAAC,EAAE;YACpC,IAAIC,mBAAmB,GAAGd,MAAM,CAACjE,MAAM,CAAC4C,KAAK,CAACkC,WAAW,CAACtD,MAAM,CAAC,CAAC,CAAC,CAAC;cAChE7C,KAAK,GAAGoG,mBAAmB,CAACpG,KAAK;cACjCkE,MAAM,GAAGkC,mBAAmB,CAAClC,MAAM;YAEvC,IAAIlE,KAAK,EAAE;cACT,MAAM4E,KAAK,CAAC5E,KAAK,CAAC;YACpB;YAEAmG,WAAW,GAAGjC,MAAM;UACtB;UAEA,OAAOiC,WAAW;QACpB,CAAC,CAAC;MACJ,CAAC;MAED,IAAIE,oBAAoB,GAAGlG,QAAQ,CAACwF,UAAU,EAAE,UAAUzC,OAAO,EAAE4C,QAAQ,EAAE;QAC3E,OAAOD,UAAU,CAAC3C,OAAO,EAAE4C,QAAQ,CAAC;MACtC,CAAC,CAAC;MACFrB,IAAI,CAAC4B,oBAAoB,CAAC;IAC5B;IACA;AACJ;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACD3G,GAAG,EAAE,eAAe;IACpBuC,KAAK,EAAE,SAASD,aAAa,GAAG;MAC9B,IAAI,CAACI,oBAAoB,EAAE;IAC7B;IACA;AACJ;AACA;EAEE,CAAC,EAAE;IACD1C,GAAG,EAAE,SAAS;IACduC,KAAK,EAAE,SAASqE,OAAO,GAAG;MACxB,IAAI,CAACrF,GAAG,GAAG,IAAI;MACf,IAAI,CAACG,CAAC,GAAG,IAAI;MACb,IAAI,CAACF,YAAY,CAACoF,OAAO,EAAE;MAC3B,IAAI,CAACpF,YAAY,GAAG,IAAI;MACxB,IAAI,CAACK,YAAY,CAAC+E,OAAO,EAAE;MAC3B,IAAI,CAAC/E,YAAY,GAAG,IAAI;MACxB,IAAI,CAACF,MAAM,GAAG,IAAI;MAClB,IAAI,CAACC,MAAM,CAAC2B,KAAK,EAAE;MACnB,IAAI,CAAC3B,MAAM,GAAG,IAAI;IACpB;EACF,CAAC,CAAC,CAAC;EAEH,OAAON,KAAK;AACd,CAAC,EAAE;AAEHV,KAAK,CAACU,KAAK,EAAEZ,UAAU,CAAC;AACxB,eAAeY,KAAK"},"metadata":{},"sourceType":"module"}