{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n    return arr2;\n  }\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n  return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n      return desc.value;\n    };\n  }\n  return _get(target, property, receiver || target);\n}\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n  return object;\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nimport BasePlugin from './../_base';\nimport Hooks from './../../pluginHooks';\nimport { registerPlugin } from './../../plugins';\nimport { stopImmediatePropagation } from './../../helpers/dom/event';\nimport { CellCoords, CellRange } from './../../3rdparty/walkontable/src';\nimport MergedCellsCollection from './cellsCollection';\nimport MergedCellCoords from './cellCoords';\nimport AutofillCalculations from './calculations/autofill';\nimport SelectionCalculations from './calculations/selection';\nimport toggleMergeItem from './contextMenuItem/toggleMerge';\nimport { arrayEach } from '../../helpers/array';\nimport { clone } from '../../helpers/object';\nimport { warn } from '../../helpers/console';\nimport { rangeEach } from '../../helpers/number';\nimport { applySpanProperties } from './utils';\nHooks.getSingleton().register('beforeMergeCells');\nHooks.getSingleton().register('afterMergeCells');\nHooks.getSingleton().register('beforeUnmergeCells');\nHooks.getSingleton().register('afterUnmergeCells');\nvar privatePool = new WeakMap();\n/**\n * @plugin MergeCells\n *\n * @description\n * Plugin, which allows merging cells in the table (using the initial configuration, API or context menu).\n *\n * @example\n *\n * ```js\n * const hot = new Handsontable(document.getElementById('example'), {\n *  data: getData(),\n *  mergeCells: [\n *    {row: 0, col: 3, rowspan: 3, colspan: 3},\n *    {row: 2, col: 6, rowspan: 2, colspan: 2},\n *    {row: 4, col: 8, rowspan: 3, colspan: 3}\n *  ],\n * ```\n */\n\nvar MergeCells = /*#__PURE__*/\nfunction (_BasePlugin) {\n  _inherits(MergeCells, _BasePlugin);\n  function MergeCells(hotInstance) {\n    var _this;\n    _classCallCheck(this, MergeCells);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MergeCells).call(this, hotInstance));\n    privatePool.set(_assertThisInitialized(_this), {\n      lastDesiredCoords: null\n    });\n    /**\n     * A container for all the merged cells.\n     *\n     * @private\n     * @type {MergedCellsCollection}\n     */\n\n    _this.mergedCellsCollection = null;\n    /**\n     * Instance of the class responsible for all the autofill-related calculations.\n     *\n     * @private\n     * @type {AutofillCalculations}\n     */\n\n    _this.autofillCalculations = null;\n    /**\n     * Instance of the class responsible for the selection-related calculations.\n     *\n     * @private\n     * @type {SelectionCalculations}\n     */\n\n    _this.selectionCalculations = null;\n    return _this;\n  }\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` than the {@link MergeCells#enablePlugin} method is called.\n   *\n   * @returns {Boolean}\n   */\n\n  _createClass(MergeCells, [{\n    key: \"isEnabled\",\n    value: function isEnabled() {\n      return !!this.hot.getSettings().mergeCells;\n    }\n    /**\n     * Enables the plugin functionality for this Handsontable instance.\n     */\n  }, {\n    key: \"enablePlugin\",\n    value: function enablePlugin() {\n      var _this2 = this;\n      if (this.enabled) {\n        return;\n      }\n      this.mergedCellsCollection = new MergedCellsCollection(this);\n      this.autofillCalculations = new AutofillCalculations(this);\n      this.selectionCalculations = new SelectionCalculations(this);\n      this.addHook('afterInit', function () {\n        return _this2.onAfterInit.apply(_this2, arguments);\n      });\n      this.addHook('beforeKeyDown', function () {\n        return _this2.onBeforeKeyDown.apply(_this2, arguments);\n      });\n      this.addHook('modifyTransformStart', function () {\n        return _this2.onModifyTransformStart.apply(_this2, arguments);\n      });\n      this.addHook('afterModifyTransformStart', function () {\n        return _this2.onAfterModifyTransformStart.apply(_this2, arguments);\n      });\n      this.addHook('modifyTransformEnd', function () {\n        return _this2.onModifyTransformEnd.apply(_this2, arguments);\n      });\n      this.addHook('modifyGetCellCoords', function () {\n        return _this2.onModifyGetCellCoords.apply(_this2, arguments);\n      });\n      this.addHook('beforeSetRangeEnd', function () {\n        return _this2.onBeforeSetRangeEnd.apply(_this2, arguments);\n      });\n      this.addHook('afterIsMultipleSelection', function () {\n        return _this2.onAfterIsMultipleSelection.apply(_this2, arguments);\n      });\n      this.addHook('afterRenderer', function () {\n        return _this2.onAfterRenderer.apply(_this2, arguments);\n      });\n      this.addHook('afterContextMenuDefaultOptions', function () {\n        return _this2.addMergeActionsToContextMenu.apply(_this2, arguments);\n      });\n      this.addHook('afterGetCellMeta', function () {\n        return _this2.onAfterGetCellMeta.apply(_this2, arguments);\n      });\n      this.addHook('afterViewportRowCalculatorOverride', function () {\n        return _this2.onAfterViewportRowCalculatorOverride.apply(_this2, arguments);\n      });\n      this.addHook('afterViewportColumnCalculatorOverride', function () {\n        return _this2.onAfterViewportColumnCalculatorOverride.apply(_this2, arguments);\n      });\n      this.addHook('modifyAutofillRange', function () {\n        return _this2.onModifyAutofillRange.apply(_this2, arguments);\n      });\n      this.addHook('afterCreateCol', function () {\n        return _this2.onAfterCreateCol.apply(_this2, arguments);\n      });\n      this.addHook('afterRemoveCol', function () {\n        return _this2.onAfterRemoveCol.apply(_this2, arguments);\n      });\n      this.addHook('afterCreateRow', function () {\n        return _this2.onAfterCreateRow.apply(_this2, arguments);\n      });\n      this.addHook('afterRemoveRow', function () {\n        return _this2.onAfterRemoveRow.apply(_this2, arguments);\n      });\n      this.addHook('afterChange', function () {\n        return _this2.onAfterChange.apply(_this2, arguments);\n      });\n      this.addHook('beforeDrawBorders', function () {\n        return _this2.onBeforeDrawAreaBorders.apply(_this2, arguments);\n      });\n      this.addHook('afterDrawSelection', function () {\n        return _this2.onAfterDrawSelection.apply(_this2, arguments);\n      });\n      this.addHook('beforeRemoveCellClassNames', function () {\n        return _this2.onBeforeRemoveCellClassNames.apply(_this2, arguments);\n      });\n      _get(_getPrototypeOf(MergeCells.prototype), \"enablePlugin\", this).call(this);\n    }\n    /**\n     * Disables the plugin functionality for this Handsontable instance.\n     */\n  }, {\n    key: \"disablePlugin\",\n    value: function disablePlugin() {\n      this.clearCollections();\n      this.hot.render();\n      _get(_getPrototypeOf(MergeCells.prototype), \"disablePlugin\", this).call(this);\n    }\n    /**\n     * Updates the plugin state. This method is executed when {@link Core#updateSettings} is invoked.\n     */\n  }, {\n    key: \"updatePlugin\",\n    value: function updatePlugin() {\n      var settings = this.hot.getSettings().mergeCells;\n      this.disablePlugin();\n      this.enablePlugin();\n      this.generateFromSettings(settings);\n      _get(_getPrototypeOf(MergeCells.prototype), \"updatePlugin\", this).call(this);\n    }\n    /**\n     * Validates a single setting object, represented by a single merged cell information object.\n     *\n     * @private\n     * @param {Object} setting An object with `row`, `col`, `rowspan` and `colspan` properties.\n     * @return {Boolean}\n     */\n  }, {\n    key: \"validateSetting\",\n    value: function validateSetting(setting) {\n      var valid = true;\n      if (!setting) {\n        return false;\n      }\n      if (MergedCellCoords.containsNegativeValues(setting)) {\n        warn(MergedCellCoords.NEGATIVE_VALUES_WARNING(setting));\n        valid = false;\n      } else if (MergedCellCoords.isOutOfBounds(setting, this.hot.countRows(), this.hot.countCols())) {\n        warn(MergedCellCoords.IS_OUT_OF_BOUNDS_WARNING(setting));\n        valid = false;\n      } else if (MergedCellCoords.isSingleCell(setting)) {\n        warn(MergedCellCoords.IS_SINGLE_CELL(setting));\n        valid = false;\n      } else if (MergedCellCoords.containsZeroSpan(setting)) {\n        warn(MergedCellCoords.ZERO_SPAN_WARNING(setting));\n        valid = false;\n      }\n      return valid;\n    }\n    /**\n     * Generates the merged cells from the settings provided to the plugin.\n     *\n     * @private\n     * @param {Array|Boolean} settings The settings provided to the plugin.\n     */\n  }, {\n    key: \"generateFromSettings\",\n    value: function generateFromSettings(settings) {\n      var _this3 = this;\n      if (Array.isArray(settings)) {\n        var _this$hot;\n        var populationArgumentsList = [];\n        arrayEach(settings, function (setting) {\n          if (!_this3.validateSetting(setting)) {\n            return;\n          }\n          var highlight = new CellCoords(setting.row, setting.col);\n          var rangeEnd = new CellCoords(setting.row + setting.rowspan - 1, setting.col + setting.colspan - 1);\n          var mergeRange = new CellRange(highlight, highlight, rangeEnd);\n          populationArgumentsList.push(_this3.mergeRange(mergeRange, true, true));\n        }); // remove 'empty' setting objects, caused by improper merge range declarations\n\n        populationArgumentsList = populationArgumentsList.filter(function (value) {\n          return value !== true;\n        });\n        var bulkPopulationData = this.getBulkCollectionData(populationArgumentsList);\n        (_this$hot = this.hot).populateFromArray.apply(_this$hot, _toConsumableArray(bulkPopulationData));\n      }\n    }\n    /**\n     * Generates a bulk set of all the data to be populated to fill the data \"under\" the added merged cells.\n     *\n     * @private\n     * @param {Array} populationArgumentsList Array in a form of `[row, column, dataUnderCollection]`.\n     * @return {Array} Array in a form of `[row, column, dataOfAllCollections]`.\n     */\n  }, {\n    key: \"getBulkCollectionData\",\n    value: function getBulkCollectionData(populationArgumentsList) {\n      var _this$hot2;\n      var populationDataRange = this.getBulkCollectionDataRange(populationArgumentsList);\n      var dataAtRange = (_this$hot2 = this.hot).getData.apply(_this$hot2, _toConsumableArray(populationDataRange));\n      var newDataAtRange = dataAtRange.splice(0);\n      arrayEach(populationArgumentsList, function (mergedCellArguments) {\n        var _mergedCellArguments = _slicedToArray(mergedCellArguments, 3),\n          mergedCellRowIndex = _mergedCellArguments[0],\n          mergedCellColumnIndex = _mergedCellArguments[1],\n          mergedCellData = _mergedCellArguments[2];\n        arrayEach(mergedCellData, function (mergedCellRow, rowIndex) {\n          arrayEach(mergedCellRow, function (mergedCellElement, columnIndex) {\n            newDataAtRange[mergedCellRowIndex - populationDataRange[0] + rowIndex][mergedCellColumnIndex - populationDataRange[1] + columnIndex] = mergedCellElement;\n          });\n        });\n      });\n      return [populationDataRange[0], populationDataRange[1], newDataAtRange];\n    }\n    /**\n     * Gets the range of combined data ranges provided in a form of an array of arrays ([row, column, dataUnderCollection])\n     *\n     * @private\n     * @param {Array} populationArgumentsList Array containing argument lists for the `populateFromArray` method - row, column and data for population.\n     * @return {Array[]} Start and end coordinates of the merged cell range. (in a form of [rowIndex, columnIndex])\n     */\n  }, {\n    key: \"getBulkCollectionDataRange\",\n    value: function getBulkCollectionDataRange(populationArgumentsList) {\n      var start = [0, 0];\n      var end = [0, 0];\n      var mergedCellRow = null;\n      var mergedCellColumn = null;\n      var mergedCellData = null;\n      arrayEach(populationArgumentsList, function (mergedCellArguments) {\n        mergedCellRow = mergedCellArguments[0];\n        mergedCellColumn = mergedCellArguments[1];\n        mergedCellData = mergedCellArguments[2];\n        start[0] = Math.min(mergedCellRow, start[0]);\n        start[1] = Math.min(mergedCellColumn, start[1]);\n        end[0] = Math.max(mergedCellRow + mergedCellData.length - 1, end[0]);\n        end[1] = Math.max(mergedCellColumn + mergedCellData[0].length - 1, end[1]);\n      });\n      return [].concat(start, end);\n    }\n    /**\n     * Clears the merged cells from the merged cell container.\n     */\n  }, {\n    key: \"clearCollections\",\n    value: function clearCollections() {\n      this.mergedCellsCollection.clear();\n    }\n    /**\n     * Returns `true` if a range is mergeable.\n     *\n     * @private\n     * @param {Object} newMergedCellInfo Merged cell information object to test.\n     * @param {Boolean} [auto=false] `true` if triggered at initialization.\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"canMergeRange\",\n    value: function canMergeRange(newMergedCellInfo) {\n      var auto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return auto ? true : this.validateSetting(newMergedCellInfo);\n    }\n    /**\n     * Merge or unmerge, based on last selected range.\n     *\n     * @private\n     */\n  }, {\n    key: \"toggleMergeOnSelection\",\n    value: function toggleMergeOnSelection() {\n      var currentRange = this.hot.getSelectedRangeLast();\n      if (!currentRange) {\n        return;\n      }\n      currentRange.setDirection('NW-SE');\n      var from = currentRange.from,\n        to = currentRange.to;\n      this.toggleMerge(currentRange);\n      this.hot.selectCell(from.row, from.col, to.row, to.col, false);\n    }\n    /**\n     * Merges the selection provided as a cell range.\n     *\n     * @param {CellRange} [cellRange] Selection cell range.\n     */\n  }, {\n    key: \"mergeSelection\",\n    value: function mergeSelection() {\n      var cellRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.hot.getSelectedRangeLast();\n      if (!cellRange) {\n        return;\n      }\n      cellRange.setDirection('NW-SE');\n      var from = cellRange.from,\n        to = cellRange.to;\n      this.unmergeRange(cellRange, true);\n      this.mergeRange(cellRange);\n      this.hot.selectCell(from.row, from.col, to.row, to.col, false);\n    }\n    /**\n     * Unmerges the selection provided as a cell range.\n     *\n     * @param {CellRange} [cellRange] Selection cell range.\n     */\n  }, {\n    key: \"unmergeSelection\",\n    value: function unmergeSelection() {\n      var cellRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.hot.getSelectedRangeLast();\n      if (!cellRange) {\n        return;\n      }\n      var from = cellRange.from,\n        to = cellRange.to;\n      this.unmergeRange(cellRange, true);\n      this.hot.selectCell(from.row, from.col, to.row, to.col, false);\n    }\n    /**\n     * Merges cells in the provided cell range.\n     *\n     * @private\n     * @param {CellRange} cellRange Cell range to merge.\n     * @param {Boolean} [auto=false] `true` if is called automatically, e.g. at initialization.\n     * @param {Boolean} [preventPopulation=false] `true`, if the method should not run `populateFromArray` at the end, but rather return its arguments.\n     * @returns {Array|Boolean} Returns an array of [row, column, dataUnderCollection] if preventPopulation is set to true. If the the merging process went successful, it returns `true`, otherwise - `false`.\n     * @fires Hooks#beforeMergeCells\n     * @fires Hooks#afterMergeCells\n     */\n  }, {\n    key: \"mergeRange\",\n    value: function mergeRange(cellRange) {\n      var _this4 = this;\n      var auto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var preventPopulation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var topLeft = cellRange.getTopLeftCorner();\n      var bottomRight = cellRange.getBottomRightCorner();\n      var mergeParent = {\n        row: topLeft.row,\n        col: topLeft.col,\n        rowspan: bottomRight.row - topLeft.row + 1,\n        colspan: bottomRight.col - topLeft.col + 1\n      };\n      var clearedData = [];\n      var populationInfo = null;\n      if (!this.canMergeRange(mergeParent, auto)) {\n        return false;\n      }\n      this.hot.runHooks('beforeMergeCells', cellRange, auto);\n      rangeEach(0, mergeParent.rowspan - 1, function (i) {\n        rangeEach(0, mergeParent.colspan - 1, function (j) {\n          var clearedValue = null;\n          if (!clearedData[i]) {\n            clearedData[i] = [];\n          }\n          if (i === 0 && j === 0) {\n            clearedValue = _this4.hot.getDataAtCell(mergeParent.row, mergeParent.col);\n          } else {\n            _this4.hot.setCellMeta(mergeParent.row + i, mergeParent.col + j, 'hidden', true);\n          }\n          clearedData[i][j] = clearedValue;\n        });\n      });\n      this.hot.setCellMeta(mergeParent.row, mergeParent.col, 'spanned', true);\n      var mergedCellAdded = this.mergedCellsCollection.add(mergeParent);\n      if (mergedCellAdded) {\n        if (preventPopulation) {\n          populationInfo = [mergeParent.row, mergeParent.col, clearedData];\n        } else {\n          this.hot.populateFromArray(mergeParent.row, mergeParent.col, clearedData, void 0, void 0, this.pluginName);\n        }\n        this.hot.runHooks('afterMergeCells', cellRange, mergeParent, auto);\n        return populationInfo;\n      }\n      return true;\n    }\n    /**\n     * Unmerges the selection provided as a cell range. If no cell range is provided, it uses the current selection.\n     *\n     * @private\n     * @param {CellRange} cellRange Selection cell range.\n     * @param {Boolean} [auto=false] `true` if called automatically by the plugin.\n     *\n     * @fires Hooks#beforeUnmergeCells\n     * @fires Hooks#afterUnmergeCells\n     */\n  }, {\n    key: \"unmergeRange\",\n    value: function unmergeRange(cellRange) {\n      var _this5 = this;\n      var auto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var mergedCells = this.mergedCellsCollection.getWithinRange(cellRange);\n      if (!mergedCells) {\n        return;\n      }\n      this.hot.runHooks('beforeUnmergeCells', cellRange, auto);\n      arrayEach(mergedCells, function (currentCollection) {\n        _this5.mergedCellsCollection.remove(currentCollection.row, currentCollection.col);\n        rangeEach(0, currentCollection.rowspan - 1, function (i) {\n          rangeEach(0, currentCollection.colspan - 1, function (j) {\n            _this5.hot.removeCellMeta(currentCollection.row + i, currentCollection.col + j, 'hidden');\n          });\n        });\n        _this5.hot.removeCellMeta(currentCollection.row, currentCollection.col, 'spanned');\n      });\n      this.hot.render();\n      this.hot.runHooks('afterUnmergeCells', cellRange, auto);\n    }\n    /**\n     * Merges or unmerges, based on the cell range provided as `cellRange`.\n     *\n     * @private\n     * @param {CellRange} cellRange The cell range to merge or unmerged.\n     */\n  }, {\n    key: \"toggleMerge\",\n    value: function toggleMerge(cellRange) {\n      var mergedCell = this.mergedCellsCollection.get(cellRange.from.row, cellRange.from.col);\n      var mergedCellCoversWholeRange = mergedCell.row === cellRange.from.row && mergedCell.col === cellRange.from.col && mergedCell.row + mergedCell.rowspan - 1 === cellRange.to.row && mergedCell.col + mergedCell.colspan - 1 === cellRange.to.col;\n      if (mergedCellCoversWholeRange) {\n        this.unmergeRange(cellRange);\n      } else {\n        this.mergeSelection(cellRange);\n      }\n    }\n    /**\n     * Merges the specified range.\n     *\n     * @param {Number} startRow Start row of the merged cell.\n     * @param {Number} startColumn Start column of the merged cell.\n     * @param {Number} endRow End row of the merged cell.\n     * @param {Number} endColumn End column of the merged cell.\n     * @fires Hooks#beforeMergeCells\n     * @fires Hooks#afterMergeCells\n     */\n  }, {\n    key: \"merge\",\n    value: function merge(startRow, startColumn, endRow, endColumn) {\n      var start = new CellCoords(startRow, startColumn);\n      var end = new CellCoords(endRow, endColumn);\n      this.mergeRange(new CellRange(start, start, end));\n    }\n    /**\n     * Unmerges the merged cell in the provided range.\n     *\n     * @param {Number} startRow Start row of the merged cell.\n     * @param {Number} startColumn Start column of the merged cell.\n     * @param {Number} endRow End row of the merged cell.\n     * @param {Number} endColumn End column of the merged cell.\n     * @fires Hooks#beforeUnmergeCells\n     * @fires Hooks#afterUnmergeCells\n     */\n  }, {\n    key: \"unmerge\",\n    value: function unmerge(startRow, startColumn, endRow, endColumn) {\n      var start = new CellCoords(startRow, startColumn);\n      var end = new CellCoords(endRow, endColumn);\n      this.unmergeRange(new CellRange(start, start, end));\n    }\n    /**\n     * `afterInit` hook callback.\n     *\n     * @private\n     */\n  }, {\n    key: \"onAfterInit\",\n    value: function onAfterInit() {\n      this.generateFromSettings(this.hot.getSettings().mergeCells);\n      this.hot.render();\n    }\n    /**\n     * `beforeKeyDown` hook callback.\n     *\n     * @private\n     * @param {KeyboardEvent} event The `keydown` event object.\n     */\n  }, {\n    key: \"onBeforeKeyDown\",\n    value: function onBeforeKeyDown(event) {\n      var ctrlDown = (event.ctrlKey || event.metaKey) && !event.altKey;\n      if (ctrlDown && event.keyCode === 77) {\n        // CTRL + M\n        this.toggleMerge(this.hot.getSelectedRangeLast());\n        this.hot.render();\n        stopImmediatePropagation(event);\n      }\n    }\n    /**\n     * Modifies the information on whether the current selection contains multiple cells. The `afterIsMultipleSelection` hook callback.\n     *\n     * @private\n     * @param {Boolean} isMultiple\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"onAfterIsMultipleSelection\",\n    value: function onAfterIsMultipleSelection(isMultiple) {\n      if (isMultiple) {\n        var mergedCells = this.mergedCellsCollection.mergedCells;\n        var selectionRange = this.hot.getSelectedRangeLast();\n        for (var group = 0; group < mergedCells.length; group += 1) {\n          if (selectionRange.highlight.row === mergedCells[group].row && selectionRange.highlight.col === mergedCells[group].col && selectionRange.to.row === mergedCells[group].row + mergedCells[group].rowspan - 1 && selectionRange.to.col === mergedCells[group].col + mergedCells[group].colspan - 1) {\n            return false;\n          }\n        }\n      }\n      return isMultiple;\n    }\n    /**\n     * `modifyTransformStart` hook callback.\n     *\n     * @private\n     * @param {Object} delta The transformation delta.\n     */\n  }, {\n    key: \"onModifyTransformStart\",\n    value: function onModifyTransformStart(delta) {\n      var priv = privatePool.get(this);\n      var currentlySelectedRange = this.hot.getSelectedRangeLast();\n      var newDelta = {\n        row: delta.row,\n        col: delta.col\n      };\n      var nextPosition = null;\n      var currentPosition = new CellCoords(currentlySelectedRange.highlight.row, currentlySelectedRange.highlight.col);\n      var mergedParent = this.mergedCellsCollection.get(currentPosition.row, currentPosition.col);\n      if (!priv.lastDesiredCoords) {\n        priv.lastDesiredCoords = new CellCoords(null, null);\n      }\n      if (mergedParent) {\n        // only merge selected\n        var mergeTopLeft = new CellCoords(mergedParent.row, mergedParent.col);\n        var mergeBottomRight = new CellCoords(mergedParent.row + mergedParent.rowspan - 1, mergedParent.col + mergedParent.colspan - 1);\n        var mergeRange = new CellRange(mergeTopLeft, mergeTopLeft, mergeBottomRight);\n        if (!mergeRange.includes(priv.lastDesiredCoords)) {\n          priv.lastDesiredCoords = new CellCoords(null, null); // reset outdated version of lastDesiredCoords\n        }\n\n        newDelta.row = priv.lastDesiredCoords.row ? priv.lastDesiredCoords.row - currentPosition.row : newDelta.row;\n        newDelta.col = priv.lastDesiredCoords.col ? priv.lastDesiredCoords.col - currentPosition.col : newDelta.col;\n        if (delta.row > 0) {\n          // moving down\n          newDelta.row = mergedParent.row + mergedParent.rowspan - 1 - currentPosition.row + delta.row;\n        } else if (delta.row < 0) {\n          // moving up\n          newDelta.row = currentPosition.row - mergedParent.row + delta.row;\n        }\n        if (delta.col > 0) {\n          // moving right\n          newDelta.col = mergedParent.col + mergedParent.colspan - 1 - currentPosition.col + delta.col;\n        } else if (delta.col < 0) {\n          // moving left\n          newDelta.col = currentPosition.col - mergedParent.col + delta.col;\n        }\n      }\n      nextPosition = new CellCoords(currentlySelectedRange.highlight.row + newDelta.row, currentlySelectedRange.highlight.col + newDelta.col);\n      var nextParentIsMerged = this.mergedCellsCollection.get(nextPosition.row, nextPosition.col);\n      if (nextParentIsMerged) {\n        // skipping the invisible cells in the merge range\n        priv.lastDesiredCoords = nextPosition;\n        newDelta = {\n          row: nextParentIsMerged.row - currentPosition.row,\n          col: nextParentIsMerged.col - currentPosition.col\n        };\n      }\n      if (newDelta.row !== 0) {\n        delta.row = newDelta.row;\n      }\n      if (newDelta.col !== 0) {\n        delta.col = newDelta.col;\n      }\n    }\n    /**\n     * `modifyTransformEnd` hook callback. Needed to handle \"jumping over\" merged merged cells, while selecting.\n     *\n     * @private\n     * @param {Object} delta The transformation delta.\n     */\n  }, {\n    key: \"onModifyTransformEnd\",\n    value: function onModifyTransformEnd(delta) {\n      var _this6 = this;\n      var currentSelectionRange = this.hot.getSelectedRangeLast();\n      var newDelta = clone(delta);\n      var newSelectionRange = this.selectionCalculations.getUpdatedSelectionRange(currentSelectionRange, delta);\n      var tempDelta = clone(newDelta);\n      var mergedCellsWithinRange = this.mergedCellsCollection.getWithinRange(newSelectionRange, true);\n      do {\n        tempDelta = clone(newDelta);\n        this.selectionCalculations.getUpdatedSelectionRange(currentSelectionRange, newDelta);\n        arrayEach(mergedCellsWithinRange, function (mergedCell) {\n          _this6.selectionCalculations.snapDelta(newDelta, currentSelectionRange, mergedCell);\n        });\n      } while (newDelta.row !== tempDelta.row || newDelta.col !== tempDelta.col);\n      delta.row = newDelta.row;\n      delta.col = newDelta.col;\n    }\n    /**\n     * `modifyGetCellCoords` hook callback. Swaps the `getCell` coords with the merged parent coords.\n     *\n     * @private\n     * @param {Number} row Row index.\n     * @param {Number} column Column index.\n     * @returns {Array}\n     */\n  }, {\n    key: \"onModifyGetCellCoords\",\n    value: function onModifyGetCellCoords(row, column) {\n      var mergeParent = this.mergedCellsCollection.get(row, column);\n      return mergeParent ? [mergeParent.row, mergeParent.col, mergeParent.row + mergeParent.rowspan - 1, mergeParent.col + mergeParent.colspan - 1] : void 0;\n    }\n    /**\n     * `afterContextMenuDefaultOptions` hook callback.\n     *\n     * @private\n     * @param {Object} defaultOptions The default context menu options.\n     */\n  }, {\n    key: \"addMergeActionsToContextMenu\",\n    value: function addMergeActionsToContextMenu(defaultOptions) {\n      defaultOptions.items.push({\n        name: '---------'\n      }, toggleMergeItem(this));\n    }\n    /**\n     * `afterRenderer` hook callback.\n     *\n     * @private\n     * @param {HTMLElement} TD The cell to be modified.\n     * @param {Number} row Row index.\n     * @param {Number} col Column index.\n     */\n  }, {\n    key: \"onAfterRenderer\",\n    value: function onAfterRenderer(TD, row, col) {\n      var mergedCell = this.mergedCellsCollection.get(row, col);\n      applySpanProperties(TD, mergedCell, row, col);\n    }\n    /**\n     * `beforeSetRangeEnd` hook callback.\n     * While selecting cells with keyboard or mouse, make sure that rectangular area is expanded to the extent of the merged cell\n     *\n     * @private\n     * @param {Object} coords Cell coords.\n     */\n  }, {\n    key: \"onBeforeSetRangeEnd\",\n    value: function onBeforeSetRangeEnd(coords) {\n      var selRange = this.hot.getSelectedRangeLast();\n      selRange.highlight = new CellCoords(selRange.highlight.row, selRange.highlight.col); // clone in case we will modify its reference\n\n      selRange.to = coords;\n      var rangeExpanded = false;\n      if (this.hot.selection.isSelectedByColumnHeader() || this.hot.selection.isSelectedByRowHeader()) {\n        return;\n      }\n      do {\n        rangeExpanded = false;\n        for (var i = 0; i < this.mergedCellsCollection.mergedCells.length; i += 1) {\n          var cellInfo = this.mergedCellsCollection.mergedCells[i];\n          var mergedCellRange = cellInfo.getRange();\n          if (selRange.expandByRange(mergedCellRange)) {\n            coords.row = selRange.to.row;\n            coords.col = selRange.to.col;\n            rangeExpanded = true;\n          }\n        }\n      } while (rangeExpanded);\n    }\n    /**\n     * The `afterGetCellMeta` hook callback.\n     *\n     * @private\n     * @param {Number} row Row index.\n     * @param {Number} col Column index.\n     * @param {Object} cellProperties The cell properties object.\n     */\n  }, {\n    key: \"onAfterGetCellMeta\",\n    value: function onAfterGetCellMeta(row, col, cellProperties) {\n      var mergeParent = this.mergedCellsCollection.get(row, col);\n      if (mergeParent) {\n        if (mergeParent.row !== row || mergeParent.col !== col) {\n          cellProperties.copyable = false;\n        } else {\n          cellProperties.rowspan = mergeParent.rowspan;\n          cellProperties.colspan = mergeParent.colspan;\n        }\n      }\n    }\n    /**\n     * `afterViewportRowCalculatorOverride` hook callback.\n     *\n     * @private\n     * @param {Object} calc The row calculator object.\n     */\n  }, {\n    key: \"onAfterViewportRowCalculatorOverride\",\n    value: function onAfterViewportRowCalculatorOverride(calc) {\n      var _this7 = this;\n      var colCount = this.hot.countCols();\n      var mergeParent;\n      rangeEach(0, colCount - 1, function (c) {\n        mergeParent = _this7.mergedCellsCollection.get(calc.startRow, c);\n        if (mergeParent) {\n          if (mergeParent.row < calc.startRow) {\n            calc.startRow = mergeParent.row;\n            return _this7.onAfterViewportRowCalculatorOverride.call(_this7, calc); // recursively search upwards\n          }\n        }\n\n        mergeParent = _this7.mergedCellsCollection.get(calc.endRow, c);\n        if (mergeParent) {\n          var mergeEnd = mergeParent.row + mergeParent.rowspan - 1;\n          if (mergeEnd > calc.endRow) {\n            calc.endRow = mergeEnd;\n            return _this7.onAfterViewportRowCalculatorOverride.call(_this7, calc); // recursively search upwards\n          }\n        }\n\n        return true;\n      });\n    }\n    /**\n     * `afterViewportColumnCalculatorOverride` hook callback.\n     *\n     * @private\n     * @param {Object} calc The column calculator object.\n     */\n  }, {\n    key: \"onAfterViewportColumnCalculatorOverride\",\n    value: function onAfterViewportColumnCalculatorOverride(calc) {\n      var _this8 = this;\n      var rowCount = this.hot.countRows();\n      var mergeParent;\n      rangeEach(0, rowCount - 1, function (r) {\n        mergeParent = _this8.mergedCellsCollection.get(r, calc.startColumn);\n        if (mergeParent && mergeParent.col < calc.startColumn) {\n          calc.startColumn = mergeParent.col;\n          return _this8.onAfterViewportColumnCalculatorOverride.call(_this8, calc); // recursively search upwards\n        }\n\n        mergeParent = _this8.mergedCellsCollection.get(r, calc.endColumn);\n        if (mergeParent) {\n          var mergeEnd = mergeParent.col + mergeParent.colspan - 1;\n          if (mergeEnd > calc.endColumn) {\n            calc.endColumn = mergeEnd;\n            return _this8.onAfterViewportColumnCalculatorOverride.call(_this8, calc); // recursively search upwards\n          }\n        }\n\n        return true;\n      });\n    }\n    /**\n     * The `modifyAutofillRange` hook callback.\n     *\n     * @private\n     * @param {Array} drag The drag area coordinates.\n     * @param {Array} select The selection information.\n     * @return {Array} The new drag area.\n     */\n  }, {\n    key: \"onModifyAutofillRange\",\n    value: function onModifyAutofillRange(drag, select) {\n      this.autofillCalculations.correctSelectionAreaSize(select);\n      var dragDirection = this.autofillCalculations.getDirection(select, drag);\n      var dragArea = drag;\n      if (this.autofillCalculations.dragAreaOverlapsCollections(select, dragArea, dragDirection)) {\n        dragArea = select;\n        return dragArea;\n      }\n      var mergedCellsWithinSelectionArea = this.mergedCellsCollection.getWithinRange({\n        from: {\n          row: select[0],\n          col: select[1]\n        },\n        to: {\n          row: select[2],\n          col: select[3]\n        }\n      });\n      if (!mergedCellsWithinSelectionArea) {\n        return dragArea;\n      }\n      dragArea = this.autofillCalculations.snapDragArea(select, dragArea, dragDirection, mergedCellsWithinSelectionArea);\n      return dragArea;\n    }\n    /**\n     * `afterCreateCol` hook callback.\n     *\n     * @private\n     * @param {Number} column Column index.\n     * @param {Number} count Number of created columns.\n     */\n  }, {\n    key: \"onAfterCreateCol\",\n    value: function onAfterCreateCol(column, count) {\n      this.mergedCellsCollection.shiftCollections('right', column, count);\n    }\n    /**\n     * `afterRemoveCol` hook callback.\n     *\n     * @private\n     * @param {Number} column Column index.\n     * @param {Number} count Number of removed columns.\n     */\n  }, {\n    key: \"onAfterRemoveCol\",\n    value: function onAfterRemoveCol(column, count) {\n      this.mergedCellsCollection.shiftCollections('left', column, count);\n    }\n    /**\n     * `afterCreateRow` hook callback.\n     *\n     * @private\n     * @param {Number} row Row index.\n     * @param {Number} count Number of created rows.\n     * @param {String} source Source of change.\n     */\n  }, {\n    key: \"onAfterCreateRow\",\n    value: function onAfterCreateRow(row, count, source) {\n      if (source === 'auto') {\n        return;\n      }\n      this.mergedCellsCollection.shiftCollections('down', row, count);\n    }\n    /**\n     * `afterRemoveRow` hook callback.\n     *\n     * @private\n     * @param {Number} row Row index.\n     * @param {Number} count Number of removed rows.\n     */\n  }, {\n    key: \"onAfterRemoveRow\",\n    value: function onAfterRemoveRow(row, count) {\n      this.mergedCellsCollection.shiftCollections('up', row, count);\n    }\n    /**\n     * `afterChange` hook callback. Used to propagate merged cells after using Autofill.\n     *\n     * @private\n     * @param {Array} changes The changes array.\n     * @param {String} source Determines the source of the change.\n     */\n  }, {\n    key: \"onAfterChange\",\n    value: function onAfterChange(changes, source) {\n      if (source !== 'Autofill.fill') {\n        return;\n      }\n      this.autofillCalculations.recreateAfterDataPopulation(changes);\n    }\n    /**\n     * `beforeDrawAreaBorders` hook callback.\n     *\n     * @private\n     * @param {Array} corners Coordinates of the area corners.\n     * @param {String} className Class name for the area.\n     */\n  }, {\n    key: \"onBeforeDrawAreaBorders\",\n    value: function onBeforeDrawAreaBorders(corners, className) {\n      if (className && className === 'area') {\n        var selectedRange = this.hot.getSelectedRangeLast();\n        var mergedCellsWithinRange = this.mergedCellsCollection.getWithinRange(selectedRange);\n        arrayEach(mergedCellsWithinRange, function (mergedCell) {\n          if (selectedRange.getBottomRightCorner().row === mergedCell.getLastRow() && selectedRange.getBottomRightCorner().col === mergedCell.getLastColumn()) {\n            corners[2] = mergedCell.row;\n            corners[3] = mergedCell.col;\n          }\n        });\n      }\n    }\n    /**\n     * `afterModifyTransformStart` hook callback. Fixes a problem with navigating through merged cells at the edges of the table\n     * with the ENTER/SHIFT+ENTER/TAB/SHIFT+TAB keys.\n     *\n     * @private\n     * @param {CellCoords} coords Coordinates of the to-be-selected cell.\n     * @param {Number} rowTransformDir Row transformation direction (negative value = up, 0 = none, positive value = down)\n     * @param {Number} colTransformDir Column transformation direction (negative value = up, 0 = none, positive value = down)\n     */\n  }, {\n    key: \"onAfterModifyTransformStart\",\n    value: function onAfterModifyTransformStart(coords, rowTransformDir, colTransformDir) {\n      if (!this.enabled) {\n        return;\n      }\n      var mergedCellAtCoords = this.mergedCellsCollection.get(coords.row, coords.col);\n      if (!mergedCellAtCoords) {\n        return;\n      }\n      var goingDown = rowTransformDir > 0;\n      var goingUp = rowTransformDir < 0;\n      var goingLeft = colTransformDir < 0;\n      var goingRight = colTransformDir > 0;\n      var mergedCellOnBottomEdge = mergedCellAtCoords.row + mergedCellAtCoords.rowspan - 1 === this.hot.countRows() - 1;\n      var mergedCellOnTopEdge = mergedCellAtCoords.row === 0;\n      var mergedCellOnRightEdge = mergedCellAtCoords.col + mergedCellAtCoords.colspan - 1 === this.hot.countCols() - 1;\n      var mergedCellOnLeftEdge = mergedCellAtCoords.col === 0;\n      if (goingDown && mergedCellOnBottomEdge || goingUp && mergedCellOnTopEdge || goingRight && mergedCellOnRightEdge || goingLeft && mergedCellOnLeftEdge) {\n        coords.row = mergedCellAtCoords.row;\n        coords.col = mergedCellAtCoords.col;\n      }\n    }\n    /**\n     * `afterDrawSelection` hook callback. Used to add the additional class name for the entirely-selected merged cells.\n     *\n     * @private\n     * @param {Number} currentRow Row index of the currently processed cell.\n     * @param {Number} currentColumn Column index of the currently cell.\n     * @param {Array} cornersOfSelection Array of the current selection in a form of `[startRow, startColumn, endRow, endColumn]`.\n     * @param {Number|undefined} layerLevel Number indicating which layer of selection is currently processed.\n     * @returns {String|undefined} A `String`, which will act as an additional `className` to be added to the currently processed cell.\n     */\n  }, {\n    key: \"onAfterDrawSelection\",\n    value: function onAfterDrawSelection(currentRow, currentColumn, cornersOfSelection, layerLevel) {\n      return this.selectionCalculations.getSelectedMergedCellClassName(currentRow, currentColumn, cornersOfSelection, layerLevel);\n    }\n    /**\n     * `beforeRemoveCellClassNames` hook callback. Used to remove additional class name from all cells in the table.\n     *\n     * @private\n     * @returns {String[]} An `Array` of `String`s. Each of these strings will act like class names to be removed from all the cells in the table.\n     */\n  }, {\n    key: \"onBeforeRemoveCellClassNames\",\n    value: function onBeforeRemoveCellClassNames() {\n      return this.selectionCalculations.getSelectedMergedCellClassNameToRemove();\n    }\n  }]);\n  return MergeCells;\n}(BasePlugin);\nregisterPlugin('mergeCells', MergeCells);\nexport default MergeCells;","map":{"version":3,"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","TypeError","Object","toString","call","_arr","_n","_d","_e","undefined","_i","_s","next","done","push","value","length","err","Array","isArray","_toConsumableArray","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","iter","from","arr2","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","_possibleConstructorReturn","self","_assertThisInitialized","ReferenceError","_get","property","receiver","Reflect","get","base","_superPropBase","desc","getOwnPropertyDescriptor","object","hasOwnProperty","_getPrototypeOf","o","setPrototypeOf","getPrototypeOf","__proto__","_inherits","subClass","superClass","create","_setPrototypeOf","p","BasePlugin","Hooks","registerPlugin","stopImmediatePropagation","CellCoords","CellRange","MergedCellsCollection","MergedCellCoords","AutofillCalculations","SelectionCalculations","toggleMergeItem","arrayEach","clone","warn","rangeEach","applySpanProperties","getSingleton","register","privatePool","WeakMap","MergeCells","_BasePlugin","hotInstance","_this","set","lastDesiredCoords","mergedCellsCollection","autofillCalculations","selectionCalculations","isEnabled","hot","getSettings","mergeCells","enablePlugin","_this2","enabled","addHook","onAfterInit","apply","arguments","onBeforeKeyDown","onModifyTransformStart","onAfterModifyTransformStart","onModifyTransformEnd","onModifyGetCellCoords","onBeforeSetRangeEnd","onAfterIsMultipleSelection","onAfterRenderer","addMergeActionsToContextMenu","onAfterGetCellMeta","onAfterViewportRowCalculatorOverride","onAfterViewportColumnCalculatorOverride","onModifyAutofillRange","onAfterCreateCol","onAfterRemoveCol","onAfterCreateRow","onAfterRemoveRow","onAfterChange","onBeforeDrawAreaBorders","onAfterDrawSelection","onBeforeRemoveCellClassNames","disablePlugin","clearCollections","render","updatePlugin","settings","generateFromSettings","validateSetting","setting","valid","containsNegativeValues","NEGATIVE_VALUES_WARNING","isOutOfBounds","countRows","countCols","IS_OUT_OF_BOUNDS_WARNING","isSingleCell","IS_SINGLE_CELL","containsZeroSpan","ZERO_SPAN_WARNING","_this3","_this$hot","populationArgumentsList","highlight","row","col","rangeEnd","rowspan","colspan","mergeRange","filter","bulkPopulationData","getBulkCollectionData","populateFromArray","_this$hot2","populationDataRange","getBulkCollectionDataRange","dataAtRange","getData","newDataAtRange","splice","mergedCellArguments","_mergedCellArguments","mergedCellRowIndex","mergedCellColumnIndex","mergedCellData","mergedCellRow","rowIndex","mergedCellElement","columnIndex","start","end","mergedCellColumn","Math","min","max","concat","clear","canMergeRange","newMergedCellInfo","auto","toggleMergeOnSelection","currentRange","getSelectedRangeLast","setDirection","to","toggleMerge","selectCell","mergeSelection","cellRange","unmergeRange","unmergeSelection","_this4","preventPopulation","topLeft","getTopLeftCorner","bottomRight","getBottomRightCorner","mergeParent","clearedData","populationInfo","runHooks","j","clearedValue","getDataAtCell","setCellMeta","mergedCellAdded","add","pluginName","_this5","mergedCells","getWithinRange","currentCollection","remove","removeCellMeta","mergedCell","mergedCellCoversWholeRange","merge","startRow","startColumn","endRow","endColumn","unmerge","event","ctrlDown","ctrlKey","metaKey","altKey","keyCode","isMultiple","selectionRange","group","delta","priv","currentlySelectedRange","newDelta","nextPosition","currentPosition","mergedParent","mergeTopLeft","mergeBottomRight","includes","nextParentIsMerged","_this6","currentSelectionRange","newSelectionRange","getUpdatedSelectionRange","tempDelta","mergedCellsWithinRange","snapDelta","column","defaultOptions","items","name","TD","coords","selRange","rangeExpanded","selection","isSelectedByColumnHeader","isSelectedByRowHeader","cellInfo","mergedCellRange","getRange","expandByRange","cellProperties","copyable","calc","_this7","colCount","c","mergeEnd","_this8","rowCount","r","drag","select","correctSelectionAreaSize","dragDirection","getDirection","dragArea","dragAreaOverlapsCollections","mergedCellsWithinSelectionArea","snapDragArea","count","shiftCollections","source","changes","recreateAfterDataPopulation","corners","className","selectedRange","getLastRow","getLastColumn","rowTransformDir","colTransformDir","mergedCellAtCoords","goingDown","goingUp","goingLeft","goingRight","mergedCellOnBottomEdge","mergedCellOnTopEdge","mergedCellOnRightEdge","mergedCellOnLeftEdge","currentRow","currentColumn","cornersOfSelection","layerLevel","getSelectedMergedCellClassName","getSelectedMergedCellClassNameToRemove"],"sources":["C:/Users/mrezy/VSCode/internships-master/node_modules/handsontable/es/plugins/mergeCells/mergeCells.js"],"sourcesContent":["import \"core-js/modules/es.symbol\";\nimport \"core-js/modules/es.symbol.description\";\nimport \"core-js/modules/es.symbol.iterator\";\nimport \"core-js/modules/es.array.concat\";\nimport \"core-js/modules/es.array.filter\";\nimport \"core-js/modules/es.array.from\";\nimport \"core-js/modules/es.array.includes\";\nimport \"core-js/modules/es.array.iterator\";\nimport \"core-js/modules/es.array.splice\";\nimport \"core-js/modules/es.object.get-own-property-descriptor\";\nimport \"core-js/modules/es.object.get-prototype-of\";\nimport \"core-js/modules/es.object.set-prototype-of\";\nimport \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.reflect.get\";\nimport \"core-js/modules/es.regexp.to-string\";\nimport \"core-js/modules/es.string.includes\";\nimport \"core-js/modules/es.string.iterator\";\nimport \"core-js/modules/es.weak-map\";\nimport \"core-js/modules/web.dom-collections.iterator\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nimport BasePlugin from './../_base';\nimport Hooks from './../../pluginHooks';\nimport { registerPlugin } from './../../plugins';\nimport { stopImmediatePropagation } from './../../helpers/dom/event';\nimport { CellCoords, CellRange } from './../../3rdparty/walkontable/src';\nimport MergedCellsCollection from './cellsCollection';\nimport MergedCellCoords from './cellCoords';\nimport AutofillCalculations from './calculations/autofill';\nimport SelectionCalculations from './calculations/selection';\nimport toggleMergeItem from './contextMenuItem/toggleMerge';\nimport { arrayEach } from '../../helpers/array';\nimport { clone } from '../../helpers/object';\nimport { warn } from '../../helpers/console';\nimport { rangeEach } from '../../helpers/number';\nimport { applySpanProperties } from './utils';\nHooks.getSingleton().register('beforeMergeCells');\nHooks.getSingleton().register('afterMergeCells');\nHooks.getSingleton().register('beforeUnmergeCells');\nHooks.getSingleton().register('afterUnmergeCells');\nvar privatePool = new WeakMap();\n/**\n * @plugin MergeCells\n *\n * @description\n * Plugin, which allows merging cells in the table (using the initial configuration, API or context menu).\n *\n * @example\n *\n * ```js\n * const hot = new Handsontable(document.getElementById('example'), {\n *  data: getData(),\n *  mergeCells: [\n *    {row: 0, col: 3, rowspan: 3, colspan: 3},\n *    {row: 2, col: 6, rowspan: 2, colspan: 2},\n *    {row: 4, col: 8, rowspan: 3, colspan: 3}\n *  ],\n * ```\n */\n\nvar MergeCells =\n/*#__PURE__*/\nfunction (_BasePlugin) {\n  _inherits(MergeCells, _BasePlugin);\n\n  function MergeCells(hotInstance) {\n    var _this;\n\n    _classCallCheck(this, MergeCells);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MergeCells).call(this, hotInstance));\n    privatePool.set(_assertThisInitialized(_this), {\n      lastDesiredCoords: null\n    });\n    /**\n     * A container for all the merged cells.\n     *\n     * @private\n     * @type {MergedCellsCollection}\n     */\n\n    _this.mergedCellsCollection = null;\n    /**\n     * Instance of the class responsible for all the autofill-related calculations.\n     *\n     * @private\n     * @type {AutofillCalculations}\n     */\n\n    _this.autofillCalculations = null;\n    /**\n     * Instance of the class responsible for the selection-related calculations.\n     *\n     * @private\n     * @type {SelectionCalculations}\n     */\n\n    _this.selectionCalculations = null;\n    return _this;\n  }\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` than the {@link MergeCells#enablePlugin} method is called.\n   *\n   * @returns {Boolean}\n   */\n\n\n  _createClass(MergeCells, [{\n    key: \"isEnabled\",\n    value: function isEnabled() {\n      return !!this.hot.getSettings().mergeCells;\n    }\n    /**\n     * Enables the plugin functionality for this Handsontable instance.\n     */\n\n  }, {\n    key: \"enablePlugin\",\n    value: function enablePlugin() {\n      var _this2 = this;\n\n      if (this.enabled) {\n        return;\n      }\n\n      this.mergedCellsCollection = new MergedCellsCollection(this);\n      this.autofillCalculations = new AutofillCalculations(this);\n      this.selectionCalculations = new SelectionCalculations(this);\n      this.addHook('afterInit', function () {\n        return _this2.onAfterInit.apply(_this2, arguments);\n      });\n      this.addHook('beforeKeyDown', function () {\n        return _this2.onBeforeKeyDown.apply(_this2, arguments);\n      });\n      this.addHook('modifyTransformStart', function () {\n        return _this2.onModifyTransformStart.apply(_this2, arguments);\n      });\n      this.addHook('afterModifyTransformStart', function () {\n        return _this2.onAfterModifyTransformStart.apply(_this2, arguments);\n      });\n      this.addHook('modifyTransformEnd', function () {\n        return _this2.onModifyTransformEnd.apply(_this2, arguments);\n      });\n      this.addHook('modifyGetCellCoords', function () {\n        return _this2.onModifyGetCellCoords.apply(_this2, arguments);\n      });\n      this.addHook('beforeSetRangeEnd', function () {\n        return _this2.onBeforeSetRangeEnd.apply(_this2, arguments);\n      });\n      this.addHook('afterIsMultipleSelection', function () {\n        return _this2.onAfterIsMultipleSelection.apply(_this2, arguments);\n      });\n      this.addHook('afterRenderer', function () {\n        return _this2.onAfterRenderer.apply(_this2, arguments);\n      });\n      this.addHook('afterContextMenuDefaultOptions', function () {\n        return _this2.addMergeActionsToContextMenu.apply(_this2, arguments);\n      });\n      this.addHook('afterGetCellMeta', function () {\n        return _this2.onAfterGetCellMeta.apply(_this2, arguments);\n      });\n      this.addHook('afterViewportRowCalculatorOverride', function () {\n        return _this2.onAfterViewportRowCalculatorOverride.apply(_this2, arguments);\n      });\n      this.addHook('afterViewportColumnCalculatorOverride', function () {\n        return _this2.onAfterViewportColumnCalculatorOverride.apply(_this2, arguments);\n      });\n      this.addHook('modifyAutofillRange', function () {\n        return _this2.onModifyAutofillRange.apply(_this2, arguments);\n      });\n      this.addHook('afterCreateCol', function () {\n        return _this2.onAfterCreateCol.apply(_this2, arguments);\n      });\n      this.addHook('afterRemoveCol', function () {\n        return _this2.onAfterRemoveCol.apply(_this2, arguments);\n      });\n      this.addHook('afterCreateRow', function () {\n        return _this2.onAfterCreateRow.apply(_this2, arguments);\n      });\n      this.addHook('afterRemoveRow', function () {\n        return _this2.onAfterRemoveRow.apply(_this2, arguments);\n      });\n      this.addHook('afterChange', function () {\n        return _this2.onAfterChange.apply(_this2, arguments);\n      });\n      this.addHook('beforeDrawBorders', function () {\n        return _this2.onBeforeDrawAreaBorders.apply(_this2, arguments);\n      });\n      this.addHook('afterDrawSelection', function () {\n        return _this2.onAfterDrawSelection.apply(_this2, arguments);\n      });\n      this.addHook('beforeRemoveCellClassNames', function () {\n        return _this2.onBeforeRemoveCellClassNames.apply(_this2, arguments);\n      });\n\n      _get(_getPrototypeOf(MergeCells.prototype), \"enablePlugin\", this).call(this);\n    }\n    /**\n     * Disables the plugin functionality for this Handsontable instance.\n     */\n\n  }, {\n    key: \"disablePlugin\",\n    value: function disablePlugin() {\n      this.clearCollections();\n      this.hot.render();\n\n      _get(_getPrototypeOf(MergeCells.prototype), \"disablePlugin\", this).call(this);\n    }\n    /**\n     * Updates the plugin state. This method is executed when {@link Core#updateSettings} is invoked.\n     */\n\n  }, {\n    key: \"updatePlugin\",\n    value: function updatePlugin() {\n      var settings = this.hot.getSettings().mergeCells;\n      this.disablePlugin();\n      this.enablePlugin();\n      this.generateFromSettings(settings);\n\n      _get(_getPrototypeOf(MergeCells.prototype), \"updatePlugin\", this).call(this);\n    }\n    /**\n     * Validates a single setting object, represented by a single merged cell information object.\n     *\n     * @private\n     * @param {Object} setting An object with `row`, `col`, `rowspan` and `colspan` properties.\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"validateSetting\",\n    value: function validateSetting(setting) {\n      var valid = true;\n\n      if (!setting) {\n        return false;\n      }\n\n      if (MergedCellCoords.containsNegativeValues(setting)) {\n        warn(MergedCellCoords.NEGATIVE_VALUES_WARNING(setting));\n        valid = false;\n      } else if (MergedCellCoords.isOutOfBounds(setting, this.hot.countRows(), this.hot.countCols())) {\n        warn(MergedCellCoords.IS_OUT_OF_BOUNDS_WARNING(setting));\n        valid = false;\n      } else if (MergedCellCoords.isSingleCell(setting)) {\n        warn(MergedCellCoords.IS_SINGLE_CELL(setting));\n        valid = false;\n      } else if (MergedCellCoords.containsZeroSpan(setting)) {\n        warn(MergedCellCoords.ZERO_SPAN_WARNING(setting));\n        valid = false;\n      }\n\n      return valid;\n    }\n    /**\n     * Generates the merged cells from the settings provided to the plugin.\n     *\n     * @private\n     * @param {Array|Boolean} settings The settings provided to the plugin.\n     */\n\n  }, {\n    key: \"generateFromSettings\",\n    value: function generateFromSettings(settings) {\n      var _this3 = this;\n\n      if (Array.isArray(settings)) {\n        var _this$hot;\n\n        var populationArgumentsList = [];\n        arrayEach(settings, function (setting) {\n          if (!_this3.validateSetting(setting)) {\n            return;\n          }\n\n          var highlight = new CellCoords(setting.row, setting.col);\n          var rangeEnd = new CellCoords(setting.row + setting.rowspan - 1, setting.col + setting.colspan - 1);\n          var mergeRange = new CellRange(highlight, highlight, rangeEnd);\n          populationArgumentsList.push(_this3.mergeRange(mergeRange, true, true));\n        }); // remove 'empty' setting objects, caused by improper merge range declarations\n\n        populationArgumentsList = populationArgumentsList.filter(function (value) {\n          return value !== true;\n        });\n        var bulkPopulationData = this.getBulkCollectionData(populationArgumentsList);\n\n        (_this$hot = this.hot).populateFromArray.apply(_this$hot, _toConsumableArray(bulkPopulationData));\n      }\n    }\n    /**\n     * Generates a bulk set of all the data to be populated to fill the data \"under\" the added merged cells.\n     *\n     * @private\n     * @param {Array} populationArgumentsList Array in a form of `[row, column, dataUnderCollection]`.\n     * @return {Array} Array in a form of `[row, column, dataOfAllCollections]`.\n     */\n\n  }, {\n    key: \"getBulkCollectionData\",\n    value: function getBulkCollectionData(populationArgumentsList) {\n      var _this$hot2;\n\n      var populationDataRange = this.getBulkCollectionDataRange(populationArgumentsList);\n\n      var dataAtRange = (_this$hot2 = this.hot).getData.apply(_this$hot2, _toConsumableArray(populationDataRange));\n\n      var newDataAtRange = dataAtRange.splice(0);\n      arrayEach(populationArgumentsList, function (mergedCellArguments) {\n        var _mergedCellArguments = _slicedToArray(mergedCellArguments, 3),\n            mergedCellRowIndex = _mergedCellArguments[0],\n            mergedCellColumnIndex = _mergedCellArguments[1],\n            mergedCellData = _mergedCellArguments[2];\n\n        arrayEach(mergedCellData, function (mergedCellRow, rowIndex) {\n          arrayEach(mergedCellRow, function (mergedCellElement, columnIndex) {\n            newDataAtRange[mergedCellRowIndex - populationDataRange[0] + rowIndex][mergedCellColumnIndex - populationDataRange[1] + columnIndex] = mergedCellElement;\n          });\n        });\n      });\n      return [populationDataRange[0], populationDataRange[1], newDataAtRange];\n    }\n    /**\n     * Gets the range of combined data ranges provided in a form of an array of arrays ([row, column, dataUnderCollection])\n     *\n     * @private\n     * @param {Array} populationArgumentsList Array containing argument lists for the `populateFromArray` method - row, column and data for population.\n     * @return {Array[]} Start and end coordinates of the merged cell range. (in a form of [rowIndex, columnIndex])\n     */\n\n  }, {\n    key: \"getBulkCollectionDataRange\",\n    value: function getBulkCollectionDataRange(populationArgumentsList) {\n      var start = [0, 0];\n      var end = [0, 0];\n      var mergedCellRow = null;\n      var mergedCellColumn = null;\n      var mergedCellData = null;\n      arrayEach(populationArgumentsList, function (mergedCellArguments) {\n        mergedCellRow = mergedCellArguments[0];\n        mergedCellColumn = mergedCellArguments[1];\n        mergedCellData = mergedCellArguments[2];\n        start[0] = Math.min(mergedCellRow, start[0]);\n        start[1] = Math.min(mergedCellColumn, start[1]);\n        end[0] = Math.max(mergedCellRow + mergedCellData.length - 1, end[0]);\n        end[1] = Math.max(mergedCellColumn + mergedCellData[0].length - 1, end[1]);\n      });\n      return [].concat(start, end);\n    }\n    /**\n     * Clears the merged cells from the merged cell container.\n     */\n\n  }, {\n    key: \"clearCollections\",\n    value: function clearCollections() {\n      this.mergedCellsCollection.clear();\n    }\n    /**\n     * Returns `true` if a range is mergeable.\n     *\n     * @private\n     * @param {Object} newMergedCellInfo Merged cell information object to test.\n     * @param {Boolean} [auto=false] `true` if triggered at initialization.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"canMergeRange\",\n    value: function canMergeRange(newMergedCellInfo) {\n      var auto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return auto ? true : this.validateSetting(newMergedCellInfo);\n    }\n    /**\n     * Merge or unmerge, based on last selected range.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"toggleMergeOnSelection\",\n    value: function toggleMergeOnSelection() {\n      var currentRange = this.hot.getSelectedRangeLast();\n\n      if (!currentRange) {\n        return;\n      }\n\n      currentRange.setDirection('NW-SE');\n      var from = currentRange.from,\n          to = currentRange.to;\n      this.toggleMerge(currentRange);\n      this.hot.selectCell(from.row, from.col, to.row, to.col, false);\n    }\n    /**\n     * Merges the selection provided as a cell range.\n     *\n     * @param {CellRange} [cellRange] Selection cell range.\n     */\n\n  }, {\n    key: \"mergeSelection\",\n    value: function mergeSelection() {\n      var cellRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.hot.getSelectedRangeLast();\n\n      if (!cellRange) {\n        return;\n      }\n\n      cellRange.setDirection('NW-SE');\n      var from = cellRange.from,\n          to = cellRange.to;\n      this.unmergeRange(cellRange, true);\n      this.mergeRange(cellRange);\n      this.hot.selectCell(from.row, from.col, to.row, to.col, false);\n    }\n    /**\n     * Unmerges the selection provided as a cell range.\n     *\n     * @param {CellRange} [cellRange] Selection cell range.\n     */\n\n  }, {\n    key: \"unmergeSelection\",\n    value: function unmergeSelection() {\n      var cellRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.hot.getSelectedRangeLast();\n\n      if (!cellRange) {\n        return;\n      }\n\n      var from = cellRange.from,\n          to = cellRange.to;\n      this.unmergeRange(cellRange, true);\n      this.hot.selectCell(from.row, from.col, to.row, to.col, false);\n    }\n    /**\n     * Merges cells in the provided cell range.\n     *\n     * @private\n     * @param {CellRange} cellRange Cell range to merge.\n     * @param {Boolean} [auto=false] `true` if is called automatically, e.g. at initialization.\n     * @param {Boolean} [preventPopulation=false] `true`, if the method should not run `populateFromArray` at the end, but rather return its arguments.\n     * @returns {Array|Boolean} Returns an array of [row, column, dataUnderCollection] if preventPopulation is set to true. If the the merging process went successful, it returns `true`, otherwise - `false`.\n     * @fires Hooks#beforeMergeCells\n     * @fires Hooks#afterMergeCells\n     */\n\n  }, {\n    key: \"mergeRange\",\n    value: function mergeRange(cellRange) {\n      var _this4 = this;\n\n      var auto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var preventPopulation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var topLeft = cellRange.getTopLeftCorner();\n      var bottomRight = cellRange.getBottomRightCorner();\n      var mergeParent = {\n        row: topLeft.row,\n        col: topLeft.col,\n        rowspan: bottomRight.row - topLeft.row + 1,\n        colspan: bottomRight.col - topLeft.col + 1\n      };\n      var clearedData = [];\n      var populationInfo = null;\n\n      if (!this.canMergeRange(mergeParent, auto)) {\n        return false;\n      }\n\n      this.hot.runHooks('beforeMergeCells', cellRange, auto);\n      rangeEach(0, mergeParent.rowspan - 1, function (i) {\n        rangeEach(0, mergeParent.colspan - 1, function (j) {\n          var clearedValue = null;\n\n          if (!clearedData[i]) {\n            clearedData[i] = [];\n          }\n\n          if (i === 0 && j === 0) {\n            clearedValue = _this4.hot.getDataAtCell(mergeParent.row, mergeParent.col);\n          } else {\n            _this4.hot.setCellMeta(mergeParent.row + i, mergeParent.col + j, 'hidden', true);\n          }\n\n          clearedData[i][j] = clearedValue;\n        });\n      });\n      this.hot.setCellMeta(mergeParent.row, mergeParent.col, 'spanned', true);\n      var mergedCellAdded = this.mergedCellsCollection.add(mergeParent);\n\n      if (mergedCellAdded) {\n        if (preventPopulation) {\n          populationInfo = [mergeParent.row, mergeParent.col, clearedData];\n        } else {\n          this.hot.populateFromArray(mergeParent.row, mergeParent.col, clearedData, void 0, void 0, this.pluginName);\n        }\n\n        this.hot.runHooks('afterMergeCells', cellRange, mergeParent, auto);\n        return populationInfo;\n      }\n\n      return true;\n    }\n    /**\n     * Unmerges the selection provided as a cell range. If no cell range is provided, it uses the current selection.\n     *\n     * @private\n     * @param {CellRange} cellRange Selection cell range.\n     * @param {Boolean} [auto=false] `true` if called automatically by the plugin.\n     *\n     * @fires Hooks#beforeUnmergeCells\n     * @fires Hooks#afterUnmergeCells\n     */\n\n  }, {\n    key: \"unmergeRange\",\n    value: function unmergeRange(cellRange) {\n      var _this5 = this;\n\n      var auto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var mergedCells = this.mergedCellsCollection.getWithinRange(cellRange);\n\n      if (!mergedCells) {\n        return;\n      }\n\n      this.hot.runHooks('beforeUnmergeCells', cellRange, auto);\n      arrayEach(mergedCells, function (currentCollection) {\n        _this5.mergedCellsCollection.remove(currentCollection.row, currentCollection.col);\n\n        rangeEach(0, currentCollection.rowspan - 1, function (i) {\n          rangeEach(0, currentCollection.colspan - 1, function (j) {\n            _this5.hot.removeCellMeta(currentCollection.row + i, currentCollection.col + j, 'hidden');\n          });\n        });\n\n        _this5.hot.removeCellMeta(currentCollection.row, currentCollection.col, 'spanned');\n      });\n      this.hot.render();\n      this.hot.runHooks('afterUnmergeCells', cellRange, auto);\n    }\n    /**\n     * Merges or unmerges, based on the cell range provided as `cellRange`.\n     *\n     * @private\n     * @param {CellRange} cellRange The cell range to merge or unmerged.\n     */\n\n  }, {\n    key: \"toggleMerge\",\n    value: function toggleMerge(cellRange) {\n      var mergedCell = this.mergedCellsCollection.get(cellRange.from.row, cellRange.from.col);\n      var mergedCellCoversWholeRange = mergedCell.row === cellRange.from.row && mergedCell.col === cellRange.from.col && mergedCell.row + mergedCell.rowspan - 1 === cellRange.to.row && mergedCell.col + mergedCell.colspan - 1 === cellRange.to.col;\n\n      if (mergedCellCoversWholeRange) {\n        this.unmergeRange(cellRange);\n      } else {\n        this.mergeSelection(cellRange);\n      }\n    }\n    /**\n     * Merges the specified range.\n     *\n     * @param {Number} startRow Start row of the merged cell.\n     * @param {Number} startColumn Start column of the merged cell.\n     * @param {Number} endRow End row of the merged cell.\n     * @param {Number} endColumn End column of the merged cell.\n     * @fires Hooks#beforeMergeCells\n     * @fires Hooks#afterMergeCells\n     */\n\n  }, {\n    key: \"merge\",\n    value: function merge(startRow, startColumn, endRow, endColumn) {\n      var start = new CellCoords(startRow, startColumn);\n      var end = new CellCoords(endRow, endColumn);\n      this.mergeRange(new CellRange(start, start, end));\n    }\n    /**\n     * Unmerges the merged cell in the provided range.\n     *\n     * @param {Number} startRow Start row of the merged cell.\n     * @param {Number} startColumn Start column of the merged cell.\n     * @param {Number} endRow End row of the merged cell.\n     * @param {Number} endColumn End column of the merged cell.\n     * @fires Hooks#beforeUnmergeCells\n     * @fires Hooks#afterUnmergeCells\n     */\n\n  }, {\n    key: \"unmerge\",\n    value: function unmerge(startRow, startColumn, endRow, endColumn) {\n      var start = new CellCoords(startRow, startColumn);\n      var end = new CellCoords(endRow, endColumn);\n      this.unmergeRange(new CellRange(start, start, end));\n    }\n    /**\n     * `afterInit` hook callback.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"onAfterInit\",\n    value: function onAfterInit() {\n      this.generateFromSettings(this.hot.getSettings().mergeCells);\n      this.hot.render();\n    }\n    /**\n     * `beforeKeyDown` hook callback.\n     *\n     * @private\n     * @param {KeyboardEvent} event The `keydown` event object.\n     */\n\n  }, {\n    key: \"onBeforeKeyDown\",\n    value: function onBeforeKeyDown(event) {\n      var ctrlDown = (event.ctrlKey || event.metaKey) && !event.altKey;\n\n      if (ctrlDown && event.keyCode === 77) {\n        // CTRL + M\n        this.toggleMerge(this.hot.getSelectedRangeLast());\n        this.hot.render();\n        stopImmediatePropagation(event);\n      }\n    }\n    /**\n     * Modifies the information on whether the current selection contains multiple cells. The `afterIsMultipleSelection` hook callback.\n     *\n     * @private\n     * @param {Boolean} isMultiple\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"onAfterIsMultipleSelection\",\n    value: function onAfterIsMultipleSelection(isMultiple) {\n      if (isMultiple) {\n        var mergedCells = this.mergedCellsCollection.mergedCells;\n        var selectionRange = this.hot.getSelectedRangeLast();\n\n        for (var group = 0; group < mergedCells.length; group += 1) {\n          if (selectionRange.highlight.row === mergedCells[group].row && selectionRange.highlight.col === mergedCells[group].col && selectionRange.to.row === mergedCells[group].row + mergedCells[group].rowspan - 1 && selectionRange.to.col === mergedCells[group].col + mergedCells[group].colspan - 1) {\n            return false;\n          }\n        }\n      }\n\n      return isMultiple;\n    }\n    /**\n     * `modifyTransformStart` hook callback.\n     *\n     * @private\n     * @param {Object} delta The transformation delta.\n     */\n\n  }, {\n    key: \"onModifyTransformStart\",\n    value: function onModifyTransformStart(delta) {\n      var priv = privatePool.get(this);\n      var currentlySelectedRange = this.hot.getSelectedRangeLast();\n      var newDelta = {\n        row: delta.row,\n        col: delta.col\n      };\n      var nextPosition = null;\n      var currentPosition = new CellCoords(currentlySelectedRange.highlight.row, currentlySelectedRange.highlight.col);\n      var mergedParent = this.mergedCellsCollection.get(currentPosition.row, currentPosition.col);\n\n      if (!priv.lastDesiredCoords) {\n        priv.lastDesiredCoords = new CellCoords(null, null);\n      }\n\n      if (mergedParent) {\n        // only merge selected\n        var mergeTopLeft = new CellCoords(mergedParent.row, mergedParent.col);\n        var mergeBottomRight = new CellCoords(mergedParent.row + mergedParent.rowspan - 1, mergedParent.col + mergedParent.colspan - 1);\n        var mergeRange = new CellRange(mergeTopLeft, mergeTopLeft, mergeBottomRight);\n\n        if (!mergeRange.includes(priv.lastDesiredCoords)) {\n          priv.lastDesiredCoords = new CellCoords(null, null); // reset outdated version of lastDesiredCoords\n        }\n\n        newDelta.row = priv.lastDesiredCoords.row ? priv.lastDesiredCoords.row - currentPosition.row : newDelta.row;\n        newDelta.col = priv.lastDesiredCoords.col ? priv.lastDesiredCoords.col - currentPosition.col : newDelta.col;\n\n        if (delta.row > 0) {\n          // moving down\n          newDelta.row = mergedParent.row + mergedParent.rowspan - 1 - currentPosition.row + delta.row;\n        } else if (delta.row < 0) {\n          // moving up\n          newDelta.row = currentPosition.row - mergedParent.row + delta.row;\n        }\n\n        if (delta.col > 0) {\n          // moving right\n          newDelta.col = mergedParent.col + mergedParent.colspan - 1 - currentPosition.col + delta.col;\n        } else if (delta.col < 0) {\n          // moving left\n          newDelta.col = currentPosition.col - mergedParent.col + delta.col;\n        }\n      }\n\n      nextPosition = new CellCoords(currentlySelectedRange.highlight.row + newDelta.row, currentlySelectedRange.highlight.col + newDelta.col);\n      var nextParentIsMerged = this.mergedCellsCollection.get(nextPosition.row, nextPosition.col);\n\n      if (nextParentIsMerged) {\n        // skipping the invisible cells in the merge range\n        priv.lastDesiredCoords = nextPosition;\n        newDelta = {\n          row: nextParentIsMerged.row - currentPosition.row,\n          col: nextParentIsMerged.col - currentPosition.col\n        };\n      }\n\n      if (newDelta.row !== 0) {\n        delta.row = newDelta.row;\n      }\n\n      if (newDelta.col !== 0) {\n        delta.col = newDelta.col;\n      }\n    }\n    /**\n     * `modifyTransformEnd` hook callback. Needed to handle \"jumping over\" merged merged cells, while selecting.\n     *\n     * @private\n     * @param {Object} delta The transformation delta.\n     */\n\n  }, {\n    key: \"onModifyTransformEnd\",\n    value: function onModifyTransformEnd(delta) {\n      var _this6 = this;\n\n      var currentSelectionRange = this.hot.getSelectedRangeLast();\n      var newDelta = clone(delta);\n      var newSelectionRange = this.selectionCalculations.getUpdatedSelectionRange(currentSelectionRange, delta);\n      var tempDelta = clone(newDelta);\n      var mergedCellsWithinRange = this.mergedCellsCollection.getWithinRange(newSelectionRange, true);\n\n      do {\n        tempDelta = clone(newDelta);\n        this.selectionCalculations.getUpdatedSelectionRange(currentSelectionRange, newDelta);\n        arrayEach(mergedCellsWithinRange, function (mergedCell) {\n          _this6.selectionCalculations.snapDelta(newDelta, currentSelectionRange, mergedCell);\n        });\n      } while (newDelta.row !== tempDelta.row || newDelta.col !== tempDelta.col);\n\n      delta.row = newDelta.row;\n      delta.col = newDelta.col;\n    }\n    /**\n     * `modifyGetCellCoords` hook callback. Swaps the `getCell` coords with the merged parent coords.\n     *\n     * @private\n     * @param {Number} row Row index.\n     * @param {Number} column Column index.\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"onModifyGetCellCoords\",\n    value: function onModifyGetCellCoords(row, column) {\n      var mergeParent = this.mergedCellsCollection.get(row, column);\n      return mergeParent ? [mergeParent.row, mergeParent.col, mergeParent.row + mergeParent.rowspan - 1, mergeParent.col + mergeParent.colspan - 1] : void 0;\n    }\n    /**\n     * `afterContextMenuDefaultOptions` hook callback.\n     *\n     * @private\n     * @param {Object} defaultOptions The default context menu options.\n     */\n\n  }, {\n    key: \"addMergeActionsToContextMenu\",\n    value: function addMergeActionsToContextMenu(defaultOptions) {\n      defaultOptions.items.push({\n        name: '---------'\n      }, toggleMergeItem(this));\n    }\n    /**\n     * `afterRenderer` hook callback.\n     *\n     * @private\n     * @param {HTMLElement} TD The cell to be modified.\n     * @param {Number} row Row index.\n     * @param {Number} col Column index.\n     */\n\n  }, {\n    key: \"onAfterRenderer\",\n    value: function onAfterRenderer(TD, row, col) {\n      var mergedCell = this.mergedCellsCollection.get(row, col);\n      applySpanProperties(TD, mergedCell, row, col);\n    }\n    /**\n     * `beforeSetRangeEnd` hook callback.\n     * While selecting cells with keyboard or mouse, make sure that rectangular area is expanded to the extent of the merged cell\n     *\n     * @private\n     * @param {Object} coords Cell coords.\n     */\n\n  }, {\n    key: \"onBeforeSetRangeEnd\",\n    value: function onBeforeSetRangeEnd(coords) {\n      var selRange = this.hot.getSelectedRangeLast();\n      selRange.highlight = new CellCoords(selRange.highlight.row, selRange.highlight.col); // clone in case we will modify its reference\n\n      selRange.to = coords;\n      var rangeExpanded = false;\n\n      if (this.hot.selection.isSelectedByColumnHeader() || this.hot.selection.isSelectedByRowHeader()) {\n        return;\n      }\n\n      do {\n        rangeExpanded = false;\n\n        for (var i = 0; i < this.mergedCellsCollection.mergedCells.length; i += 1) {\n          var cellInfo = this.mergedCellsCollection.mergedCells[i];\n          var mergedCellRange = cellInfo.getRange();\n\n          if (selRange.expandByRange(mergedCellRange)) {\n            coords.row = selRange.to.row;\n            coords.col = selRange.to.col;\n            rangeExpanded = true;\n          }\n        }\n      } while (rangeExpanded);\n    }\n    /**\n     * The `afterGetCellMeta` hook callback.\n     *\n     * @private\n     * @param {Number} row Row index.\n     * @param {Number} col Column index.\n     * @param {Object} cellProperties The cell properties object.\n     */\n\n  }, {\n    key: \"onAfterGetCellMeta\",\n    value: function onAfterGetCellMeta(row, col, cellProperties) {\n      var mergeParent = this.mergedCellsCollection.get(row, col);\n\n      if (mergeParent) {\n        if (mergeParent.row !== row || mergeParent.col !== col) {\n          cellProperties.copyable = false;\n        } else {\n          cellProperties.rowspan = mergeParent.rowspan;\n          cellProperties.colspan = mergeParent.colspan;\n        }\n      }\n    }\n    /**\n     * `afterViewportRowCalculatorOverride` hook callback.\n     *\n     * @private\n     * @param {Object} calc The row calculator object.\n     */\n\n  }, {\n    key: \"onAfterViewportRowCalculatorOverride\",\n    value: function onAfterViewportRowCalculatorOverride(calc) {\n      var _this7 = this;\n\n      var colCount = this.hot.countCols();\n      var mergeParent;\n      rangeEach(0, colCount - 1, function (c) {\n        mergeParent = _this7.mergedCellsCollection.get(calc.startRow, c);\n\n        if (mergeParent) {\n          if (mergeParent.row < calc.startRow) {\n            calc.startRow = mergeParent.row;\n            return _this7.onAfterViewportRowCalculatorOverride.call(_this7, calc); // recursively search upwards\n          }\n        }\n\n        mergeParent = _this7.mergedCellsCollection.get(calc.endRow, c);\n\n        if (mergeParent) {\n          var mergeEnd = mergeParent.row + mergeParent.rowspan - 1;\n\n          if (mergeEnd > calc.endRow) {\n            calc.endRow = mergeEnd;\n            return _this7.onAfterViewportRowCalculatorOverride.call(_this7, calc); // recursively search upwards\n          }\n        }\n\n        return true;\n      });\n    }\n    /**\n     * `afterViewportColumnCalculatorOverride` hook callback.\n     *\n     * @private\n     * @param {Object} calc The column calculator object.\n     */\n\n  }, {\n    key: \"onAfterViewportColumnCalculatorOverride\",\n    value: function onAfterViewportColumnCalculatorOverride(calc) {\n      var _this8 = this;\n\n      var rowCount = this.hot.countRows();\n      var mergeParent;\n      rangeEach(0, rowCount - 1, function (r) {\n        mergeParent = _this8.mergedCellsCollection.get(r, calc.startColumn);\n\n        if (mergeParent && mergeParent.col < calc.startColumn) {\n          calc.startColumn = mergeParent.col;\n          return _this8.onAfterViewportColumnCalculatorOverride.call(_this8, calc); // recursively search upwards\n        }\n\n        mergeParent = _this8.mergedCellsCollection.get(r, calc.endColumn);\n\n        if (mergeParent) {\n          var mergeEnd = mergeParent.col + mergeParent.colspan - 1;\n\n          if (mergeEnd > calc.endColumn) {\n            calc.endColumn = mergeEnd;\n            return _this8.onAfterViewportColumnCalculatorOverride.call(_this8, calc); // recursively search upwards\n          }\n        }\n\n        return true;\n      });\n    }\n    /**\n     * The `modifyAutofillRange` hook callback.\n     *\n     * @private\n     * @param {Array} drag The drag area coordinates.\n     * @param {Array} select The selection information.\n     * @return {Array} The new drag area.\n     */\n\n  }, {\n    key: \"onModifyAutofillRange\",\n    value: function onModifyAutofillRange(drag, select) {\n      this.autofillCalculations.correctSelectionAreaSize(select);\n      var dragDirection = this.autofillCalculations.getDirection(select, drag);\n      var dragArea = drag;\n\n      if (this.autofillCalculations.dragAreaOverlapsCollections(select, dragArea, dragDirection)) {\n        dragArea = select;\n        return dragArea;\n      }\n\n      var mergedCellsWithinSelectionArea = this.mergedCellsCollection.getWithinRange({\n        from: {\n          row: select[0],\n          col: select[1]\n        },\n        to: {\n          row: select[2],\n          col: select[3]\n        }\n      });\n\n      if (!mergedCellsWithinSelectionArea) {\n        return dragArea;\n      }\n\n      dragArea = this.autofillCalculations.snapDragArea(select, dragArea, dragDirection, mergedCellsWithinSelectionArea);\n      return dragArea;\n    }\n    /**\n     * `afterCreateCol` hook callback.\n     *\n     * @private\n     * @param {Number} column Column index.\n     * @param {Number} count Number of created columns.\n     */\n\n  }, {\n    key: \"onAfterCreateCol\",\n    value: function onAfterCreateCol(column, count) {\n      this.mergedCellsCollection.shiftCollections('right', column, count);\n    }\n    /**\n     * `afterRemoveCol` hook callback.\n     *\n     * @private\n     * @param {Number} column Column index.\n     * @param {Number} count Number of removed columns.\n     */\n\n  }, {\n    key: \"onAfterRemoveCol\",\n    value: function onAfterRemoveCol(column, count) {\n      this.mergedCellsCollection.shiftCollections('left', column, count);\n    }\n    /**\n     * `afterCreateRow` hook callback.\n     *\n     * @private\n     * @param {Number} row Row index.\n     * @param {Number} count Number of created rows.\n     * @param {String} source Source of change.\n     */\n\n  }, {\n    key: \"onAfterCreateRow\",\n    value: function onAfterCreateRow(row, count, source) {\n      if (source === 'auto') {\n        return;\n      }\n\n      this.mergedCellsCollection.shiftCollections('down', row, count);\n    }\n    /**\n     * `afterRemoveRow` hook callback.\n     *\n     * @private\n     * @param {Number} row Row index.\n     * @param {Number} count Number of removed rows.\n     */\n\n  }, {\n    key: \"onAfterRemoveRow\",\n    value: function onAfterRemoveRow(row, count) {\n      this.mergedCellsCollection.shiftCollections('up', row, count);\n    }\n    /**\n     * `afterChange` hook callback. Used to propagate merged cells after using Autofill.\n     *\n     * @private\n     * @param {Array} changes The changes array.\n     * @param {String} source Determines the source of the change.\n     */\n\n  }, {\n    key: \"onAfterChange\",\n    value: function onAfterChange(changes, source) {\n      if (source !== 'Autofill.fill') {\n        return;\n      }\n\n      this.autofillCalculations.recreateAfterDataPopulation(changes);\n    }\n    /**\n     * `beforeDrawAreaBorders` hook callback.\n     *\n     * @private\n     * @param {Array} corners Coordinates of the area corners.\n     * @param {String} className Class name for the area.\n     */\n\n  }, {\n    key: \"onBeforeDrawAreaBorders\",\n    value: function onBeforeDrawAreaBorders(corners, className) {\n      if (className && className === 'area') {\n        var selectedRange = this.hot.getSelectedRangeLast();\n        var mergedCellsWithinRange = this.mergedCellsCollection.getWithinRange(selectedRange);\n        arrayEach(mergedCellsWithinRange, function (mergedCell) {\n          if (selectedRange.getBottomRightCorner().row === mergedCell.getLastRow() && selectedRange.getBottomRightCorner().col === mergedCell.getLastColumn()) {\n            corners[2] = mergedCell.row;\n            corners[3] = mergedCell.col;\n          }\n        });\n      }\n    }\n    /**\n     * `afterModifyTransformStart` hook callback. Fixes a problem with navigating through merged cells at the edges of the table\n     * with the ENTER/SHIFT+ENTER/TAB/SHIFT+TAB keys.\n     *\n     * @private\n     * @param {CellCoords} coords Coordinates of the to-be-selected cell.\n     * @param {Number} rowTransformDir Row transformation direction (negative value = up, 0 = none, positive value = down)\n     * @param {Number} colTransformDir Column transformation direction (negative value = up, 0 = none, positive value = down)\n     */\n\n  }, {\n    key: \"onAfterModifyTransformStart\",\n    value: function onAfterModifyTransformStart(coords, rowTransformDir, colTransformDir) {\n      if (!this.enabled) {\n        return;\n      }\n\n      var mergedCellAtCoords = this.mergedCellsCollection.get(coords.row, coords.col);\n\n      if (!mergedCellAtCoords) {\n        return;\n      }\n\n      var goingDown = rowTransformDir > 0;\n      var goingUp = rowTransformDir < 0;\n      var goingLeft = colTransformDir < 0;\n      var goingRight = colTransformDir > 0;\n      var mergedCellOnBottomEdge = mergedCellAtCoords.row + mergedCellAtCoords.rowspan - 1 === this.hot.countRows() - 1;\n      var mergedCellOnTopEdge = mergedCellAtCoords.row === 0;\n      var mergedCellOnRightEdge = mergedCellAtCoords.col + mergedCellAtCoords.colspan - 1 === this.hot.countCols() - 1;\n      var mergedCellOnLeftEdge = mergedCellAtCoords.col === 0;\n\n      if (goingDown && mergedCellOnBottomEdge || goingUp && mergedCellOnTopEdge || goingRight && mergedCellOnRightEdge || goingLeft && mergedCellOnLeftEdge) {\n        coords.row = mergedCellAtCoords.row;\n        coords.col = mergedCellAtCoords.col;\n      }\n    }\n    /**\n     * `afterDrawSelection` hook callback. Used to add the additional class name for the entirely-selected merged cells.\n     *\n     * @private\n     * @param {Number} currentRow Row index of the currently processed cell.\n     * @param {Number} currentColumn Column index of the currently cell.\n     * @param {Array} cornersOfSelection Array of the current selection in a form of `[startRow, startColumn, endRow, endColumn]`.\n     * @param {Number|undefined} layerLevel Number indicating which layer of selection is currently processed.\n     * @returns {String|undefined} A `String`, which will act as an additional `className` to be added to the currently processed cell.\n     */\n\n  }, {\n    key: \"onAfterDrawSelection\",\n    value: function onAfterDrawSelection(currentRow, currentColumn, cornersOfSelection, layerLevel) {\n      return this.selectionCalculations.getSelectedMergedCellClassName(currentRow, currentColumn, cornersOfSelection, layerLevel);\n    }\n    /**\n     * `beforeRemoveCellClassNames` hook callback. Used to remove additional class name from all cells in the table.\n     *\n     * @private\n     * @returns {String[]} An `Array` of `String`s. Each of these strings will act like class names to be removed from all the cells in the table.\n     */\n\n  }, {\n    key: \"onBeforeRemoveCellClassNames\",\n    value: function onBeforeRemoveCellClassNames() {\n      return this.selectionCalculations.getSelectedMergedCellClassNameToRemove();\n    }\n  }]);\n\n  return MergeCells;\n}(BasePlugin);\n\nregisterPlugin('mergeCells', MergeCells);\nexport default MergeCells;"],"mappings":"AAoBA,SAASA,OAAO,CAACC,GAAG,EAAE;EAAE,yBAAyB;;EAAE,IAAI,OAAOC,MAAM,KAAK,UAAU,IAAI,OAAOA,MAAM,CAACC,QAAQ,KAAK,QAAQ,EAAE;IAAEH,OAAO,GAAG,SAASA,OAAO,CAACC,GAAG,EAAE;MAAE,OAAO,OAAOA,GAAG;IAAE,CAAC;EAAE,CAAC,MAAM;IAAED,OAAO,GAAG,SAASA,OAAO,CAACC,GAAG,EAAE;MAAE,OAAOA,GAAG,IAAI,OAAOC,MAAM,KAAK,UAAU,IAAID,GAAG,CAACG,WAAW,KAAKF,MAAM,IAAID,GAAG,KAAKC,MAAM,CAACG,SAAS,GAAG,QAAQ,GAAG,OAAOJ,GAAG;IAAE,CAAC;EAAE;EAAE,OAAOD,OAAO,CAACC,GAAG,CAAC;AAAE;AAEzX,SAASK,cAAc,CAACC,GAAG,EAAEC,CAAC,EAAE;EAAE,OAAOC,eAAe,CAACF,GAAG,CAAC,IAAIG,qBAAqB,CAACH,GAAG,EAAEC,CAAC,CAAC,IAAIG,gBAAgB,EAAE;AAAE;AAEtH,SAASA,gBAAgB,GAAG;EAAE,MAAM,IAAIC,SAAS,CAAC,sDAAsD,CAAC;AAAE;AAE3G,SAASF,qBAAqB,CAACH,GAAG,EAAEC,CAAC,EAAE;EAAE,IAAI,EAAEN,MAAM,CAACC,QAAQ,IAAIU,MAAM,CAACN,GAAG,CAAC,IAAIM,MAAM,CAACR,SAAS,CAACS,QAAQ,CAACC,IAAI,CAACR,GAAG,CAAC,KAAK,oBAAoB,CAAC,EAAE;IAAE;EAAQ;EAAE,IAAIS,IAAI,GAAG,EAAE;EAAE,IAAIC,EAAE,GAAG,IAAI;EAAE,IAAIC,EAAE,GAAG,KAAK;EAAE,IAAIC,EAAE,GAAGC,SAAS;EAAE,IAAI;IAAE,KAAK,IAAIC,EAAE,GAAGd,GAAG,CAACL,MAAM,CAACC,QAAQ,CAAC,EAAE,EAAEmB,EAAE,EAAE,EAAEL,EAAE,GAAG,CAACK,EAAE,GAAGD,EAAE,CAACE,IAAI,EAAE,EAAEC,IAAI,CAAC,EAAEP,EAAE,GAAG,IAAI,EAAE;MAAED,IAAI,CAACS,IAAI,CAACH,EAAE,CAACI,KAAK,CAAC;MAAE,IAAIlB,CAAC,IAAIQ,IAAI,CAACW,MAAM,KAAKnB,CAAC,EAAE;IAAO;EAAE,CAAC,CAAC,OAAOoB,GAAG,EAAE;IAAEV,EAAE,GAAG,IAAI;IAAEC,EAAE,GAAGS,GAAG;EAAE,CAAC,SAAS;IAAE,IAAI;MAAE,IAAI,CAACX,EAAE,IAAII,EAAE,CAAC,QAAQ,CAAC,IAAI,IAAI,EAAEA,EAAE,CAAC,QAAQ,CAAC,EAAE;IAAE,CAAC,SAAS;MAAE,IAAIH,EAAE,EAAE,MAAMC,EAAE;IAAE;EAAE;EAAE,OAAOH,IAAI;AAAE;AAE3gB,SAASP,eAAe,CAACF,GAAG,EAAE;EAAE,IAAIsB,KAAK,CAACC,OAAO,CAACvB,GAAG,CAAC,EAAE,OAAOA,GAAG;AAAE;AAEpE,SAASwB,kBAAkB,CAACxB,GAAG,EAAE;EAAE,OAAOyB,kBAAkB,CAACzB,GAAG,CAAC,IAAI0B,gBAAgB,CAAC1B,GAAG,CAAC,IAAI2B,kBAAkB,EAAE;AAAE;AAEpH,SAASA,kBAAkB,GAAG;EAAE,MAAM,IAAItB,SAAS,CAAC,iDAAiD,CAAC;AAAE;AAExG,SAASqB,gBAAgB,CAACE,IAAI,EAAE;EAAE,IAAIjC,MAAM,CAACC,QAAQ,IAAIU,MAAM,CAACsB,IAAI,CAAC,IAAItB,MAAM,CAACR,SAAS,CAACS,QAAQ,CAACC,IAAI,CAACoB,IAAI,CAAC,KAAK,oBAAoB,EAAE,OAAON,KAAK,CAACO,IAAI,CAACD,IAAI,CAAC;AAAE;AAEjK,SAASH,kBAAkB,CAACzB,GAAG,EAAE;EAAE,IAAIsB,KAAK,CAACC,OAAO,CAACvB,GAAG,CAAC,EAAE;IAAE,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAE6B,IAAI,GAAG,IAAIR,KAAK,CAACtB,GAAG,CAACoB,MAAM,CAAC,EAAEnB,CAAC,GAAGD,GAAG,CAACoB,MAAM,EAAEnB,CAAC,EAAE,EAAE;MAAE6B,IAAI,CAAC7B,CAAC,CAAC,GAAGD,GAAG,CAACC,CAAC,CAAC;IAAE;IAAE,OAAO6B,IAAI;EAAE;AAAE;AAErK,SAASC,eAAe,CAACC,QAAQ,EAAEC,WAAW,EAAE;EAAE,IAAI,EAAED,QAAQ,YAAYC,WAAW,CAAC,EAAE;IAAE,MAAM,IAAI5B,SAAS,CAAC,mCAAmC,CAAC;EAAE;AAAE;AAExJ,SAAS6B,iBAAiB,CAACC,MAAM,EAAEC,KAAK,EAAE;EAAE,KAAK,IAAInC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmC,KAAK,CAAChB,MAAM,EAAEnB,CAAC,EAAE,EAAE;IAAE,IAAIoC,UAAU,GAAGD,KAAK,CAACnC,CAAC,CAAC;IAAEoC,UAAU,CAACC,UAAU,GAAGD,UAAU,CAACC,UAAU,IAAI,KAAK;IAAED,UAAU,CAACE,YAAY,GAAG,IAAI;IAAE,IAAI,OAAO,IAAIF,UAAU,EAAEA,UAAU,CAACG,QAAQ,GAAG,IAAI;IAAElC,MAAM,CAACmC,cAAc,CAACN,MAAM,EAAEE,UAAU,CAACK,GAAG,EAAEL,UAAU,CAAC;EAAE;AAAE;AAE5T,SAASM,YAAY,CAACV,WAAW,EAAEW,UAAU,EAAEC,WAAW,EAAE;EAAE,IAAID,UAAU,EAAEV,iBAAiB,CAACD,WAAW,CAACnC,SAAS,EAAE8C,UAAU,CAAC;EAAE,IAAIC,WAAW,EAAEX,iBAAiB,CAACD,WAAW,EAAEY,WAAW,CAAC;EAAE,OAAOZ,WAAW;AAAE;AAEtN,SAASa,0BAA0B,CAACC,IAAI,EAAEvC,IAAI,EAAE;EAAE,IAAIA,IAAI,KAAKf,OAAO,CAACe,IAAI,CAAC,KAAK,QAAQ,IAAI,OAAOA,IAAI,KAAK,UAAU,CAAC,EAAE;IAAE,OAAOA,IAAI;EAAE;EAAE,OAAOwC,sBAAsB,CAACD,IAAI,CAAC;AAAE;AAEhL,SAASC,sBAAsB,CAACD,IAAI,EAAE;EAAE,IAAIA,IAAI,KAAK,KAAK,CAAC,EAAE;IAAE,MAAM,IAAIE,cAAc,CAAC,2DAA2D,CAAC;EAAE;EAAE,OAAOF,IAAI;AAAE;AAErK,SAASG,IAAI,CAACf,MAAM,EAAEgB,QAAQ,EAAEC,QAAQ,EAAE;EAAE,IAAI,OAAOC,OAAO,KAAK,WAAW,IAAIA,OAAO,CAACC,GAAG,EAAE;IAAEJ,IAAI,GAAGG,OAAO,CAACC,GAAG;EAAE,CAAC,MAAM;IAAEJ,IAAI,GAAG,SAASA,IAAI,CAACf,MAAM,EAAEgB,QAAQ,EAAEC,QAAQ,EAAE;MAAE,IAAIG,IAAI,GAAGC,cAAc,CAACrB,MAAM,EAAEgB,QAAQ,CAAC;MAAE,IAAI,CAACI,IAAI,EAAE;MAAQ,IAAIE,IAAI,GAAGnD,MAAM,CAACoD,wBAAwB,CAACH,IAAI,EAAEJ,QAAQ,CAAC;MAAE,IAAIM,IAAI,CAACH,GAAG,EAAE;QAAE,OAAOG,IAAI,CAACH,GAAG,CAAC9C,IAAI,CAAC4C,QAAQ,CAAC;MAAE;MAAE,OAAOK,IAAI,CAACtC,KAAK;IAAE,CAAC;EAAE;EAAE,OAAO+B,IAAI,CAACf,MAAM,EAAEgB,QAAQ,EAAEC,QAAQ,IAAIjB,MAAM,CAAC;AAAE;AAE1a,SAASqB,cAAc,CAACG,MAAM,EAAER,QAAQ,EAAE;EAAE,OAAO,CAAC7C,MAAM,CAACR,SAAS,CAAC8D,cAAc,CAACpD,IAAI,CAACmD,MAAM,EAAER,QAAQ,CAAC,EAAE;IAAEQ,MAAM,GAAGE,eAAe,CAACF,MAAM,CAAC;IAAE,IAAIA,MAAM,KAAK,IAAI,EAAE;EAAO;EAAE,OAAOA,MAAM;AAAE;AAE7L,SAASE,eAAe,CAACC,CAAC,EAAE;EAAED,eAAe,GAAGvD,MAAM,CAACyD,cAAc,GAAGzD,MAAM,CAAC0D,cAAc,GAAG,SAASH,eAAe,CAACC,CAAC,EAAE;IAAE,OAAOA,CAAC,CAACG,SAAS,IAAI3D,MAAM,CAAC0D,cAAc,CAACF,CAAC,CAAC;EAAE,CAAC;EAAE,OAAOD,eAAe,CAACC,CAAC,CAAC;AAAE;AAE5M,SAASI,SAAS,CAACC,QAAQ,EAAEC,UAAU,EAAE;EAAE,IAAI,OAAOA,UAAU,KAAK,UAAU,IAAIA,UAAU,KAAK,IAAI,EAAE;IAAE,MAAM,IAAI/D,SAAS,CAAC,oDAAoD,CAAC;EAAE;EAAE8D,QAAQ,CAACrE,SAAS,GAAGQ,MAAM,CAAC+D,MAAM,CAACD,UAAU,IAAIA,UAAU,CAACtE,SAAS,EAAE;IAAED,WAAW,EAAE;MAAEsB,KAAK,EAAEgD,QAAQ;MAAE3B,QAAQ,EAAE,IAAI;MAAED,YAAY,EAAE;IAAK;EAAE,CAAC,CAAC;EAAE,IAAI6B,UAAU,EAAEE,eAAe,CAACH,QAAQ,EAAEC,UAAU,CAAC;AAAE;AAEhY,SAASE,eAAe,CAACR,CAAC,EAAES,CAAC,EAAE;EAAED,eAAe,GAAGhE,MAAM,CAACyD,cAAc,IAAI,SAASO,eAAe,CAACR,CAAC,EAAES,CAAC,EAAE;IAAET,CAAC,CAACG,SAAS,GAAGM,CAAC;IAAE,OAAOT,CAAC;EAAE,CAAC;EAAE,OAAOQ,eAAe,CAACR,CAAC,EAAES,CAAC,CAAC;AAAE;AAEzK,OAAOC,UAAU,MAAM,YAAY;AACnC,OAAOC,KAAK,MAAM,qBAAqB;AACvC,SAASC,cAAc,QAAQ,iBAAiB;AAChD,SAASC,wBAAwB,QAAQ,2BAA2B;AACpE,SAASC,UAAU,EAAEC,SAAS,QAAQ,kCAAkC;AACxE,OAAOC,qBAAqB,MAAM,mBAAmB;AACrD,OAAOC,gBAAgB,MAAM,cAAc;AAC3C,OAAOC,oBAAoB,MAAM,yBAAyB;AAC1D,OAAOC,qBAAqB,MAAM,0BAA0B;AAC5D,OAAOC,eAAe,MAAM,+BAA+B;AAC3D,SAASC,SAAS,QAAQ,qBAAqB;AAC/C,SAASC,KAAK,QAAQ,sBAAsB;AAC5C,SAASC,IAAI,QAAQ,uBAAuB;AAC5C,SAASC,SAAS,QAAQ,sBAAsB;AAChD,SAASC,mBAAmB,QAAQ,SAAS;AAC7Cd,KAAK,CAACe,YAAY,EAAE,CAACC,QAAQ,CAAC,kBAAkB,CAAC;AACjDhB,KAAK,CAACe,YAAY,EAAE,CAACC,QAAQ,CAAC,iBAAiB,CAAC;AAChDhB,KAAK,CAACe,YAAY,EAAE,CAACC,QAAQ,CAAC,oBAAoB,CAAC;AACnDhB,KAAK,CAACe,YAAY,EAAE,CAACC,QAAQ,CAAC,mBAAmB,CAAC;AAClD,IAAIC,WAAW,GAAG,IAAIC,OAAO,EAAE;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIC,UAAU,GACd;AACA,UAAUC,WAAW,EAAE;EACrB3B,SAAS,CAAC0B,UAAU,EAAEC,WAAW,CAAC;EAElC,SAASD,UAAU,CAACE,WAAW,EAAE;IAC/B,IAAIC,KAAK;IAEThE,eAAe,CAAC,IAAI,EAAE6D,UAAU,CAAC;IAEjCG,KAAK,GAAGjD,0BAA0B,CAAC,IAAI,EAAEe,eAAe,CAAC+B,UAAU,CAAC,CAACpF,IAAI,CAAC,IAAI,EAAEsF,WAAW,CAAC,CAAC;IAC7FJ,WAAW,CAACM,GAAG,CAAChD,sBAAsB,CAAC+C,KAAK,CAAC,EAAE;MAC7CE,iBAAiB,EAAE;IACrB,CAAC,CAAC;IACF;AACJ;AACA;AACA;AACA;AACA;;IAEIF,KAAK,CAACG,qBAAqB,GAAG,IAAI;IAClC;AACJ;AACA;AACA;AACA;AACA;;IAEIH,KAAK,CAACI,oBAAoB,GAAG,IAAI;IACjC;AACJ;AACA;AACA;AACA;AACA;;IAEIJ,KAAK,CAACK,qBAAqB,GAAG,IAAI;IAClC,OAAOL,KAAK;EACd;EACA;AACF;AACA;AACA;AACA;AACA;;EAGEpD,YAAY,CAACiD,UAAU,EAAE,CAAC;IACxBlD,GAAG,EAAE,WAAW;IAChBvB,KAAK,EAAE,SAASkF,SAAS,GAAG;MAC1B,OAAO,CAAC,CAAC,IAAI,CAACC,GAAG,CAACC,WAAW,EAAE,CAACC,UAAU;IAC5C;IACA;AACJ;AACA;EAEE,CAAC,EAAE;IACD9D,GAAG,EAAE,cAAc;IACnBvB,KAAK,EAAE,SAASsF,YAAY,GAAG;MAC7B,IAAIC,MAAM,GAAG,IAAI;MAEjB,IAAI,IAAI,CAACC,OAAO,EAAE;QAChB;MACF;MAEA,IAAI,CAACT,qBAAqB,GAAG,IAAIpB,qBAAqB,CAAC,IAAI,CAAC;MAC5D,IAAI,CAACqB,oBAAoB,GAAG,IAAInB,oBAAoB,CAAC,IAAI,CAAC;MAC1D,IAAI,CAACoB,qBAAqB,GAAG,IAAInB,qBAAqB,CAAC,IAAI,CAAC;MAC5D,IAAI,CAAC2B,OAAO,CAAC,WAAW,EAAE,YAAY;QACpC,OAAOF,MAAM,CAACG,WAAW,CAACC,KAAK,CAACJ,MAAM,EAAEK,SAAS,CAAC;MACpD,CAAC,CAAC;MACF,IAAI,CAACH,OAAO,CAAC,eAAe,EAAE,YAAY;QACxC,OAAOF,MAAM,CAACM,eAAe,CAACF,KAAK,CAACJ,MAAM,EAAEK,SAAS,CAAC;MACxD,CAAC,CAAC;MACF,IAAI,CAACH,OAAO,CAAC,sBAAsB,EAAE,YAAY;QAC/C,OAAOF,MAAM,CAACO,sBAAsB,CAACH,KAAK,CAACJ,MAAM,EAAEK,SAAS,CAAC;MAC/D,CAAC,CAAC;MACF,IAAI,CAACH,OAAO,CAAC,2BAA2B,EAAE,YAAY;QACpD,OAAOF,MAAM,CAACQ,2BAA2B,CAACJ,KAAK,CAACJ,MAAM,EAAEK,SAAS,CAAC;MACpE,CAAC,CAAC;MACF,IAAI,CAACH,OAAO,CAAC,oBAAoB,EAAE,YAAY;QAC7C,OAAOF,MAAM,CAACS,oBAAoB,CAACL,KAAK,CAACJ,MAAM,EAAEK,SAAS,CAAC;MAC7D,CAAC,CAAC;MACF,IAAI,CAACH,OAAO,CAAC,qBAAqB,EAAE,YAAY;QAC9C,OAAOF,MAAM,CAACU,qBAAqB,CAACN,KAAK,CAACJ,MAAM,EAAEK,SAAS,CAAC;MAC9D,CAAC,CAAC;MACF,IAAI,CAACH,OAAO,CAAC,mBAAmB,EAAE,YAAY;QAC5C,OAAOF,MAAM,CAACW,mBAAmB,CAACP,KAAK,CAACJ,MAAM,EAAEK,SAAS,CAAC;MAC5D,CAAC,CAAC;MACF,IAAI,CAACH,OAAO,CAAC,0BAA0B,EAAE,YAAY;QACnD,OAAOF,MAAM,CAACY,0BAA0B,CAACR,KAAK,CAACJ,MAAM,EAAEK,SAAS,CAAC;MACnE,CAAC,CAAC;MACF,IAAI,CAACH,OAAO,CAAC,eAAe,EAAE,YAAY;QACxC,OAAOF,MAAM,CAACa,eAAe,CAACT,KAAK,CAACJ,MAAM,EAAEK,SAAS,CAAC;MACxD,CAAC,CAAC;MACF,IAAI,CAACH,OAAO,CAAC,gCAAgC,EAAE,YAAY;QACzD,OAAOF,MAAM,CAACc,4BAA4B,CAACV,KAAK,CAACJ,MAAM,EAAEK,SAAS,CAAC;MACrE,CAAC,CAAC;MACF,IAAI,CAACH,OAAO,CAAC,kBAAkB,EAAE,YAAY;QAC3C,OAAOF,MAAM,CAACe,kBAAkB,CAACX,KAAK,CAACJ,MAAM,EAAEK,SAAS,CAAC;MAC3D,CAAC,CAAC;MACF,IAAI,CAACH,OAAO,CAAC,oCAAoC,EAAE,YAAY;QAC7D,OAAOF,MAAM,CAACgB,oCAAoC,CAACZ,KAAK,CAACJ,MAAM,EAAEK,SAAS,CAAC;MAC7E,CAAC,CAAC;MACF,IAAI,CAACH,OAAO,CAAC,uCAAuC,EAAE,YAAY;QAChE,OAAOF,MAAM,CAACiB,uCAAuC,CAACb,KAAK,CAACJ,MAAM,EAAEK,SAAS,CAAC;MAChF,CAAC,CAAC;MACF,IAAI,CAACH,OAAO,CAAC,qBAAqB,EAAE,YAAY;QAC9C,OAAOF,MAAM,CAACkB,qBAAqB,CAACd,KAAK,CAACJ,MAAM,EAAEK,SAAS,CAAC;MAC9D,CAAC,CAAC;MACF,IAAI,CAACH,OAAO,CAAC,gBAAgB,EAAE,YAAY;QACzC,OAAOF,MAAM,CAACmB,gBAAgB,CAACf,KAAK,CAACJ,MAAM,EAAEK,SAAS,CAAC;MACzD,CAAC,CAAC;MACF,IAAI,CAACH,OAAO,CAAC,gBAAgB,EAAE,YAAY;QACzC,OAAOF,MAAM,CAACoB,gBAAgB,CAAChB,KAAK,CAACJ,MAAM,EAAEK,SAAS,CAAC;MACzD,CAAC,CAAC;MACF,IAAI,CAACH,OAAO,CAAC,gBAAgB,EAAE,YAAY;QACzC,OAAOF,MAAM,CAACqB,gBAAgB,CAACjB,KAAK,CAACJ,MAAM,EAAEK,SAAS,CAAC;MACzD,CAAC,CAAC;MACF,IAAI,CAACH,OAAO,CAAC,gBAAgB,EAAE,YAAY;QACzC,OAAOF,MAAM,CAACsB,gBAAgB,CAAClB,KAAK,CAACJ,MAAM,EAAEK,SAAS,CAAC;MACzD,CAAC,CAAC;MACF,IAAI,CAACH,OAAO,CAAC,aAAa,EAAE,YAAY;QACtC,OAAOF,MAAM,CAACuB,aAAa,CAACnB,KAAK,CAACJ,MAAM,EAAEK,SAAS,CAAC;MACtD,CAAC,CAAC;MACF,IAAI,CAACH,OAAO,CAAC,mBAAmB,EAAE,YAAY;QAC5C,OAAOF,MAAM,CAACwB,uBAAuB,CAACpB,KAAK,CAACJ,MAAM,EAAEK,SAAS,CAAC;MAChE,CAAC,CAAC;MACF,IAAI,CAACH,OAAO,CAAC,oBAAoB,EAAE,YAAY;QAC7C,OAAOF,MAAM,CAACyB,oBAAoB,CAACrB,KAAK,CAACJ,MAAM,EAAEK,SAAS,CAAC;MAC7D,CAAC,CAAC;MACF,IAAI,CAACH,OAAO,CAAC,4BAA4B,EAAE,YAAY;QACrD,OAAOF,MAAM,CAAC0B,4BAA4B,CAACtB,KAAK,CAACJ,MAAM,EAAEK,SAAS,CAAC;MACrE,CAAC,CAAC;MAEF7D,IAAI,CAACW,eAAe,CAAC+B,UAAU,CAAC9F,SAAS,CAAC,EAAE,cAAc,EAAE,IAAI,CAAC,CAACU,IAAI,CAAC,IAAI,CAAC;IAC9E;IACA;AACJ;AACA;EAEE,CAAC,EAAE;IACDkC,GAAG,EAAE,eAAe;IACpBvB,KAAK,EAAE,SAASkH,aAAa,GAAG;MAC9B,IAAI,CAACC,gBAAgB,EAAE;MACvB,IAAI,CAAChC,GAAG,CAACiC,MAAM,EAAE;MAEjBrF,IAAI,CAACW,eAAe,CAAC+B,UAAU,CAAC9F,SAAS,CAAC,EAAE,eAAe,EAAE,IAAI,CAAC,CAACU,IAAI,CAAC,IAAI,CAAC;IAC/E;IACA;AACJ;AACA;EAEE,CAAC,EAAE;IACDkC,GAAG,EAAE,cAAc;IACnBvB,KAAK,EAAE,SAASqH,YAAY,GAAG;MAC7B,IAAIC,QAAQ,GAAG,IAAI,CAACnC,GAAG,CAACC,WAAW,EAAE,CAACC,UAAU;MAChD,IAAI,CAAC6B,aAAa,EAAE;MACpB,IAAI,CAAC5B,YAAY,EAAE;MACnB,IAAI,CAACiC,oBAAoB,CAACD,QAAQ,CAAC;MAEnCvF,IAAI,CAACW,eAAe,CAAC+B,UAAU,CAAC9F,SAAS,CAAC,EAAE,cAAc,EAAE,IAAI,CAAC,CAACU,IAAI,CAAC,IAAI,CAAC;IAC9E;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDkC,GAAG,EAAE,iBAAiB;IACtBvB,KAAK,EAAE,SAASwH,eAAe,CAACC,OAAO,EAAE;MACvC,IAAIC,KAAK,GAAG,IAAI;MAEhB,IAAI,CAACD,OAAO,EAAE;QACZ,OAAO,KAAK;MACd;MAEA,IAAI7D,gBAAgB,CAAC+D,sBAAsB,CAACF,OAAO,CAAC,EAAE;QACpDvD,IAAI,CAACN,gBAAgB,CAACgE,uBAAuB,CAACH,OAAO,CAAC,CAAC;QACvDC,KAAK,GAAG,KAAK;MACf,CAAC,MAAM,IAAI9D,gBAAgB,CAACiE,aAAa,CAACJ,OAAO,EAAE,IAAI,CAACtC,GAAG,CAAC2C,SAAS,EAAE,EAAE,IAAI,CAAC3C,GAAG,CAAC4C,SAAS,EAAE,CAAC,EAAE;QAC9F7D,IAAI,CAACN,gBAAgB,CAACoE,wBAAwB,CAACP,OAAO,CAAC,CAAC;QACxDC,KAAK,GAAG,KAAK;MACf,CAAC,MAAM,IAAI9D,gBAAgB,CAACqE,YAAY,CAACR,OAAO,CAAC,EAAE;QACjDvD,IAAI,CAACN,gBAAgB,CAACsE,cAAc,CAACT,OAAO,CAAC,CAAC;QAC9CC,KAAK,GAAG,KAAK;MACf,CAAC,MAAM,IAAI9D,gBAAgB,CAACuE,gBAAgB,CAACV,OAAO,CAAC,EAAE;QACrDvD,IAAI,CAACN,gBAAgB,CAACwE,iBAAiB,CAACX,OAAO,CAAC,CAAC;QACjDC,KAAK,GAAG,KAAK;MACf;MAEA,OAAOA,KAAK;IACd;IACA;AACJ;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDnG,GAAG,EAAE,sBAAsB;IAC3BvB,KAAK,EAAE,SAASuH,oBAAoB,CAACD,QAAQ,EAAE;MAC7C,IAAIe,MAAM,GAAG,IAAI;MAEjB,IAAIlI,KAAK,CAACC,OAAO,CAACkH,QAAQ,CAAC,EAAE;QAC3B,IAAIgB,SAAS;QAEb,IAAIC,uBAAuB,GAAG,EAAE;QAChCvE,SAAS,CAACsD,QAAQ,EAAE,UAAUG,OAAO,EAAE;UACrC,IAAI,CAACY,MAAM,CAACb,eAAe,CAACC,OAAO,CAAC,EAAE;YACpC;UACF;UAEA,IAAIe,SAAS,GAAG,IAAI/E,UAAU,CAACgE,OAAO,CAACgB,GAAG,EAAEhB,OAAO,CAACiB,GAAG,CAAC;UACxD,IAAIC,QAAQ,GAAG,IAAIlF,UAAU,CAACgE,OAAO,CAACgB,GAAG,GAAGhB,OAAO,CAACmB,OAAO,GAAG,CAAC,EAAEnB,OAAO,CAACiB,GAAG,GAAGjB,OAAO,CAACoB,OAAO,GAAG,CAAC,CAAC;UACnG,IAAIC,UAAU,GAAG,IAAIpF,SAAS,CAAC8E,SAAS,EAAEA,SAAS,EAAEG,QAAQ,CAAC;UAC9DJ,uBAAuB,CAACxI,IAAI,CAACsI,MAAM,CAACS,UAAU,CAACA,UAAU,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;QACzE,CAAC,CAAC,CAAC,CAAC;;QAEJP,uBAAuB,GAAGA,uBAAuB,CAACQ,MAAM,CAAC,UAAU/I,KAAK,EAAE;UACxE,OAAOA,KAAK,KAAK,IAAI;QACvB,CAAC,CAAC;QACF,IAAIgJ,kBAAkB,GAAG,IAAI,CAACC,qBAAqB,CAACV,uBAAuB,CAAC;QAE5E,CAACD,SAAS,GAAG,IAAI,CAACnD,GAAG,EAAE+D,iBAAiB,CAACvD,KAAK,CAAC2C,SAAS,EAAEjI,kBAAkB,CAAC2I,kBAAkB,CAAC,CAAC;MACnG;IACF;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDzH,GAAG,EAAE,uBAAuB;IAC5BvB,KAAK,EAAE,SAASiJ,qBAAqB,CAACV,uBAAuB,EAAE;MAC7D,IAAIY,UAAU;MAEd,IAAIC,mBAAmB,GAAG,IAAI,CAACC,0BAA0B,CAACd,uBAAuB,CAAC;MAElF,IAAIe,WAAW,GAAG,CAACH,UAAU,GAAG,IAAI,CAAChE,GAAG,EAAEoE,OAAO,CAAC5D,KAAK,CAACwD,UAAU,EAAE9I,kBAAkB,CAAC+I,mBAAmB,CAAC,CAAC;MAE5G,IAAII,cAAc,GAAGF,WAAW,CAACG,MAAM,CAAC,CAAC,CAAC;MAC1CzF,SAAS,CAACuE,uBAAuB,EAAE,UAAUmB,mBAAmB,EAAE;QAChE,IAAIC,oBAAoB,GAAG/K,cAAc,CAAC8K,mBAAmB,EAAE,CAAC,CAAC;UAC7DE,kBAAkB,GAAGD,oBAAoB,CAAC,CAAC,CAAC;UAC5CE,qBAAqB,GAAGF,oBAAoB,CAAC,CAAC,CAAC;UAC/CG,cAAc,GAAGH,oBAAoB,CAAC,CAAC,CAAC;QAE5C3F,SAAS,CAAC8F,cAAc,EAAE,UAAUC,aAAa,EAAEC,QAAQ,EAAE;UAC3DhG,SAAS,CAAC+F,aAAa,EAAE,UAAUE,iBAAiB,EAAEC,WAAW,EAAE;YACjEV,cAAc,CAACI,kBAAkB,GAAGR,mBAAmB,CAAC,CAAC,CAAC,GAAGY,QAAQ,CAAC,CAACH,qBAAqB,GAAGT,mBAAmB,CAAC,CAAC,CAAC,GAAGc,WAAW,CAAC,GAAGD,iBAAiB;UAC1J,CAAC,CAAC;QACJ,CAAC,CAAC;MACJ,CAAC,CAAC;MACF,OAAO,CAACb,mBAAmB,CAAC,CAAC,CAAC,EAAEA,mBAAmB,CAAC,CAAC,CAAC,EAAEI,cAAc,CAAC;IACzE;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDjI,GAAG,EAAE,4BAA4B;IACjCvB,KAAK,EAAE,SAASqJ,0BAA0B,CAACd,uBAAuB,EAAE;MAClE,IAAI4B,KAAK,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;MAClB,IAAIC,GAAG,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;MAChB,IAAIL,aAAa,GAAG,IAAI;MACxB,IAAIM,gBAAgB,GAAG,IAAI;MAC3B,IAAIP,cAAc,GAAG,IAAI;MACzB9F,SAAS,CAACuE,uBAAuB,EAAE,UAAUmB,mBAAmB,EAAE;QAChEK,aAAa,GAAGL,mBAAmB,CAAC,CAAC,CAAC;QACtCW,gBAAgB,GAAGX,mBAAmB,CAAC,CAAC,CAAC;QACzCI,cAAc,GAAGJ,mBAAmB,CAAC,CAAC,CAAC;QACvCS,KAAK,CAAC,CAAC,CAAC,GAAGG,IAAI,CAACC,GAAG,CAACR,aAAa,EAAEI,KAAK,CAAC,CAAC,CAAC,CAAC;QAC5CA,KAAK,CAAC,CAAC,CAAC,GAAGG,IAAI,CAACC,GAAG,CAACF,gBAAgB,EAAEF,KAAK,CAAC,CAAC,CAAC,CAAC;QAC/CC,GAAG,CAAC,CAAC,CAAC,GAAGE,IAAI,CAACE,GAAG,CAACT,aAAa,GAAGD,cAAc,CAAC7J,MAAM,GAAG,CAAC,EAAEmK,GAAG,CAAC,CAAC,CAAC,CAAC;QACpEA,GAAG,CAAC,CAAC,CAAC,GAAGE,IAAI,CAACE,GAAG,CAACH,gBAAgB,GAAGP,cAAc,CAAC,CAAC,CAAC,CAAC7J,MAAM,GAAG,CAAC,EAAEmK,GAAG,CAAC,CAAC,CAAC,CAAC;MAC5E,CAAC,CAAC;MACF,OAAO,EAAE,CAACK,MAAM,CAACN,KAAK,EAAEC,GAAG,CAAC;IAC9B;IACA;AACJ;AACA;EAEE,CAAC,EAAE;IACD7I,GAAG,EAAE,kBAAkB;IACvBvB,KAAK,EAAE,SAASmH,gBAAgB,GAAG;MACjC,IAAI,CAACpC,qBAAqB,CAAC2F,KAAK,EAAE;IACpC;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDnJ,GAAG,EAAE,eAAe;IACpBvB,KAAK,EAAE,SAAS2K,aAAa,CAACC,iBAAiB,EAAE;MAC/C,IAAIC,IAAI,GAAGjF,SAAS,CAAC3F,MAAM,GAAG,CAAC,IAAI2F,SAAS,CAAC,CAAC,CAAC,KAAKlG,SAAS,GAAGkG,SAAS,CAAC,CAAC,CAAC,GAAG,KAAK;MACpF,OAAOiF,IAAI,GAAG,IAAI,GAAG,IAAI,CAACrD,eAAe,CAACoD,iBAAiB,CAAC;IAC9D;IACA;AACJ;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDrJ,GAAG,EAAE,wBAAwB;IAC7BvB,KAAK,EAAE,SAAS8K,sBAAsB,GAAG;MACvC,IAAIC,YAAY,GAAG,IAAI,CAAC5F,GAAG,CAAC6F,oBAAoB,EAAE;MAElD,IAAI,CAACD,YAAY,EAAE;QACjB;MACF;MAEAA,YAAY,CAACE,YAAY,CAAC,OAAO,CAAC;MAClC,IAAIvK,IAAI,GAAGqK,YAAY,CAACrK,IAAI;QACxBwK,EAAE,GAAGH,YAAY,CAACG,EAAE;MACxB,IAAI,CAACC,WAAW,CAACJ,YAAY,CAAC;MAC9B,IAAI,CAAC5F,GAAG,CAACiG,UAAU,CAAC1K,IAAI,CAAC+H,GAAG,EAAE/H,IAAI,CAACgI,GAAG,EAAEwC,EAAE,CAACzC,GAAG,EAAEyC,EAAE,CAACxC,GAAG,EAAE,KAAK,CAAC;IAChE;IACA;AACJ;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDnH,GAAG,EAAE,gBAAgB;IACrBvB,KAAK,EAAE,SAASqL,cAAc,GAAG;MAC/B,IAAIC,SAAS,GAAG1F,SAAS,CAAC3F,MAAM,GAAG,CAAC,IAAI2F,SAAS,CAAC,CAAC,CAAC,KAAKlG,SAAS,GAAGkG,SAAS,CAAC,CAAC,CAAC,GAAG,IAAI,CAACT,GAAG,CAAC6F,oBAAoB,EAAE;MAEnH,IAAI,CAACM,SAAS,EAAE;QACd;MACF;MAEAA,SAAS,CAACL,YAAY,CAAC,OAAO,CAAC;MAC/B,IAAIvK,IAAI,GAAG4K,SAAS,CAAC5K,IAAI;QACrBwK,EAAE,GAAGI,SAAS,CAACJ,EAAE;MACrB,IAAI,CAACK,YAAY,CAACD,SAAS,EAAE,IAAI,CAAC;MAClC,IAAI,CAACxC,UAAU,CAACwC,SAAS,CAAC;MAC1B,IAAI,CAACnG,GAAG,CAACiG,UAAU,CAAC1K,IAAI,CAAC+H,GAAG,EAAE/H,IAAI,CAACgI,GAAG,EAAEwC,EAAE,CAACzC,GAAG,EAAEyC,EAAE,CAACxC,GAAG,EAAE,KAAK,CAAC;IAChE;IACA;AACJ;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDnH,GAAG,EAAE,kBAAkB;IACvBvB,KAAK,EAAE,SAASwL,gBAAgB,GAAG;MACjC,IAAIF,SAAS,GAAG1F,SAAS,CAAC3F,MAAM,GAAG,CAAC,IAAI2F,SAAS,CAAC,CAAC,CAAC,KAAKlG,SAAS,GAAGkG,SAAS,CAAC,CAAC,CAAC,GAAG,IAAI,CAACT,GAAG,CAAC6F,oBAAoB,EAAE;MAEnH,IAAI,CAACM,SAAS,EAAE;QACd;MACF;MAEA,IAAI5K,IAAI,GAAG4K,SAAS,CAAC5K,IAAI;QACrBwK,EAAE,GAAGI,SAAS,CAACJ,EAAE;MACrB,IAAI,CAACK,YAAY,CAACD,SAAS,EAAE,IAAI,CAAC;MAClC,IAAI,CAACnG,GAAG,CAACiG,UAAU,CAAC1K,IAAI,CAAC+H,GAAG,EAAE/H,IAAI,CAACgI,GAAG,EAAEwC,EAAE,CAACzC,GAAG,EAAEyC,EAAE,CAACxC,GAAG,EAAE,KAAK,CAAC;IAChE;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDnH,GAAG,EAAE,YAAY;IACjBvB,KAAK,EAAE,SAAS8I,UAAU,CAACwC,SAAS,EAAE;MACpC,IAAIG,MAAM,GAAG,IAAI;MAEjB,IAAIZ,IAAI,GAAGjF,SAAS,CAAC3F,MAAM,GAAG,CAAC,IAAI2F,SAAS,CAAC,CAAC,CAAC,KAAKlG,SAAS,GAAGkG,SAAS,CAAC,CAAC,CAAC,GAAG,KAAK;MACpF,IAAI8F,iBAAiB,GAAG9F,SAAS,CAAC3F,MAAM,GAAG,CAAC,IAAI2F,SAAS,CAAC,CAAC,CAAC,KAAKlG,SAAS,GAAGkG,SAAS,CAAC,CAAC,CAAC,GAAG,KAAK;MACjG,IAAI+F,OAAO,GAAGL,SAAS,CAACM,gBAAgB,EAAE;MAC1C,IAAIC,WAAW,GAAGP,SAAS,CAACQ,oBAAoB,EAAE;MAClD,IAAIC,WAAW,GAAG;QAChBtD,GAAG,EAAEkD,OAAO,CAAClD,GAAG;QAChBC,GAAG,EAAEiD,OAAO,CAACjD,GAAG;QAChBE,OAAO,EAAEiD,WAAW,CAACpD,GAAG,GAAGkD,OAAO,CAAClD,GAAG,GAAG,CAAC;QAC1CI,OAAO,EAAEgD,WAAW,CAACnD,GAAG,GAAGiD,OAAO,CAACjD,GAAG,GAAG;MAC3C,CAAC;MACD,IAAIsD,WAAW,GAAG,EAAE;MACpB,IAAIC,cAAc,GAAG,IAAI;MAEzB,IAAI,CAAC,IAAI,CAACtB,aAAa,CAACoB,WAAW,EAAElB,IAAI,CAAC,EAAE;QAC1C,OAAO,KAAK;MACd;MAEA,IAAI,CAAC1F,GAAG,CAAC+G,QAAQ,CAAC,kBAAkB,EAAEZ,SAAS,EAAET,IAAI,CAAC;MACtD1G,SAAS,CAAC,CAAC,EAAE4H,WAAW,CAACnD,OAAO,GAAG,CAAC,EAAE,UAAU9J,CAAC,EAAE;QACjDqF,SAAS,CAAC,CAAC,EAAE4H,WAAW,CAAClD,OAAO,GAAG,CAAC,EAAE,UAAUsD,CAAC,EAAE;UACjD,IAAIC,YAAY,GAAG,IAAI;UAEvB,IAAI,CAACJ,WAAW,CAAClN,CAAC,CAAC,EAAE;YACnBkN,WAAW,CAAClN,CAAC,CAAC,GAAG,EAAE;UACrB;UAEA,IAAIA,CAAC,KAAK,CAAC,IAAIqN,CAAC,KAAK,CAAC,EAAE;YACtBC,YAAY,GAAGX,MAAM,CAACtG,GAAG,CAACkH,aAAa,CAACN,WAAW,CAACtD,GAAG,EAAEsD,WAAW,CAACrD,GAAG,CAAC;UAC3E,CAAC,MAAM;YACL+C,MAAM,CAACtG,GAAG,CAACmH,WAAW,CAACP,WAAW,CAACtD,GAAG,GAAG3J,CAAC,EAAEiN,WAAW,CAACrD,GAAG,GAAGyD,CAAC,EAAE,QAAQ,EAAE,IAAI,CAAC;UAClF;UAEAH,WAAW,CAAClN,CAAC,CAAC,CAACqN,CAAC,CAAC,GAAGC,YAAY;QAClC,CAAC,CAAC;MACJ,CAAC,CAAC;MACF,IAAI,CAACjH,GAAG,CAACmH,WAAW,CAACP,WAAW,CAACtD,GAAG,EAAEsD,WAAW,CAACrD,GAAG,EAAE,SAAS,EAAE,IAAI,CAAC;MACvE,IAAI6D,eAAe,GAAG,IAAI,CAACxH,qBAAqB,CAACyH,GAAG,CAACT,WAAW,CAAC;MAEjE,IAAIQ,eAAe,EAAE;QACnB,IAAIb,iBAAiB,EAAE;UACrBO,cAAc,GAAG,CAACF,WAAW,CAACtD,GAAG,EAAEsD,WAAW,CAACrD,GAAG,EAAEsD,WAAW,CAAC;QAClE,CAAC,MAAM;UACL,IAAI,CAAC7G,GAAG,CAAC+D,iBAAiB,CAAC6C,WAAW,CAACtD,GAAG,EAAEsD,WAAW,CAACrD,GAAG,EAAEsD,WAAW,EAAE,KAAK,CAAC,EAAE,KAAK,CAAC,EAAE,IAAI,CAACS,UAAU,CAAC;QAC5G;QAEA,IAAI,CAACtH,GAAG,CAAC+G,QAAQ,CAAC,iBAAiB,EAAEZ,SAAS,EAAES,WAAW,EAAElB,IAAI,CAAC;QAClE,OAAOoB,cAAc;MACvB;MAEA,OAAO,IAAI;IACb;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACD1K,GAAG,EAAE,cAAc;IACnBvB,KAAK,EAAE,SAASuL,YAAY,CAACD,SAAS,EAAE;MACtC,IAAIoB,MAAM,GAAG,IAAI;MAEjB,IAAI7B,IAAI,GAAGjF,SAAS,CAAC3F,MAAM,GAAG,CAAC,IAAI2F,SAAS,CAAC,CAAC,CAAC,KAAKlG,SAAS,GAAGkG,SAAS,CAAC,CAAC,CAAC,GAAG,KAAK;MACpF,IAAI+G,WAAW,GAAG,IAAI,CAAC5H,qBAAqB,CAAC6H,cAAc,CAACtB,SAAS,CAAC;MAEtE,IAAI,CAACqB,WAAW,EAAE;QAChB;MACF;MAEA,IAAI,CAACxH,GAAG,CAAC+G,QAAQ,CAAC,oBAAoB,EAAEZ,SAAS,EAAET,IAAI,CAAC;MACxD7G,SAAS,CAAC2I,WAAW,EAAE,UAAUE,iBAAiB,EAAE;QAClDH,MAAM,CAAC3H,qBAAqB,CAAC+H,MAAM,CAACD,iBAAiB,CAACpE,GAAG,EAAEoE,iBAAiB,CAACnE,GAAG,CAAC;QAEjFvE,SAAS,CAAC,CAAC,EAAE0I,iBAAiB,CAACjE,OAAO,GAAG,CAAC,EAAE,UAAU9J,CAAC,EAAE;UACvDqF,SAAS,CAAC,CAAC,EAAE0I,iBAAiB,CAAChE,OAAO,GAAG,CAAC,EAAE,UAAUsD,CAAC,EAAE;YACvDO,MAAM,CAACvH,GAAG,CAAC4H,cAAc,CAACF,iBAAiB,CAACpE,GAAG,GAAG3J,CAAC,EAAE+N,iBAAiB,CAACnE,GAAG,GAAGyD,CAAC,EAAE,QAAQ,CAAC;UAC3F,CAAC,CAAC;QACJ,CAAC,CAAC;QAEFO,MAAM,CAACvH,GAAG,CAAC4H,cAAc,CAACF,iBAAiB,CAACpE,GAAG,EAAEoE,iBAAiB,CAACnE,GAAG,EAAE,SAAS,CAAC;MACpF,CAAC,CAAC;MACF,IAAI,CAACvD,GAAG,CAACiC,MAAM,EAAE;MACjB,IAAI,CAACjC,GAAG,CAAC+G,QAAQ,CAAC,mBAAmB,EAAEZ,SAAS,EAAET,IAAI,CAAC;IACzD;IACA;AACJ;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDtJ,GAAG,EAAE,aAAa;IAClBvB,KAAK,EAAE,SAASmL,WAAW,CAACG,SAAS,EAAE;MACrC,IAAI0B,UAAU,GAAG,IAAI,CAACjI,qBAAqB,CAAC5C,GAAG,CAACmJ,SAAS,CAAC5K,IAAI,CAAC+H,GAAG,EAAE6C,SAAS,CAAC5K,IAAI,CAACgI,GAAG,CAAC;MACvF,IAAIuE,0BAA0B,GAAGD,UAAU,CAACvE,GAAG,KAAK6C,SAAS,CAAC5K,IAAI,CAAC+H,GAAG,IAAIuE,UAAU,CAACtE,GAAG,KAAK4C,SAAS,CAAC5K,IAAI,CAACgI,GAAG,IAAIsE,UAAU,CAACvE,GAAG,GAAGuE,UAAU,CAACpE,OAAO,GAAG,CAAC,KAAK0C,SAAS,CAACJ,EAAE,CAACzC,GAAG,IAAIuE,UAAU,CAACtE,GAAG,GAAGsE,UAAU,CAACnE,OAAO,GAAG,CAAC,KAAKyC,SAAS,CAACJ,EAAE,CAACxC,GAAG;MAE/O,IAAIuE,0BAA0B,EAAE;QAC9B,IAAI,CAAC1B,YAAY,CAACD,SAAS,CAAC;MAC9B,CAAC,MAAM;QACL,IAAI,CAACD,cAAc,CAACC,SAAS,CAAC;MAChC;IACF;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACD/J,GAAG,EAAE,OAAO;IACZvB,KAAK,EAAE,SAASkN,KAAK,CAACC,QAAQ,EAAEC,WAAW,EAAEC,MAAM,EAAEC,SAAS,EAAE;MAC9D,IAAInD,KAAK,GAAG,IAAI1G,UAAU,CAAC0J,QAAQ,EAAEC,WAAW,CAAC;MACjD,IAAIhD,GAAG,GAAG,IAAI3G,UAAU,CAAC4J,MAAM,EAAEC,SAAS,CAAC;MAC3C,IAAI,CAACxE,UAAU,CAAC,IAAIpF,SAAS,CAACyG,KAAK,EAAEA,KAAK,EAAEC,GAAG,CAAC,CAAC;IACnD;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACD7I,GAAG,EAAE,SAAS;IACdvB,KAAK,EAAE,SAASuN,OAAO,CAACJ,QAAQ,EAAEC,WAAW,EAAEC,MAAM,EAAEC,SAAS,EAAE;MAChE,IAAInD,KAAK,GAAG,IAAI1G,UAAU,CAAC0J,QAAQ,EAAEC,WAAW,CAAC;MACjD,IAAIhD,GAAG,GAAG,IAAI3G,UAAU,CAAC4J,MAAM,EAAEC,SAAS,CAAC;MAC3C,IAAI,CAAC/B,YAAY,CAAC,IAAI7H,SAAS,CAACyG,KAAK,EAAEA,KAAK,EAAEC,GAAG,CAAC,CAAC;IACrD;IACA;AACJ;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACD7I,GAAG,EAAE,aAAa;IAClBvB,KAAK,EAAE,SAAS0F,WAAW,GAAG;MAC5B,IAAI,CAAC6B,oBAAoB,CAAC,IAAI,CAACpC,GAAG,CAACC,WAAW,EAAE,CAACC,UAAU,CAAC;MAC5D,IAAI,CAACF,GAAG,CAACiC,MAAM,EAAE;IACnB;IACA;AACJ;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACD7F,GAAG,EAAE,iBAAiB;IACtBvB,KAAK,EAAE,SAAS6F,eAAe,CAAC2H,KAAK,EAAE;MACrC,IAAIC,QAAQ,GAAG,CAACD,KAAK,CAACE,OAAO,IAAIF,KAAK,CAACG,OAAO,KAAK,CAACH,KAAK,CAACI,MAAM;MAEhE,IAAIH,QAAQ,IAAID,KAAK,CAACK,OAAO,KAAK,EAAE,EAAE;QACpC;QACA,IAAI,CAAC1C,WAAW,CAAC,IAAI,CAAChG,GAAG,CAAC6F,oBAAoB,EAAE,CAAC;QACjD,IAAI,CAAC7F,GAAG,CAACiC,MAAM,EAAE;QACjB5D,wBAAwB,CAACgK,KAAK,CAAC;MACjC;IACF;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDjM,GAAG,EAAE,4BAA4B;IACjCvB,KAAK,EAAE,SAASmG,0BAA0B,CAAC2H,UAAU,EAAE;MACrD,IAAIA,UAAU,EAAE;QACd,IAAInB,WAAW,GAAG,IAAI,CAAC5H,qBAAqB,CAAC4H,WAAW;QACxD,IAAIoB,cAAc,GAAG,IAAI,CAAC5I,GAAG,CAAC6F,oBAAoB,EAAE;QAEpD,KAAK,IAAIgD,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGrB,WAAW,CAAC1M,MAAM,EAAE+N,KAAK,IAAI,CAAC,EAAE;UAC1D,IAAID,cAAc,CAACvF,SAAS,CAACC,GAAG,KAAKkE,WAAW,CAACqB,KAAK,CAAC,CAACvF,GAAG,IAAIsF,cAAc,CAACvF,SAAS,CAACE,GAAG,KAAKiE,WAAW,CAACqB,KAAK,CAAC,CAACtF,GAAG,IAAIqF,cAAc,CAAC7C,EAAE,CAACzC,GAAG,KAAKkE,WAAW,CAACqB,KAAK,CAAC,CAACvF,GAAG,GAAGkE,WAAW,CAACqB,KAAK,CAAC,CAACpF,OAAO,GAAG,CAAC,IAAImF,cAAc,CAAC7C,EAAE,CAACxC,GAAG,KAAKiE,WAAW,CAACqB,KAAK,CAAC,CAACtF,GAAG,GAAGiE,WAAW,CAACqB,KAAK,CAAC,CAACnF,OAAO,GAAG,CAAC,EAAE;YAChS,OAAO,KAAK;UACd;QACF;MACF;MAEA,OAAOiF,UAAU;IACnB;IACA;AACJ;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDvM,GAAG,EAAE,wBAAwB;IAC7BvB,KAAK,EAAE,SAAS8F,sBAAsB,CAACmI,KAAK,EAAE;MAC5C,IAAIC,IAAI,GAAG3J,WAAW,CAACpC,GAAG,CAAC,IAAI,CAAC;MAChC,IAAIgM,sBAAsB,GAAG,IAAI,CAAChJ,GAAG,CAAC6F,oBAAoB,EAAE;MAC5D,IAAIoD,QAAQ,GAAG;QACb3F,GAAG,EAAEwF,KAAK,CAACxF,GAAG;QACdC,GAAG,EAAEuF,KAAK,CAACvF;MACb,CAAC;MACD,IAAI2F,YAAY,GAAG,IAAI;MACvB,IAAIC,eAAe,GAAG,IAAI7K,UAAU,CAAC0K,sBAAsB,CAAC3F,SAAS,CAACC,GAAG,EAAE0F,sBAAsB,CAAC3F,SAAS,CAACE,GAAG,CAAC;MAChH,IAAI6F,YAAY,GAAG,IAAI,CAACxJ,qBAAqB,CAAC5C,GAAG,CAACmM,eAAe,CAAC7F,GAAG,EAAE6F,eAAe,CAAC5F,GAAG,CAAC;MAE3F,IAAI,CAACwF,IAAI,CAACpJ,iBAAiB,EAAE;QAC3BoJ,IAAI,CAACpJ,iBAAiB,GAAG,IAAIrB,UAAU,CAAC,IAAI,EAAE,IAAI,CAAC;MACrD;MAEA,IAAI8K,YAAY,EAAE;QAChB;QACA,IAAIC,YAAY,GAAG,IAAI/K,UAAU,CAAC8K,YAAY,CAAC9F,GAAG,EAAE8F,YAAY,CAAC7F,GAAG,CAAC;QACrE,IAAI+F,gBAAgB,GAAG,IAAIhL,UAAU,CAAC8K,YAAY,CAAC9F,GAAG,GAAG8F,YAAY,CAAC3F,OAAO,GAAG,CAAC,EAAE2F,YAAY,CAAC7F,GAAG,GAAG6F,YAAY,CAAC1F,OAAO,GAAG,CAAC,CAAC;QAC/H,IAAIC,UAAU,GAAG,IAAIpF,SAAS,CAAC8K,YAAY,EAAEA,YAAY,EAAEC,gBAAgB,CAAC;QAE5E,IAAI,CAAC3F,UAAU,CAAC4F,QAAQ,CAACR,IAAI,CAACpJ,iBAAiB,CAAC,EAAE;UAChDoJ,IAAI,CAACpJ,iBAAiB,GAAG,IAAIrB,UAAU,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC;QACvD;;QAEA2K,QAAQ,CAAC3F,GAAG,GAAGyF,IAAI,CAACpJ,iBAAiB,CAAC2D,GAAG,GAAGyF,IAAI,CAACpJ,iBAAiB,CAAC2D,GAAG,GAAG6F,eAAe,CAAC7F,GAAG,GAAG2F,QAAQ,CAAC3F,GAAG;QAC3G2F,QAAQ,CAAC1F,GAAG,GAAGwF,IAAI,CAACpJ,iBAAiB,CAAC4D,GAAG,GAAGwF,IAAI,CAACpJ,iBAAiB,CAAC4D,GAAG,GAAG4F,eAAe,CAAC5F,GAAG,GAAG0F,QAAQ,CAAC1F,GAAG;QAE3G,IAAIuF,KAAK,CAACxF,GAAG,GAAG,CAAC,EAAE;UACjB;UACA2F,QAAQ,CAAC3F,GAAG,GAAG8F,YAAY,CAAC9F,GAAG,GAAG8F,YAAY,CAAC3F,OAAO,GAAG,CAAC,GAAG0F,eAAe,CAAC7F,GAAG,GAAGwF,KAAK,CAACxF,GAAG;QAC9F,CAAC,MAAM,IAAIwF,KAAK,CAACxF,GAAG,GAAG,CAAC,EAAE;UACxB;UACA2F,QAAQ,CAAC3F,GAAG,GAAG6F,eAAe,CAAC7F,GAAG,GAAG8F,YAAY,CAAC9F,GAAG,GAAGwF,KAAK,CAACxF,GAAG;QACnE;QAEA,IAAIwF,KAAK,CAACvF,GAAG,GAAG,CAAC,EAAE;UACjB;UACA0F,QAAQ,CAAC1F,GAAG,GAAG6F,YAAY,CAAC7F,GAAG,GAAG6F,YAAY,CAAC1F,OAAO,GAAG,CAAC,GAAGyF,eAAe,CAAC5F,GAAG,GAAGuF,KAAK,CAACvF,GAAG;QAC9F,CAAC,MAAM,IAAIuF,KAAK,CAACvF,GAAG,GAAG,CAAC,EAAE;UACxB;UACA0F,QAAQ,CAAC1F,GAAG,GAAG4F,eAAe,CAAC5F,GAAG,GAAG6F,YAAY,CAAC7F,GAAG,GAAGuF,KAAK,CAACvF,GAAG;QACnE;MACF;MAEA2F,YAAY,GAAG,IAAI5K,UAAU,CAAC0K,sBAAsB,CAAC3F,SAAS,CAACC,GAAG,GAAG2F,QAAQ,CAAC3F,GAAG,EAAE0F,sBAAsB,CAAC3F,SAAS,CAACE,GAAG,GAAG0F,QAAQ,CAAC1F,GAAG,CAAC;MACvI,IAAIiG,kBAAkB,GAAG,IAAI,CAAC5J,qBAAqB,CAAC5C,GAAG,CAACkM,YAAY,CAAC5F,GAAG,EAAE4F,YAAY,CAAC3F,GAAG,CAAC;MAE3F,IAAIiG,kBAAkB,EAAE;QACtB;QACAT,IAAI,CAACpJ,iBAAiB,GAAGuJ,YAAY;QACrCD,QAAQ,GAAG;UACT3F,GAAG,EAAEkG,kBAAkB,CAAClG,GAAG,GAAG6F,eAAe,CAAC7F,GAAG;UACjDC,GAAG,EAAEiG,kBAAkB,CAACjG,GAAG,GAAG4F,eAAe,CAAC5F;QAChD,CAAC;MACH;MAEA,IAAI0F,QAAQ,CAAC3F,GAAG,KAAK,CAAC,EAAE;QACtBwF,KAAK,CAACxF,GAAG,GAAG2F,QAAQ,CAAC3F,GAAG;MAC1B;MAEA,IAAI2F,QAAQ,CAAC1F,GAAG,KAAK,CAAC,EAAE;QACtBuF,KAAK,CAACvF,GAAG,GAAG0F,QAAQ,CAAC1F,GAAG;MAC1B;IACF;IACA;AACJ;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDnH,GAAG,EAAE,sBAAsB;IAC3BvB,KAAK,EAAE,SAASgG,oBAAoB,CAACiI,KAAK,EAAE;MAC1C,IAAIW,MAAM,GAAG,IAAI;MAEjB,IAAIC,qBAAqB,GAAG,IAAI,CAAC1J,GAAG,CAAC6F,oBAAoB,EAAE;MAC3D,IAAIoD,QAAQ,GAAGnK,KAAK,CAACgK,KAAK,CAAC;MAC3B,IAAIa,iBAAiB,GAAG,IAAI,CAAC7J,qBAAqB,CAAC8J,wBAAwB,CAACF,qBAAqB,EAAEZ,KAAK,CAAC;MACzG,IAAIe,SAAS,GAAG/K,KAAK,CAACmK,QAAQ,CAAC;MAC/B,IAAIa,sBAAsB,GAAG,IAAI,CAAClK,qBAAqB,CAAC6H,cAAc,CAACkC,iBAAiB,EAAE,IAAI,CAAC;MAE/F,GAAG;QACDE,SAAS,GAAG/K,KAAK,CAACmK,QAAQ,CAAC;QAC3B,IAAI,CAACnJ,qBAAqB,CAAC8J,wBAAwB,CAACF,qBAAqB,EAAET,QAAQ,CAAC;QACpFpK,SAAS,CAACiL,sBAAsB,EAAE,UAAUjC,UAAU,EAAE;UACtD4B,MAAM,CAAC3J,qBAAqB,CAACiK,SAAS,CAACd,QAAQ,EAAES,qBAAqB,EAAE7B,UAAU,CAAC;QACrF,CAAC,CAAC;MACJ,CAAC,QAAQoB,QAAQ,CAAC3F,GAAG,KAAKuG,SAAS,CAACvG,GAAG,IAAI2F,QAAQ,CAAC1F,GAAG,KAAKsG,SAAS,CAACtG,GAAG;MAEzEuF,KAAK,CAACxF,GAAG,GAAG2F,QAAQ,CAAC3F,GAAG;MACxBwF,KAAK,CAACvF,GAAG,GAAG0F,QAAQ,CAAC1F,GAAG;IAC1B;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDnH,GAAG,EAAE,uBAAuB;IAC5BvB,KAAK,EAAE,SAASiG,qBAAqB,CAACwC,GAAG,EAAE0G,MAAM,EAAE;MACjD,IAAIpD,WAAW,GAAG,IAAI,CAAChH,qBAAqB,CAAC5C,GAAG,CAACsG,GAAG,EAAE0G,MAAM,CAAC;MAC7D,OAAOpD,WAAW,GAAG,CAACA,WAAW,CAACtD,GAAG,EAAEsD,WAAW,CAACrD,GAAG,EAAEqD,WAAW,CAACtD,GAAG,GAAGsD,WAAW,CAACnD,OAAO,GAAG,CAAC,EAAEmD,WAAW,CAACrD,GAAG,GAAGqD,WAAW,CAAClD,OAAO,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC;IACxJ;IACA;AACJ;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDtH,GAAG,EAAE,8BAA8B;IACnCvB,KAAK,EAAE,SAASqG,4BAA4B,CAAC+I,cAAc,EAAE;MAC3DA,cAAc,CAACC,KAAK,CAACtP,IAAI,CAAC;QACxBuP,IAAI,EAAE;MACR,CAAC,EAAEvL,eAAe,CAAC,IAAI,CAAC,CAAC;IAC3B;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDxC,GAAG,EAAE,iBAAiB;IACtBvB,KAAK,EAAE,SAASoG,eAAe,CAACmJ,EAAE,EAAE9G,GAAG,EAAEC,GAAG,EAAE;MAC5C,IAAIsE,UAAU,GAAG,IAAI,CAACjI,qBAAqB,CAAC5C,GAAG,CAACsG,GAAG,EAAEC,GAAG,CAAC;MACzDtE,mBAAmB,CAACmL,EAAE,EAAEvC,UAAU,EAAEvE,GAAG,EAAEC,GAAG,CAAC;IAC/C;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDnH,GAAG,EAAE,qBAAqB;IAC1BvB,KAAK,EAAE,SAASkG,mBAAmB,CAACsJ,MAAM,EAAE;MAC1C,IAAIC,QAAQ,GAAG,IAAI,CAACtK,GAAG,CAAC6F,oBAAoB,EAAE;MAC9CyE,QAAQ,CAACjH,SAAS,GAAG,IAAI/E,UAAU,CAACgM,QAAQ,CAACjH,SAAS,CAACC,GAAG,EAAEgH,QAAQ,CAACjH,SAAS,CAACE,GAAG,CAAC,CAAC,CAAC;;MAErF+G,QAAQ,CAACvE,EAAE,GAAGsE,MAAM;MACpB,IAAIE,aAAa,GAAG,KAAK;MAEzB,IAAI,IAAI,CAACvK,GAAG,CAACwK,SAAS,CAACC,wBAAwB,EAAE,IAAI,IAAI,CAACzK,GAAG,CAACwK,SAAS,CAACE,qBAAqB,EAAE,EAAE;QAC/F;MACF;MAEA,GAAG;QACDH,aAAa,GAAG,KAAK;QAErB,KAAK,IAAI5Q,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACiG,qBAAqB,CAAC4H,WAAW,CAAC1M,MAAM,EAAEnB,CAAC,IAAI,CAAC,EAAE;UACzE,IAAIgR,QAAQ,GAAG,IAAI,CAAC/K,qBAAqB,CAAC4H,WAAW,CAAC7N,CAAC,CAAC;UACxD,IAAIiR,eAAe,GAAGD,QAAQ,CAACE,QAAQ,EAAE;UAEzC,IAAIP,QAAQ,CAACQ,aAAa,CAACF,eAAe,CAAC,EAAE;YAC3CP,MAAM,CAAC/G,GAAG,GAAGgH,QAAQ,CAACvE,EAAE,CAACzC,GAAG;YAC5B+G,MAAM,CAAC9G,GAAG,GAAG+G,QAAQ,CAACvE,EAAE,CAACxC,GAAG;YAC5BgH,aAAa,GAAG,IAAI;UACtB;QACF;MACF,CAAC,QAAQA,aAAa;IACxB;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDnO,GAAG,EAAE,oBAAoB;IACzBvB,KAAK,EAAE,SAASsG,kBAAkB,CAACmC,GAAG,EAAEC,GAAG,EAAEwH,cAAc,EAAE;MAC3D,IAAInE,WAAW,GAAG,IAAI,CAAChH,qBAAqB,CAAC5C,GAAG,CAACsG,GAAG,EAAEC,GAAG,CAAC;MAE1D,IAAIqD,WAAW,EAAE;QACf,IAAIA,WAAW,CAACtD,GAAG,KAAKA,GAAG,IAAIsD,WAAW,CAACrD,GAAG,KAAKA,GAAG,EAAE;UACtDwH,cAAc,CAACC,QAAQ,GAAG,KAAK;QACjC,CAAC,MAAM;UACLD,cAAc,CAACtH,OAAO,GAAGmD,WAAW,CAACnD,OAAO;UAC5CsH,cAAc,CAACrH,OAAO,GAAGkD,WAAW,CAAClD,OAAO;QAC9C;MACF;IACF;IACA;AACJ;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDtH,GAAG,EAAE,sCAAsC;IAC3CvB,KAAK,EAAE,SAASuG,oCAAoC,CAAC6J,IAAI,EAAE;MACzD,IAAIC,MAAM,GAAG,IAAI;MAEjB,IAAIC,QAAQ,GAAG,IAAI,CAACnL,GAAG,CAAC4C,SAAS,EAAE;MACnC,IAAIgE,WAAW;MACf5H,SAAS,CAAC,CAAC,EAAEmM,QAAQ,GAAG,CAAC,EAAE,UAAUC,CAAC,EAAE;QACtCxE,WAAW,GAAGsE,MAAM,CAACtL,qBAAqB,CAAC5C,GAAG,CAACiO,IAAI,CAACjD,QAAQ,EAAEoD,CAAC,CAAC;QAEhE,IAAIxE,WAAW,EAAE;UACf,IAAIA,WAAW,CAACtD,GAAG,GAAG2H,IAAI,CAACjD,QAAQ,EAAE;YACnCiD,IAAI,CAACjD,QAAQ,GAAGpB,WAAW,CAACtD,GAAG;YAC/B,OAAO4H,MAAM,CAAC9J,oCAAoC,CAAClH,IAAI,CAACgR,MAAM,EAAED,IAAI,CAAC,CAAC,CAAC;UACzE;QACF;;QAEArE,WAAW,GAAGsE,MAAM,CAACtL,qBAAqB,CAAC5C,GAAG,CAACiO,IAAI,CAAC/C,MAAM,EAAEkD,CAAC,CAAC;QAE9D,IAAIxE,WAAW,EAAE;UACf,IAAIyE,QAAQ,GAAGzE,WAAW,CAACtD,GAAG,GAAGsD,WAAW,CAACnD,OAAO,GAAG,CAAC;UAExD,IAAI4H,QAAQ,GAAGJ,IAAI,CAAC/C,MAAM,EAAE;YAC1B+C,IAAI,CAAC/C,MAAM,GAAGmD,QAAQ;YACtB,OAAOH,MAAM,CAAC9J,oCAAoC,CAAClH,IAAI,CAACgR,MAAM,EAAED,IAAI,CAAC,CAAC,CAAC;UACzE;QACF;;QAEA,OAAO,IAAI;MACb,CAAC,CAAC;IACJ;IACA;AACJ;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACD7O,GAAG,EAAE,yCAAyC;IAC9CvB,KAAK,EAAE,SAASwG,uCAAuC,CAAC4J,IAAI,EAAE;MAC5D,IAAIK,MAAM,GAAG,IAAI;MAEjB,IAAIC,QAAQ,GAAG,IAAI,CAACvL,GAAG,CAAC2C,SAAS,EAAE;MACnC,IAAIiE,WAAW;MACf5H,SAAS,CAAC,CAAC,EAAEuM,QAAQ,GAAG,CAAC,EAAE,UAAUC,CAAC,EAAE;QACtC5E,WAAW,GAAG0E,MAAM,CAAC1L,qBAAqB,CAAC5C,GAAG,CAACwO,CAAC,EAAEP,IAAI,CAAChD,WAAW,CAAC;QAEnE,IAAIrB,WAAW,IAAIA,WAAW,CAACrD,GAAG,GAAG0H,IAAI,CAAChD,WAAW,EAAE;UACrDgD,IAAI,CAAChD,WAAW,GAAGrB,WAAW,CAACrD,GAAG;UAClC,OAAO+H,MAAM,CAACjK,uCAAuC,CAACnH,IAAI,CAACoR,MAAM,EAAEL,IAAI,CAAC,CAAC,CAAC;QAC5E;;QAEArE,WAAW,GAAG0E,MAAM,CAAC1L,qBAAqB,CAAC5C,GAAG,CAACwO,CAAC,EAAEP,IAAI,CAAC9C,SAAS,CAAC;QAEjE,IAAIvB,WAAW,EAAE;UACf,IAAIyE,QAAQ,GAAGzE,WAAW,CAACrD,GAAG,GAAGqD,WAAW,CAAClD,OAAO,GAAG,CAAC;UAExD,IAAI2H,QAAQ,GAAGJ,IAAI,CAAC9C,SAAS,EAAE;YAC7B8C,IAAI,CAAC9C,SAAS,GAAGkD,QAAQ;YACzB,OAAOC,MAAM,CAACjK,uCAAuC,CAACnH,IAAI,CAACoR,MAAM,EAAEL,IAAI,CAAC,CAAC,CAAC;UAC5E;QACF;;QAEA,OAAO,IAAI;MACb,CAAC,CAAC;IACJ;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACD7O,GAAG,EAAE,uBAAuB;IAC5BvB,KAAK,EAAE,SAASyG,qBAAqB,CAACmK,IAAI,EAAEC,MAAM,EAAE;MAClD,IAAI,CAAC7L,oBAAoB,CAAC8L,wBAAwB,CAACD,MAAM,CAAC;MAC1D,IAAIE,aAAa,GAAG,IAAI,CAAC/L,oBAAoB,CAACgM,YAAY,CAACH,MAAM,EAAED,IAAI,CAAC;MACxE,IAAIK,QAAQ,GAAGL,IAAI;MAEnB,IAAI,IAAI,CAAC5L,oBAAoB,CAACkM,2BAA2B,CAACL,MAAM,EAAEI,QAAQ,EAAEF,aAAa,CAAC,EAAE;QAC1FE,QAAQ,GAAGJ,MAAM;QACjB,OAAOI,QAAQ;MACjB;MAEA,IAAIE,8BAA8B,GAAG,IAAI,CAACpM,qBAAqB,CAAC6H,cAAc,CAAC;QAC7ElM,IAAI,EAAE;UACJ+H,GAAG,EAAEoI,MAAM,CAAC,CAAC,CAAC;UACdnI,GAAG,EAAEmI,MAAM,CAAC,CAAC;QACf,CAAC;QACD3F,EAAE,EAAE;UACFzC,GAAG,EAAEoI,MAAM,CAAC,CAAC,CAAC;UACdnI,GAAG,EAAEmI,MAAM,CAAC,CAAC;QACf;MACF,CAAC,CAAC;MAEF,IAAI,CAACM,8BAA8B,EAAE;QACnC,OAAOF,QAAQ;MACjB;MAEAA,QAAQ,GAAG,IAAI,CAACjM,oBAAoB,CAACoM,YAAY,CAACP,MAAM,EAAEI,QAAQ,EAAEF,aAAa,EAAEI,8BAA8B,CAAC;MAClH,OAAOF,QAAQ;IACjB;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACD1P,GAAG,EAAE,kBAAkB;IACvBvB,KAAK,EAAE,SAAS0G,gBAAgB,CAACyI,MAAM,EAAEkC,KAAK,EAAE;MAC9C,IAAI,CAACtM,qBAAqB,CAACuM,gBAAgB,CAAC,OAAO,EAAEnC,MAAM,EAAEkC,KAAK,CAAC;IACrE;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACD9P,GAAG,EAAE,kBAAkB;IACvBvB,KAAK,EAAE,SAAS2G,gBAAgB,CAACwI,MAAM,EAAEkC,KAAK,EAAE;MAC9C,IAAI,CAACtM,qBAAqB,CAACuM,gBAAgB,CAAC,MAAM,EAAEnC,MAAM,EAAEkC,KAAK,CAAC;IACpE;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACD9P,GAAG,EAAE,kBAAkB;IACvBvB,KAAK,EAAE,SAAS4G,gBAAgB,CAAC6B,GAAG,EAAE4I,KAAK,EAAEE,MAAM,EAAE;MACnD,IAAIA,MAAM,KAAK,MAAM,EAAE;QACrB;MACF;MAEA,IAAI,CAACxM,qBAAqB,CAACuM,gBAAgB,CAAC,MAAM,EAAE7I,GAAG,EAAE4I,KAAK,CAAC;IACjE;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACD9P,GAAG,EAAE,kBAAkB;IACvBvB,KAAK,EAAE,SAAS6G,gBAAgB,CAAC4B,GAAG,EAAE4I,KAAK,EAAE;MAC3C,IAAI,CAACtM,qBAAqB,CAACuM,gBAAgB,CAAC,IAAI,EAAE7I,GAAG,EAAE4I,KAAK,CAAC;IAC/D;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACD9P,GAAG,EAAE,eAAe;IACpBvB,KAAK,EAAE,SAAS8G,aAAa,CAAC0K,OAAO,EAAED,MAAM,EAAE;MAC7C,IAAIA,MAAM,KAAK,eAAe,EAAE;QAC9B;MACF;MAEA,IAAI,CAACvM,oBAAoB,CAACyM,2BAA2B,CAACD,OAAO,CAAC;IAChE;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDjQ,GAAG,EAAE,yBAAyB;IAC9BvB,KAAK,EAAE,SAAS+G,uBAAuB,CAAC2K,OAAO,EAAEC,SAAS,EAAE;MAC1D,IAAIA,SAAS,IAAIA,SAAS,KAAK,MAAM,EAAE;QACrC,IAAIC,aAAa,GAAG,IAAI,CAACzM,GAAG,CAAC6F,oBAAoB,EAAE;QACnD,IAAIiE,sBAAsB,GAAG,IAAI,CAAClK,qBAAqB,CAAC6H,cAAc,CAACgF,aAAa,CAAC;QACrF5N,SAAS,CAACiL,sBAAsB,EAAE,UAAUjC,UAAU,EAAE;UACtD,IAAI4E,aAAa,CAAC9F,oBAAoB,EAAE,CAACrD,GAAG,KAAKuE,UAAU,CAAC6E,UAAU,EAAE,IAAID,aAAa,CAAC9F,oBAAoB,EAAE,CAACpD,GAAG,KAAKsE,UAAU,CAAC8E,aAAa,EAAE,EAAE;YACnJJ,OAAO,CAAC,CAAC,CAAC,GAAG1E,UAAU,CAACvE,GAAG;YAC3BiJ,OAAO,CAAC,CAAC,CAAC,GAAG1E,UAAU,CAACtE,GAAG;UAC7B;QACF,CAAC,CAAC;MACJ;IACF;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDnH,GAAG,EAAE,6BAA6B;IAClCvB,KAAK,EAAE,SAAS+F,2BAA2B,CAACyJ,MAAM,EAAEuC,eAAe,EAAEC,eAAe,EAAE;MACpF,IAAI,CAAC,IAAI,CAACxM,OAAO,EAAE;QACjB;MACF;MAEA,IAAIyM,kBAAkB,GAAG,IAAI,CAAClN,qBAAqB,CAAC5C,GAAG,CAACqN,MAAM,CAAC/G,GAAG,EAAE+G,MAAM,CAAC9G,GAAG,CAAC;MAE/E,IAAI,CAACuJ,kBAAkB,EAAE;QACvB;MACF;MAEA,IAAIC,SAAS,GAAGH,eAAe,GAAG,CAAC;MACnC,IAAII,OAAO,GAAGJ,eAAe,GAAG,CAAC;MACjC,IAAIK,SAAS,GAAGJ,eAAe,GAAG,CAAC;MACnC,IAAIK,UAAU,GAAGL,eAAe,GAAG,CAAC;MACpC,IAAIM,sBAAsB,GAAGL,kBAAkB,CAACxJ,GAAG,GAAGwJ,kBAAkB,CAACrJ,OAAO,GAAG,CAAC,KAAK,IAAI,CAACzD,GAAG,CAAC2C,SAAS,EAAE,GAAG,CAAC;MACjH,IAAIyK,mBAAmB,GAAGN,kBAAkB,CAACxJ,GAAG,KAAK,CAAC;MACtD,IAAI+J,qBAAqB,GAAGP,kBAAkB,CAACvJ,GAAG,GAAGuJ,kBAAkB,CAACpJ,OAAO,GAAG,CAAC,KAAK,IAAI,CAAC1D,GAAG,CAAC4C,SAAS,EAAE,GAAG,CAAC;MAChH,IAAI0K,oBAAoB,GAAGR,kBAAkB,CAACvJ,GAAG,KAAK,CAAC;MAEvD,IAAIwJ,SAAS,IAAII,sBAAsB,IAAIH,OAAO,IAAII,mBAAmB,IAAIF,UAAU,IAAIG,qBAAqB,IAAIJ,SAAS,IAAIK,oBAAoB,EAAE;QACrJjD,MAAM,CAAC/G,GAAG,GAAGwJ,kBAAkB,CAACxJ,GAAG;QACnC+G,MAAM,CAAC9G,GAAG,GAAGuJ,kBAAkB,CAACvJ,GAAG;MACrC;IACF;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDnH,GAAG,EAAE,sBAAsB;IAC3BvB,KAAK,EAAE,SAASgH,oBAAoB,CAAC0L,UAAU,EAAEC,aAAa,EAAEC,kBAAkB,EAAEC,UAAU,EAAE;MAC9F,OAAO,IAAI,CAAC5N,qBAAqB,CAAC6N,8BAA8B,CAACJ,UAAU,EAAEC,aAAa,EAAEC,kBAAkB,EAAEC,UAAU,CAAC;IAC7H;IACA;AACJ;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDtR,GAAG,EAAE,8BAA8B;IACnCvB,KAAK,EAAE,SAASiH,4BAA4B,GAAG;MAC7C,OAAO,IAAI,CAAChC,qBAAqB,CAAC8N,sCAAsC,EAAE;IAC5E;EACF,CAAC,CAAC,CAAC;EAEH,OAAOtO,UAAU;AACnB,CAAC,CAACpB,UAAU,CAAC;AAEbE,cAAc,CAAC,YAAY,EAAEkB,UAAU,CAAC;AACxC,eAAeA,UAAU"},"metadata":{},"sourceType":"module"}