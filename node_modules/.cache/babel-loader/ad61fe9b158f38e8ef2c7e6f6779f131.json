{"ast":null,"code":"function _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"Unsupported format of the selection ranges was passed. To select cells pass \\n        the coordinates as an array of arrays ([[rowStart, columnStart/columnPropStart, rowEnd, columnEnd/columnPropEnd]]) \\n        or as an array of CellRange objects.\"]);\n  _templateObject = function _templateObject() {\n    return data;\n  };\n  return data;\n}\nfunction _taggedTemplateLiteral(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nimport Highlight, { AREA_TYPE, HEADER_TYPE, CELL_TYPE } from './highlight/highlight';\nimport SelectionRange from './range';\nimport { CellCoords } from './../3rdparty/walkontable/src';\nimport { isPressedCtrlKey } from './../utils/keyStateObserver';\nimport { createObjectPropListener, mixin } from './../helpers/object';\nimport { isUndefined } from './../helpers/mixed';\nimport { arrayEach } from './../helpers/array';\nimport localHooks from './../mixins/localHooks';\nimport Transformation from './transformation';\nimport { detectSelectionType, isValidCoord, normalizeSelectionFactory, SELECTION_TYPE_EMPTY, SELECTION_TYPE_UNRECOGNIZED } from './utils';\nimport { toSingleLine } from './../helpers/templateLiteralTag';\n/**\n * @class Selection\n * @util\n */\n\nvar Selection = /*#__PURE__*/\nfunction () {\n  function Selection(settings, tableProps) {\n    var _this = this;\n    _classCallCheck(this, Selection);\n\n    /**\n     * Handsontable settings instance.\n     *\n     * @type {GridSettings}\n     */\n    this.settings = settings;\n    /**\n     * An additional object with dynamically defined properties which describes table state.\n     *\n     * @type {Object}\n     */\n\n    this.tableProps = tableProps;\n    /**\n     * The flag which determines if the selection is in progress.\n     *\n     * @type {Boolean}\n     */\n\n    this.inProgress = false;\n    /**\n     * The flag indicates that selection was performed by clicking the corner overlay.\n     *\n     * @type {Boolean}\n     */\n\n    this.selectedByCorner = false;\n    /**\n     * The collection of the selection layer levels where the whole row was selected using the row header.\n     *\n     * @type {Set.<Number>}\n     */\n\n    this.selectedByRowHeader = new Set();\n    /**\n     * The collection of the selection layer levels where the whole column was selected using the column header.\n     *\n     * @type {Set.<Number>}\n     */\n\n    this.selectedByColumnHeader = new Set();\n    /**\n     * Selection data layer.\n     *\n     * @type {SelectionRange}\n     */\n\n    this.selectedRange = new SelectionRange();\n    /**\n     * Visualization layer.\n     *\n     * @type {Highlight}\n     */\n\n    this.highlight = new Highlight({\n      headerClassName: settings.currentHeaderClassName,\n      activeHeaderClassName: settings.activeHeaderClassName,\n      rowClassName: settings.currentRowClassName,\n      columnClassName: settings.currentColClassName,\n      disableHighlight: this.settings.disableVisualSelection,\n      cellCornerVisible: function cellCornerVisible() {\n        return _this.isCellCornerVisible.apply(_this, arguments);\n      },\n      areaCornerVisible: function areaCornerVisible() {\n        return _this.isAreaCornerVisible.apply(_this, arguments);\n      }\n    });\n    /**\n     * The module for modifying coordinates.\n     *\n     * @type {Transformation}\n     */\n\n    this.transformation = new Transformation(this.selectedRange, {\n      countRows: function countRows() {\n        return _this.tableProps.countRows();\n      },\n      countCols: function countCols() {\n        return _this.tableProps.countCols();\n      },\n      fixedRowsBottom: function fixedRowsBottom() {\n        return settings.fixedRowsBottom;\n      },\n      minSpareRows: function minSpareRows() {\n        return settings.minSpareRows;\n      },\n      minSpareCols: function minSpareCols() {\n        return settings.minSpareCols;\n      },\n      autoWrapRow: function autoWrapRow() {\n        return settings.autoWrapRow;\n      },\n      autoWrapCol: function autoWrapCol() {\n        return settings.autoWrapCol;\n      }\n    });\n    this.transformation.addLocalHook('beforeTransformStart', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _this.runLocalHooks.apply(_this, ['beforeModifyTransformStart'].concat(args));\n    });\n    this.transformation.addLocalHook('afterTransformStart', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return _this.runLocalHooks.apply(_this, ['afterModifyTransformStart'].concat(args));\n    });\n    this.transformation.addLocalHook('beforeTransformEnd', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return _this.runLocalHooks.apply(_this, ['beforeModifyTransformEnd'].concat(args));\n    });\n    this.transformation.addLocalHook('afterTransformEnd', function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      return _this.runLocalHooks.apply(_this, ['afterModifyTransformEnd'].concat(args));\n    });\n    this.transformation.addLocalHook('insertRowRequire', function () {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      return _this.runLocalHooks.apply(_this, ['insertRowRequire'].concat(args));\n    });\n    this.transformation.addLocalHook('insertColRequire', function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      return _this.runLocalHooks.apply(_this, ['insertColRequire'].concat(args));\n    });\n  }\n  /**\n   * Get data layer for current selection.\n   *\n   * @return {SelectionRange}\n   */\n\n  _createClass(Selection, [{\n    key: \"getSelectedRange\",\n    value: function getSelectedRange() {\n      return this.selectedRange;\n    }\n    /**\n     * Indicate that selection process began. It sets internaly `.inProgress` property to `true`.\n     */\n  }, {\n    key: \"begin\",\n    value: function begin() {\n      this.inProgress = true;\n    }\n    /**\n     * Indicate that selection process finished. It sets internaly `.inProgress` property to `false`.\n     */\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      this.runLocalHooks('afterSelectionFinished', Array.from(this.selectedRange));\n      this.inProgress = false;\n    }\n    /**\n     * Check if the process of selecting the cell/cells is in progress.\n     *\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"isInProgress\",\n    value: function isInProgress() {\n      return this.inProgress;\n    }\n    /**\n     * Starts selection range on given coordinate object.\n     *\n     * @param {CellCoords} coords Visual coords.\n     * @param {Boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works\n     *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined\n     *                                      the default trigger will be used (isPressedCtrlKey() helper).\n     * @param {Boolean} [fragment=false] If `true`, the selection will be treated as a partial selection where the\n     *                                   `setRangeEnd` method won't be called on every `setRangeStart` call.\n     */\n  }, {\n    key: \"setRangeStart\",\n    value: function setRangeStart(coords, multipleSelection) {\n      var fragment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var isMultipleMode = this.settings.selectionMode === 'multiple';\n      var isMultipleSelection = isUndefined(multipleSelection) ? isPressedCtrlKey() : multipleSelection;\n      var isRowNegative = coords.row < 0;\n      var isColumnNegative = coords.col < 0;\n      var selectedByCorner = isRowNegative && isColumnNegative;\n      if (isRowNegative) {\n        coords.row = 0;\n      }\n      if (isColumnNegative) {\n        coords.col = 0;\n      }\n      this.selectedByCorner = selectedByCorner;\n      this.runLocalHooks(\"beforeSetRangeStart\".concat(fragment ? 'Only' : ''), coords);\n      if (!isMultipleMode || isMultipleMode && !isMultipleSelection && isUndefined(multipleSelection)) {\n        this.selectedRange.clear();\n      }\n      this.selectedRange.add(coords);\n      if (this.getLayerLevel() === 0) {\n        this.selectedByRowHeader.clear();\n        this.selectedByColumnHeader.clear();\n      }\n      if (!selectedByCorner && isColumnNegative) {\n        this.selectedByRowHeader.add(this.getLayerLevel());\n      }\n      if (!selectedByCorner && isRowNegative) {\n        this.selectedByColumnHeader.add(this.getLayerLevel());\n      }\n      if (!fragment) {\n        this.setRangeEnd(coords);\n      }\n    }\n    /**\n     * Starts selection range on given coordinate object.\n     *\n     * @param {CellCoords} coords Visual coords.\n     * @param {Boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works\n     *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined\n     *                                      the default trigger will be used (isPressedCtrlKey() helper).\n     */\n  }, {\n    key: \"setRangeStartOnly\",\n    value: function setRangeStartOnly(coords, multipleSelection) {\n      this.setRangeStart(coords, multipleSelection, true);\n    }\n    /**\n     * Ends selection range on given coordinate object.\n     *\n     * @param {CellCoords} coords Visual coords.\n     */\n  }, {\n    key: \"setRangeEnd\",\n    value: function setRangeEnd(coords) {\n      if (this.selectedRange.isEmpty()) {\n        return;\n      }\n      this.runLocalHooks('beforeSetRangeEnd', coords);\n      this.begin();\n      var cellRange = this.selectedRange.current();\n      if (this.settings.selectionMode !== 'single') {\n        cellRange.setTo(new CellCoords(coords.row, coords.col));\n      } // Set up current selection.\n\n      this.highlight.getCell().clear();\n      if (this.highlight.isEnabledFor(CELL_TYPE)) {\n        this.highlight.getCell().add(this.selectedRange.current().highlight);\n      }\n      var layerLevel = this.getLayerLevel(); // If the next layer level is lower than previous then clear all area and header highlights. This is the\n      // indication that the new selection is performing.\n\n      if (layerLevel < this.highlight.layerLevel) {\n        arrayEach(this.highlight.getAreas(), function (highlight) {\n          return void highlight.clear();\n        });\n        arrayEach(this.highlight.getHeaders(), function (highlight) {\n          return void highlight.clear();\n        });\n        arrayEach(this.highlight.getActiveHeaders(), function (highlight) {\n          return void highlight.clear();\n        });\n      }\n      this.highlight.useLayerLevel(layerLevel);\n      var areaHighlight = this.highlight.createOrGetArea();\n      var headerHighlight = this.highlight.createOrGetHeader();\n      var activeHeaderHighlight = this.highlight.createOrGetActiveHeader();\n      areaHighlight.clear();\n      headerHighlight.clear();\n      activeHeaderHighlight.clear();\n      if (this.highlight.isEnabledFor(AREA_TYPE) && (this.isMultiple() || layerLevel >= 1)) {\n        areaHighlight.add(cellRange.from).add(cellRange.to);\n        if (layerLevel === 1) {\n          // For single cell selection in the same layer, we do not create area selection to prevent blue background.\n          // When non-consecutive selection is performed we have to add that missing area selection to the previous layer\n          // based on previous coordinates. It only occurs when the previous selection wasn't select multiple cells.\n          this.highlight.useLayerLevel(layerLevel - 1).createOrGetArea().add(this.selectedRange.previous().from);\n          this.highlight.useLayerLevel(layerLevel);\n        }\n      }\n      if (this.highlight.isEnabledFor(HEADER_TYPE)) {\n        if (this.settings.selectionMode === 'single') {\n          headerHighlight.add(cellRange.highlight);\n        } else {\n          headerHighlight.add(cellRange.from).add(cellRange.to);\n        }\n      }\n      if (this.isSelectedByRowHeader()) {\n        var isRowSelected = this.tableProps.countCols() === cellRange.getWidth(); // Make sure that the whole row is selected (in case where selectionMode is set to 'single')\n\n        if (isRowSelected) {\n          activeHeaderHighlight.add(new CellCoords(cellRange.from.row, -1)).add(new CellCoords(cellRange.to.row, -1));\n        }\n      }\n      if (this.isSelectedByColumnHeader()) {\n        var isColumnSelected = this.tableProps.countRows() === cellRange.getHeight(); // Make sure that the whole column is selected (in case where selectionMode is set to 'single')\n\n        if (isColumnSelected) {\n          activeHeaderHighlight.add(new CellCoords(-1, cellRange.from.col)).add(new CellCoords(-1, cellRange.to.col));\n        }\n      }\n      this.runLocalHooks('afterSetRangeEnd', coords);\n    }\n    /**\n     * Returns information if we have a multiselection. This method check multiselection only on the latest layer of\n     * the selection.\n     *\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"isMultiple\",\n    value: function isMultiple() {\n      var isMultipleListener = createObjectPropListener(!this.selectedRange.current().isSingle());\n      this.runLocalHooks('afterIsMultipleSelection', isMultipleListener);\n      return isMultipleListener.value;\n    }\n    /**\n     * Selects cell relative to the current cell (if possible).\n     *\n     * @param {Number} rowDelta Rows number to move, value can be passed as negative number.\n     * @param {Number} colDelta Columns number to move, value can be passed as negative number.\n     * @param {Boolean} force If `true` the new rows/columns will be created if necessary. Otherwise, row/column will\n     *                        be created according to `minSpareRows/minSpareCols` settings of Handsontable.\n     */\n  }, {\n    key: \"transformStart\",\n    value: function transformStart(rowDelta, colDelta, force) {\n      this.setRangeStart(this.transformation.transformStart(rowDelta, colDelta, force));\n    }\n    /**\n     * Sets selection end cell relative to the current selection end cell (if possible).\n     *\n     * @param {Number} rowDelta Rows number to move, value can be passed as negative number.\n     * @param {Number} colDelta Columns number to move, value can be passed as negative number.\n     */\n  }, {\n    key: \"transformEnd\",\n    value: function transformEnd(rowDelta, colDelta) {\n      this.setRangeEnd(this.transformation.transformEnd(rowDelta, colDelta));\n    }\n    /**\n     * Returns currently used layer level.\n     *\n     * @return {Number} Returns layer level starting from 0. If no selection was added to the table -1 is returned.\n     */\n  }, {\n    key: \"getLayerLevel\",\n    value: function getLayerLevel() {\n      return this.selectedRange.size() - 1;\n    }\n    /**\n     * Returns `true` if currently there is a selection on the screen, `false` otherwise.\n     *\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"isSelected\",\n    value: function isSelected() {\n      return !this.selectedRange.isEmpty();\n    }\n    /**\n     * Returns `true` if the selection was applied by clicking to the row header. If the `layerLevel`\n     * argument is passed then only that layer will be checked. Otherwise, it checks if any row header\n     * was clicked on any selection layer level.\n     *\n     * @param {Number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n     * @return {Boolean}\n     */\n  }, {\n    key: \"isSelectedByRowHeader\",\n    value: function isSelectedByRowHeader() {\n      var layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n      return layerLevel === -1 ? this.selectedByRowHeader.size > 0 : this.selectedByRowHeader.has(layerLevel);\n    }\n    /**\n     * Returns `true` if the selection was applied by clicking to the column header. If the `layerLevel`\n     * argument is passed then only that layer will be checked. Otherwise, it checks if any column header\n     * was clicked on any selection layer level.\n     *\n     * @param {Number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n     * @return {Boolean}\n     */\n  }, {\n    key: \"isSelectedByColumnHeader\",\n    value: function isSelectedByColumnHeader() {\n      var layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n      return layerLevel === -1 ? this.selectedByColumnHeader.size > 0 : this.selectedByColumnHeader.has(layerLevel);\n    }\n    /**\n     * Returns `true` if the selection was applied by clicking on the row or column header on any layer level.\n     *\n     * @return {Boolean}\n     */\n  }, {\n    key: \"isSelectedByAnyHeader\",\n    value: function isSelectedByAnyHeader() {\n      return this.isSelectedByRowHeader(-1) || this.isSelectedByColumnHeader(-1);\n    }\n    /**\n     * Returns `true` if the selection was applied by clicking on the left-top corner overlay.\n     *\n     * @return {Boolean}\n     */\n  }, {\n    key: \"isSelectedByCorner\",\n    value: function isSelectedByCorner() {\n      return this.selectedByCorner;\n    }\n    /**\n     * Returns `true` if coords is within selection coords. This method iterates through all selection layers to check if\n     * the coords object is within selection range.\n     *\n     * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"inInSelection\",\n    value: function inInSelection(coords) {\n      return this.selectedRange.includes(coords);\n    }\n    /**\n     * Returns `true` if the cell corner should be visible.\n     *\n     * @private\n     * @return {Boolean} `true` if the corner element has to be visible, `false` otherwise.\n     */\n  }, {\n    key: \"isCellCornerVisible\",\n    value: function isCellCornerVisible() {\n      return this.settings.fillHandle && !this.tableProps.isEditorOpened() && !this.isMultiple();\n    }\n    /**\n     * Returns `true` if the area corner should be visible.\n     *\n     * @param {Number} layerLevel The layer level.\n     * @return {Boolean} `true` if the corner element has to be visible, `false` otherwise.\n     */\n  }, {\n    key: \"isAreaCornerVisible\",\n    value: function isAreaCornerVisible(layerLevel) {\n      if (Number.isInteger(layerLevel) && layerLevel !== this.getLayerLevel()) {\n        return false;\n      }\n      return this.settings.fillHandle && !this.tableProps.isEditorOpened() && this.isMultiple();\n    }\n    /**\n     * Clear the selection by resetting the collected ranges and highlights.\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.selectedRange.clear();\n      this.highlight.clear();\n    }\n    /**\n     * Deselects all selected cells.\n     */\n  }, {\n    key: \"deselect\",\n    value: function deselect() {\n      if (!this.isSelected()) {\n        return;\n      }\n      this.inProgress = false;\n      this.clear();\n      this.runLocalHooks('afterDeselect');\n    }\n    /**\n     * Select all cells.\n     */\n  }, {\n    key: \"selectAll\",\n    value: function selectAll() {\n      this.clear();\n      this.setRangeStart(new CellCoords(-1, -1));\n      this.selectedByRowHeader.add(this.getLayerLevel());\n      this.selectedByColumnHeader.add(this.getLayerLevel());\n      this.setRangeEnd(new CellCoords(this.tableProps.countRows() - 1, this.tableProps.countCols() - 1));\n    }\n    /**\n     * Make multiple, non-contiguous selection specified by `row` and `column` values or a range of cells\n     * finishing at `endRow`, `endColumn`. The method supports two input formats, first as an array of arrays such\n     * as `[[rowStart, columnStart, rowEnd, columnEnd]]` and second format as an array of CellRange objects.\n     * If the passed ranges have another format the exception will be thrown.\n     *\n     * @param {Array[]|CellRange[]} selectionRanges The coordinates which define what the cells should be selected.\n     * @return {Boolean} Returns `true` if selection was successful, `false` otherwise.\n     */\n  }, {\n    key: \"selectCells\",\n    value: function selectCells(selectionRanges) {\n      var _this2 = this;\n      var selectionType = detectSelectionType(selectionRanges);\n      if (selectionType === SELECTION_TYPE_EMPTY) {\n        return false;\n      } else if (selectionType === SELECTION_TYPE_UNRECOGNIZED) {\n        throw new Error(toSingleLine(_templateObject()));\n      }\n      var selectionSchemaNormalizer = normalizeSelectionFactory(selectionType, {\n        propToCol: function propToCol(prop) {\n          return _this2.tableProps.propToCol(prop);\n        },\n        keepDirection: true\n      });\n      var countRows = this.tableProps.countRows();\n      var countCols = this.tableProps.countCols(); // Check if every layer of the coordinates are valid.\n\n      var isValid = !selectionRanges.some(function (selection) {\n        var _selectionSchemaNorma = selectionSchemaNormalizer(selection),\n          _selectionSchemaNorma2 = _slicedToArray(_selectionSchemaNorma, 4),\n          rowStart = _selectionSchemaNorma2[0],\n          columnStart = _selectionSchemaNorma2[1],\n          rowEnd = _selectionSchemaNorma2[2],\n          columnEnd = _selectionSchemaNorma2[3];\n        var _isValid = isValidCoord(rowStart, countRows) && isValidCoord(columnStart, countCols) && isValidCoord(rowEnd, countRows) && isValidCoord(columnEnd, countCols);\n        return !_isValid;\n      });\n      if (isValid) {\n        this.clear();\n        arrayEach(selectionRanges, function (selection) {\n          var _selectionSchemaNorma3 = selectionSchemaNormalizer(selection),\n            _selectionSchemaNorma4 = _slicedToArray(_selectionSchemaNorma3, 4),\n            rowStart = _selectionSchemaNorma4[0],\n            columnStart = _selectionSchemaNorma4[1],\n            rowEnd = _selectionSchemaNorma4[2],\n            columnEnd = _selectionSchemaNorma4[3];\n          _this2.setRangeStartOnly(new CellCoords(rowStart, columnStart), false);\n          _this2.setRangeEnd(new CellCoords(rowEnd, columnEnd));\n          _this2.finish();\n        });\n      }\n      return isValid;\n    }\n    /**\n     * Select column specified by `startColumn` visual index or column property or a range of columns finishing at `endColumn`.\n     *\n     * @param {Number|String} startColumn Visual column index or column property from which the selection starts.\n     * @param {Number|String} [endColumn] Visual column index or column property from to the selection finishes.\n     * @returns {Boolean} Returns `true` if selection was successful, `false` otherwise.\n     */\n  }, {\n    key: \"selectColumns\",\n    value: function selectColumns(startColumn) {\n      var endColumn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startColumn;\n      var start = typeof startColumn === 'string' ? this.tableProps.propToCol(startColumn) : startColumn;\n      var end = typeof endColumn === 'string' ? this.tableProps.propToCol(endColumn) : endColumn;\n      var countCols = this.tableProps.countCols();\n      var isValid = isValidCoord(start, countCols) && isValidCoord(end, countCols);\n      if (isValid) {\n        this.setRangeStartOnly(new CellCoords(-1, start));\n        this.setRangeEnd(new CellCoords(this.tableProps.countRows() - 1, end));\n        this.finish();\n      }\n      return isValid;\n    }\n    /**\n     * Select row specified by `startRow` visual index or a range of rows finishing at `endRow`.\n     *\n     * @param {Number} startRow Visual row index from which the selection starts.\n     * @param {Number} [endRow] Visual row index from to the selection finishes.\n     * @returns {Boolean} Returns `true` if selection was successful, `false` otherwise.\n     */\n  }, {\n    key: \"selectRows\",\n    value: function selectRows(startRow) {\n      var endRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startRow;\n      var countRows = this.tableProps.countRows();\n      var isValid = isValidCoord(startRow, countRows) && isValidCoord(endRow, countRows);\n      if (isValid) {\n        this.setRangeStartOnly(new CellCoords(startRow, -1));\n        this.setRangeEnd(new CellCoords(endRow, this.tableProps.countCols() - 1));\n        this.finish();\n      }\n      return isValid;\n    }\n  }]);\n  return Selection;\n}();\nmixin(Selection, localHooks);\nexport default Selection;","map":{"version":3,"names":["_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","TypeError","Symbol","iterator","Object","prototype","toString","call","_arr","_n","_d","_e","undefined","_i","_s","next","done","push","value","length","err","Array","isArray","_templateObject","data","_taggedTemplateLiteral","strings","raw","slice","freeze","defineProperties","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","Highlight","AREA_TYPE","HEADER_TYPE","CELL_TYPE","SelectionRange","CellCoords","isPressedCtrlKey","createObjectPropListener","mixin","isUndefined","arrayEach","localHooks","Transformation","detectSelectionType","isValidCoord","normalizeSelectionFactory","SELECTION_TYPE_EMPTY","SELECTION_TYPE_UNRECOGNIZED","toSingleLine","Selection","settings","tableProps","_this","inProgress","selectedByCorner","selectedByRowHeader","Set","selectedByColumnHeader","selectedRange","highlight","headerClassName","currentHeaderClassName","activeHeaderClassName","rowClassName","currentRowClassName","columnClassName","currentColClassName","disableHighlight","disableVisualSelection","cellCornerVisible","isCellCornerVisible","apply","arguments","areaCornerVisible","isAreaCornerVisible","transformation","countRows","countCols","fixedRowsBottom","minSpareRows","minSpareCols","autoWrapRow","autoWrapCol","addLocalHook","_len","args","_key","runLocalHooks","concat","_len2","_key2","_len3","_key3","_len4","_key4","_len5","_key5","_len6","_key6","getSelectedRange","begin","finish","from","isInProgress","setRangeStart","coords","multipleSelection","fragment","isMultipleMode","selectionMode","isMultipleSelection","isRowNegative","row","isColumnNegative","col","clear","add","getLayerLevel","setRangeEnd","setRangeStartOnly","isEmpty","cellRange","current","setTo","getCell","isEnabledFor","layerLevel","getAreas","getHeaders","getActiveHeaders","useLayerLevel","areaHighlight","createOrGetArea","headerHighlight","createOrGetHeader","activeHeaderHighlight","createOrGetActiveHeader","isMultiple","to","previous","isSelectedByRowHeader","isRowSelected","getWidth","isSelectedByColumnHeader","isColumnSelected","getHeight","isMultipleListener","isSingle","transformStart","rowDelta","colDelta","force","transformEnd","size","isSelected","has","isSelectedByAnyHeader","isSelectedByCorner","inInSelection","includes","fillHandle","isEditorOpened","Number","isInteger","deselect","selectAll","selectCells","selectionRanges","_this2","selectionType","Error","selectionSchemaNormalizer","propToCol","prop","keepDirection","isValid","some","selection","_selectionSchemaNorma","_selectionSchemaNorma2","rowStart","columnStart","rowEnd","columnEnd","_isValid","_selectionSchemaNorma3","_selectionSchemaNorma4","selectColumns","startColumn","endColumn","start","end","selectRows","startRow","endRow"],"sources":["C:/Users/mrezy/VSCode/internships-master/node_modules/handsontable/es/selection/selection.js"],"sourcesContent":["import \"core-js/modules/es.symbol\";\nimport \"core-js/modules/es.symbol.description\";\nimport \"core-js/modules/es.symbol.iterator\";\nimport \"core-js/modules/es.array.concat\";\nimport \"core-js/modules/es.array.from\";\nimport \"core-js/modules/es.array.includes\";\nimport \"core-js/modules/es.array.iterator\";\nimport \"core-js/modules/es.array.slice\";\nimport \"core-js/modules/es.array.some\";\nimport \"core-js/modules/es.number.constructor\";\nimport \"core-js/modules/es.number.is-integer\";\nimport \"core-js/modules/es.object.freeze\";\nimport \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.regexp.to-string\";\nimport \"core-js/modules/es.set\";\nimport \"core-js/modules/es.string.includes\";\nimport \"core-js/modules/es.string.iterator\";\nimport \"core-js/modules/web.dom-collections.iterator\";\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"Unsupported format of the selection ranges was passed. To select cells pass \\n        the coordinates as an array of arrays ([[rowStart, columnStart/columnPropStart, rowEnd, columnEnd/columnPropEnd]]) \\n        or as an array of CellRange objects.\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport Highlight, { AREA_TYPE, HEADER_TYPE, CELL_TYPE } from './highlight/highlight';\nimport SelectionRange from './range';\nimport { CellCoords } from './../3rdparty/walkontable/src';\nimport { isPressedCtrlKey } from './../utils/keyStateObserver';\nimport { createObjectPropListener, mixin } from './../helpers/object';\nimport { isUndefined } from './../helpers/mixed';\nimport { arrayEach } from './../helpers/array';\nimport localHooks from './../mixins/localHooks';\nimport Transformation from './transformation';\nimport { detectSelectionType, isValidCoord, normalizeSelectionFactory, SELECTION_TYPE_EMPTY, SELECTION_TYPE_UNRECOGNIZED } from './utils';\nimport { toSingleLine } from './../helpers/templateLiteralTag';\n/**\n * @class Selection\n * @util\n */\n\nvar Selection =\n/*#__PURE__*/\nfunction () {\n  function Selection(settings, tableProps) {\n    var _this = this;\n\n    _classCallCheck(this, Selection);\n\n    /**\n     * Handsontable settings instance.\n     *\n     * @type {GridSettings}\n     */\n    this.settings = settings;\n    /**\n     * An additional object with dynamically defined properties which describes table state.\n     *\n     * @type {Object}\n     */\n\n    this.tableProps = tableProps;\n    /**\n     * The flag which determines if the selection is in progress.\n     *\n     * @type {Boolean}\n     */\n\n    this.inProgress = false;\n    /**\n     * The flag indicates that selection was performed by clicking the corner overlay.\n     *\n     * @type {Boolean}\n     */\n\n    this.selectedByCorner = false;\n    /**\n     * The collection of the selection layer levels where the whole row was selected using the row header.\n     *\n     * @type {Set.<Number>}\n     */\n\n    this.selectedByRowHeader = new Set();\n    /**\n     * The collection of the selection layer levels where the whole column was selected using the column header.\n     *\n     * @type {Set.<Number>}\n     */\n\n    this.selectedByColumnHeader = new Set();\n    /**\n     * Selection data layer.\n     *\n     * @type {SelectionRange}\n     */\n\n    this.selectedRange = new SelectionRange();\n    /**\n     * Visualization layer.\n     *\n     * @type {Highlight}\n     */\n\n    this.highlight = new Highlight({\n      headerClassName: settings.currentHeaderClassName,\n      activeHeaderClassName: settings.activeHeaderClassName,\n      rowClassName: settings.currentRowClassName,\n      columnClassName: settings.currentColClassName,\n      disableHighlight: this.settings.disableVisualSelection,\n      cellCornerVisible: function cellCornerVisible() {\n        return _this.isCellCornerVisible.apply(_this, arguments);\n      },\n      areaCornerVisible: function areaCornerVisible() {\n        return _this.isAreaCornerVisible.apply(_this, arguments);\n      }\n    });\n    /**\n     * The module for modifying coordinates.\n     *\n     * @type {Transformation}\n     */\n\n    this.transformation = new Transformation(this.selectedRange, {\n      countRows: function countRows() {\n        return _this.tableProps.countRows();\n      },\n      countCols: function countCols() {\n        return _this.tableProps.countCols();\n      },\n      fixedRowsBottom: function fixedRowsBottom() {\n        return settings.fixedRowsBottom;\n      },\n      minSpareRows: function minSpareRows() {\n        return settings.minSpareRows;\n      },\n      minSpareCols: function minSpareCols() {\n        return settings.minSpareCols;\n      },\n      autoWrapRow: function autoWrapRow() {\n        return settings.autoWrapRow;\n      },\n      autoWrapCol: function autoWrapCol() {\n        return settings.autoWrapCol;\n      }\n    });\n    this.transformation.addLocalHook('beforeTransformStart', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['beforeModifyTransformStart'].concat(args));\n    });\n    this.transformation.addLocalHook('afterTransformStart', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['afterModifyTransformStart'].concat(args));\n    });\n    this.transformation.addLocalHook('beforeTransformEnd', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['beforeModifyTransformEnd'].concat(args));\n    });\n    this.transformation.addLocalHook('afterTransformEnd', function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['afterModifyTransformEnd'].concat(args));\n    });\n    this.transformation.addLocalHook('insertRowRequire', function () {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['insertRowRequire'].concat(args));\n    });\n    this.transformation.addLocalHook('insertColRequire', function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['insertColRequire'].concat(args));\n    });\n  }\n  /**\n   * Get data layer for current selection.\n   *\n   * @return {SelectionRange}\n   */\n\n\n  _createClass(Selection, [{\n    key: \"getSelectedRange\",\n    value: function getSelectedRange() {\n      return this.selectedRange;\n    }\n    /**\n     * Indicate that selection process began. It sets internaly `.inProgress` property to `true`.\n     */\n\n  }, {\n    key: \"begin\",\n    value: function begin() {\n      this.inProgress = true;\n    }\n    /**\n     * Indicate that selection process finished. It sets internaly `.inProgress` property to `false`.\n     */\n\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      this.runLocalHooks('afterSelectionFinished', Array.from(this.selectedRange));\n      this.inProgress = false;\n    }\n    /**\n     * Check if the process of selecting the cell/cells is in progress.\n     *\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isInProgress\",\n    value: function isInProgress() {\n      return this.inProgress;\n    }\n    /**\n     * Starts selection range on given coordinate object.\n     *\n     * @param {CellCoords} coords Visual coords.\n     * @param {Boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works\n     *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined\n     *                                      the default trigger will be used (isPressedCtrlKey() helper).\n     * @param {Boolean} [fragment=false] If `true`, the selection will be treated as a partial selection where the\n     *                                   `setRangeEnd` method won't be called on every `setRangeStart` call.\n     */\n\n  }, {\n    key: \"setRangeStart\",\n    value: function setRangeStart(coords, multipleSelection) {\n      var fragment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var isMultipleMode = this.settings.selectionMode === 'multiple';\n      var isMultipleSelection = isUndefined(multipleSelection) ? isPressedCtrlKey() : multipleSelection;\n      var isRowNegative = coords.row < 0;\n      var isColumnNegative = coords.col < 0;\n      var selectedByCorner = isRowNegative && isColumnNegative;\n\n      if (isRowNegative) {\n        coords.row = 0;\n      }\n\n      if (isColumnNegative) {\n        coords.col = 0;\n      }\n\n      this.selectedByCorner = selectedByCorner;\n      this.runLocalHooks(\"beforeSetRangeStart\".concat(fragment ? 'Only' : ''), coords);\n\n      if (!isMultipleMode || isMultipleMode && !isMultipleSelection && isUndefined(multipleSelection)) {\n        this.selectedRange.clear();\n      }\n\n      this.selectedRange.add(coords);\n\n      if (this.getLayerLevel() === 0) {\n        this.selectedByRowHeader.clear();\n        this.selectedByColumnHeader.clear();\n      }\n\n      if (!selectedByCorner && isColumnNegative) {\n        this.selectedByRowHeader.add(this.getLayerLevel());\n      }\n\n      if (!selectedByCorner && isRowNegative) {\n        this.selectedByColumnHeader.add(this.getLayerLevel());\n      }\n\n      if (!fragment) {\n        this.setRangeEnd(coords);\n      }\n    }\n    /**\n     * Starts selection range on given coordinate object.\n     *\n     * @param {CellCoords} coords Visual coords.\n     * @param {Boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works\n     *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined\n     *                                      the default trigger will be used (isPressedCtrlKey() helper).\n     */\n\n  }, {\n    key: \"setRangeStartOnly\",\n    value: function setRangeStartOnly(coords, multipleSelection) {\n      this.setRangeStart(coords, multipleSelection, true);\n    }\n    /**\n     * Ends selection range on given coordinate object.\n     *\n     * @param {CellCoords} coords Visual coords.\n     */\n\n  }, {\n    key: \"setRangeEnd\",\n    value: function setRangeEnd(coords) {\n      if (this.selectedRange.isEmpty()) {\n        return;\n      }\n\n      this.runLocalHooks('beforeSetRangeEnd', coords);\n      this.begin();\n      var cellRange = this.selectedRange.current();\n\n      if (this.settings.selectionMode !== 'single') {\n        cellRange.setTo(new CellCoords(coords.row, coords.col));\n      } // Set up current selection.\n\n\n      this.highlight.getCell().clear();\n\n      if (this.highlight.isEnabledFor(CELL_TYPE)) {\n        this.highlight.getCell().add(this.selectedRange.current().highlight);\n      }\n\n      var layerLevel = this.getLayerLevel(); // If the next layer level is lower than previous then clear all area and header highlights. This is the\n      // indication that the new selection is performing.\n\n      if (layerLevel < this.highlight.layerLevel) {\n        arrayEach(this.highlight.getAreas(), function (highlight) {\n          return void highlight.clear();\n        });\n        arrayEach(this.highlight.getHeaders(), function (highlight) {\n          return void highlight.clear();\n        });\n        arrayEach(this.highlight.getActiveHeaders(), function (highlight) {\n          return void highlight.clear();\n        });\n      }\n\n      this.highlight.useLayerLevel(layerLevel);\n      var areaHighlight = this.highlight.createOrGetArea();\n      var headerHighlight = this.highlight.createOrGetHeader();\n      var activeHeaderHighlight = this.highlight.createOrGetActiveHeader();\n      areaHighlight.clear();\n      headerHighlight.clear();\n      activeHeaderHighlight.clear();\n\n      if (this.highlight.isEnabledFor(AREA_TYPE) && (this.isMultiple() || layerLevel >= 1)) {\n        areaHighlight.add(cellRange.from).add(cellRange.to);\n\n        if (layerLevel === 1) {\n          // For single cell selection in the same layer, we do not create area selection to prevent blue background.\n          // When non-consecutive selection is performed we have to add that missing area selection to the previous layer\n          // based on previous coordinates. It only occurs when the previous selection wasn't select multiple cells.\n          this.highlight.useLayerLevel(layerLevel - 1).createOrGetArea().add(this.selectedRange.previous().from);\n          this.highlight.useLayerLevel(layerLevel);\n        }\n      }\n\n      if (this.highlight.isEnabledFor(HEADER_TYPE)) {\n        if (this.settings.selectionMode === 'single') {\n          headerHighlight.add(cellRange.highlight);\n        } else {\n          headerHighlight.add(cellRange.from).add(cellRange.to);\n        }\n      }\n\n      if (this.isSelectedByRowHeader()) {\n        var isRowSelected = this.tableProps.countCols() === cellRange.getWidth(); // Make sure that the whole row is selected (in case where selectionMode is set to 'single')\n\n        if (isRowSelected) {\n          activeHeaderHighlight.add(new CellCoords(cellRange.from.row, -1)).add(new CellCoords(cellRange.to.row, -1));\n        }\n      }\n\n      if (this.isSelectedByColumnHeader()) {\n        var isColumnSelected = this.tableProps.countRows() === cellRange.getHeight(); // Make sure that the whole column is selected (in case where selectionMode is set to 'single')\n\n        if (isColumnSelected) {\n          activeHeaderHighlight.add(new CellCoords(-1, cellRange.from.col)).add(new CellCoords(-1, cellRange.to.col));\n        }\n      }\n\n      this.runLocalHooks('afterSetRangeEnd', coords);\n    }\n    /**\n     * Returns information if we have a multiselection. This method check multiselection only on the latest layer of\n     * the selection.\n     *\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isMultiple\",\n    value: function isMultiple() {\n      var isMultipleListener = createObjectPropListener(!this.selectedRange.current().isSingle());\n      this.runLocalHooks('afterIsMultipleSelection', isMultipleListener);\n      return isMultipleListener.value;\n    }\n    /**\n     * Selects cell relative to the current cell (if possible).\n     *\n     * @param {Number} rowDelta Rows number to move, value can be passed as negative number.\n     * @param {Number} colDelta Columns number to move, value can be passed as negative number.\n     * @param {Boolean} force If `true` the new rows/columns will be created if necessary. Otherwise, row/column will\n     *                        be created according to `minSpareRows/minSpareCols` settings of Handsontable.\n     */\n\n  }, {\n    key: \"transformStart\",\n    value: function transformStart(rowDelta, colDelta, force) {\n      this.setRangeStart(this.transformation.transformStart(rowDelta, colDelta, force));\n    }\n    /**\n     * Sets selection end cell relative to the current selection end cell (if possible).\n     *\n     * @param {Number} rowDelta Rows number to move, value can be passed as negative number.\n     * @param {Number} colDelta Columns number to move, value can be passed as negative number.\n     */\n\n  }, {\n    key: \"transformEnd\",\n    value: function transformEnd(rowDelta, colDelta) {\n      this.setRangeEnd(this.transformation.transformEnd(rowDelta, colDelta));\n    }\n    /**\n     * Returns currently used layer level.\n     *\n     * @return {Number} Returns layer level starting from 0. If no selection was added to the table -1 is returned.\n     */\n\n  }, {\n    key: \"getLayerLevel\",\n    value: function getLayerLevel() {\n      return this.selectedRange.size() - 1;\n    }\n    /**\n     * Returns `true` if currently there is a selection on the screen, `false` otherwise.\n     *\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isSelected\",\n    value: function isSelected() {\n      return !this.selectedRange.isEmpty();\n    }\n    /**\n     * Returns `true` if the selection was applied by clicking to the row header. If the `layerLevel`\n     * argument is passed then only that layer will be checked. Otherwise, it checks if any row header\n     * was clicked on any selection layer level.\n     *\n     * @param {Number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"isSelectedByRowHeader\",\n    value: function isSelectedByRowHeader() {\n      var layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n      return layerLevel === -1 ? this.selectedByRowHeader.size > 0 : this.selectedByRowHeader.has(layerLevel);\n    }\n    /**\n     * Returns `true` if the selection was applied by clicking to the column header. If the `layerLevel`\n     * argument is passed then only that layer will be checked. Otherwise, it checks if any column header\n     * was clicked on any selection layer level.\n     *\n     * @param {Number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"isSelectedByColumnHeader\",\n    value: function isSelectedByColumnHeader() {\n      var layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n      return layerLevel === -1 ? this.selectedByColumnHeader.size > 0 : this.selectedByColumnHeader.has(layerLevel);\n    }\n    /**\n     * Returns `true` if the selection was applied by clicking on the row or column header on any layer level.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"isSelectedByAnyHeader\",\n    value: function isSelectedByAnyHeader() {\n      return this.isSelectedByRowHeader(-1) || this.isSelectedByColumnHeader(-1);\n    }\n    /**\n     * Returns `true` if the selection was applied by clicking on the left-top corner overlay.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"isSelectedByCorner\",\n    value: function isSelectedByCorner() {\n      return this.selectedByCorner;\n    }\n    /**\n     * Returns `true` if coords is within selection coords. This method iterates through all selection layers to check if\n     * the coords object is within selection range.\n     *\n     * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"inInSelection\",\n    value: function inInSelection(coords) {\n      return this.selectedRange.includes(coords);\n    }\n    /**\n     * Returns `true` if the cell corner should be visible.\n     *\n     * @private\n     * @return {Boolean} `true` if the corner element has to be visible, `false` otherwise.\n     */\n\n  }, {\n    key: \"isCellCornerVisible\",\n    value: function isCellCornerVisible() {\n      return this.settings.fillHandle && !this.tableProps.isEditorOpened() && !this.isMultiple();\n    }\n    /**\n     * Returns `true` if the area corner should be visible.\n     *\n     * @param {Number} layerLevel The layer level.\n     * @return {Boolean} `true` if the corner element has to be visible, `false` otherwise.\n     */\n\n  }, {\n    key: \"isAreaCornerVisible\",\n    value: function isAreaCornerVisible(layerLevel) {\n      if (Number.isInteger(layerLevel) && layerLevel !== this.getLayerLevel()) {\n        return false;\n      }\n\n      return this.settings.fillHandle && !this.tableProps.isEditorOpened() && this.isMultiple();\n    }\n    /**\n     * Clear the selection by resetting the collected ranges and highlights.\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.selectedRange.clear();\n      this.highlight.clear();\n    }\n    /**\n     * Deselects all selected cells.\n     */\n\n  }, {\n    key: \"deselect\",\n    value: function deselect() {\n      if (!this.isSelected()) {\n        return;\n      }\n\n      this.inProgress = false;\n      this.clear();\n      this.runLocalHooks('afterDeselect');\n    }\n    /**\n     * Select all cells.\n     */\n\n  }, {\n    key: \"selectAll\",\n    value: function selectAll() {\n      this.clear();\n      this.setRangeStart(new CellCoords(-1, -1));\n      this.selectedByRowHeader.add(this.getLayerLevel());\n      this.selectedByColumnHeader.add(this.getLayerLevel());\n      this.setRangeEnd(new CellCoords(this.tableProps.countRows() - 1, this.tableProps.countCols() - 1));\n    }\n    /**\n     * Make multiple, non-contiguous selection specified by `row` and `column` values or a range of cells\n     * finishing at `endRow`, `endColumn`. The method supports two input formats, first as an array of arrays such\n     * as `[[rowStart, columnStart, rowEnd, columnEnd]]` and second format as an array of CellRange objects.\n     * If the passed ranges have another format the exception will be thrown.\n     *\n     * @param {Array[]|CellRange[]} selectionRanges The coordinates which define what the cells should be selected.\n     * @return {Boolean} Returns `true` if selection was successful, `false` otherwise.\n     */\n\n  }, {\n    key: \"selectCells\",\n    value: function selectCells(selectionRanges) {\n      var _this2 = this;\n\n      var selectionType = detectSelectionType(selectionRanges);\n\n      if (selectionType === SELECTION_TYPE_EMPTY) {\n        return false;\n      } else if (selectionType === SELECTION_TYPE_UNRECOGNIZED) {\n        throw new Error(toSingleLine(_templateObject()));\n      }\n\n      var selectionSchemaNormalizer = normalizeSelectionFactory(selectionType, {\n        propToCol: function propToCol(prop) {\n          return _this2.tableProps.propToCol(prop);\n        },\n        keepDirection: true\n      });\n      var countRows = this.tableProps.countRows();\n      var countCols = this.tableProps.countCols(); // Check if every layer of the coordinates are valid.\n\n      var isValid = !selectionRanges.some(function (selection) {\n        var _selectionSchemaNorma = selectionSchemaNormalizer(selection),\n            _selectionSchemaNorma2 = _slicedToArray(_selectionSchemaNorma, 4),\n            rowStart = _selectionSchemaNorma2[0],\n            columnStart = _selectionSchemaNorma2[1],\n            rowEnd = _selectionSchemaNorma2[2],\n            columnEnd = _selectionSchemaNorma2[3];\n\n        var _isValid = isValidCoord(rowStart, countRows) && isValidCoord(columnStart, countCols) && isValidCoord(rowEnd, countRows) && isValidCoord(columnEnd, countCols);\n\n        return !_isValid;\n      });\n\n      if (isValid) {\n        this.clear();\n        arrayEach(selectionRanges, function (selection) {\n          var _selectionSchemaNorma3 = selectionSchemaNormalizer(selection),\n              _selectionSchemaNorma4 = _slicedToArray(_selectionSchemaNorma3, 4),\n              rowStart = _selectionSchemaNorma4[0],\n              columnStart = _selectionSchemaNorma4[1],\n              rowEnd = _selectionSchemaNorma4[2],\n              columnEnd = _selectionSchemaNorma4[3];\n\n          _this2.setRangeStartOnly(new CellCoords(rowStart, columnStart), false);\n\n          _this2.setRangeEnd(new CellCoords(rowEnd, columnEnd));\n\n          _this2.finish();\n        });\n      }\n\n      return isValid;\n    }\n    /**\n     * Select column specified by `startColumn` visual index or column property or a range of columns finishing at `endColumn`.\n     *\n     * @param {Number|String} startColumn Visual column index or column property from which the selection starts.\n     * @param {Number|String} [endColumn] Visual column index or column property from to the selection finishes.\n     * @returns {Boolean} Returns `true` if selection was successful, `false` otherwise.\n     */\n\n  }, {\n    key: \"selectColumns\",\n    value: function selectColumns(startColumn) {\n      var endColumn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startColumn;\n      var start = typeof startColumn === 'string' ? this.tableProps.propToCol(startColumn) : startColumn;\n      var end = typeof endColumn === 'string' ? this.tableProps.propToCol(endColumn) : endColumn;\n      var countCols = this.tableProps.countCols();\n      var isValid = isValidCoord(start, countCols) && isValidCoord(end, countCols);\n\n      if (isValid) {\n        this.setRangeStartOnly(new CellCoords(-1, start));\n        this.setRangeEnd(new CellCoords(this.tableProps.countRows() - 1, end));\n        this.finish();\n      }\n\n      return isValid;\n    }\n    /**\n     * Select row specified by `startRow` visual index or a range of rows finishing at `endRow`.\n     *\n     * @param {Number} startRow Visual row index from which the selection starts.\n     * @param {Number} [endRow] Visual row index from to the selection finishes.\n     * @returns {Boolean} Returns `true` if selection was successful, `false` otherwise.\n     */\n\n  }, {\n    key: \"selectRows\",\n    value: function selectRows(startRow) {\n      var endRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startRow;\n      var countRows = this.tableProps.countRows();\n      var isValid = isValidCoord(startRow, countRows) && isValidCoord(endRow, countRows);\n\n      if (isValid) {\n        this.setRangeStartOnly(new CellCoords(startRow, -1));\n        this.setRangeEnd(new CellCoords(endRow, this.tableProps.countCols() - 1));\n        this.finish();\n      }\n\n      return isValid;\n    }\n  }]);\n\n  return Selection;\n}();\n\nmixin(Selection, localHooks);\nexport default Selection;"],"mappings":"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"},"metadata":{},"sourceType":"module"}