{"ast":null,"code":"import \"core-js/modules/es.array.index-of\";\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nimport { getScrollableElement, getTrimmingContainer } from './../../../../helpers/dom/element';\nimport { defineGetter } from './../../../../helpers/object';\nimport { arrayEach } from './../../../../helpers/array';\nimport { warn } from './../../../../helpers/console';\nimport EventManager from './../../../../eventManager';\nimport Walkontable from './../core';\nvar registeredOverlays = {};\n/**\n * Creates an overlay over the original Walkontable instance. The overlay renders the clone of the original Walkontable\n * and (optionally) implements behavior needed for native horizontal and vertical scrolling.\n *\n * @class Overlay\n */\n\nvar Overlay = /*#__PURE__*/\nfunction () {\n  _createClass(Overlay, null, [{\n    key: \"registerOverlay\",\n    /**\n     * Register overlay class.\n     *\n     * @param {String} type Overlay type, one of the CLONE_TYPES value\n     * @param {Overlay} overlayClass Overlay class extended from base overlay class {@link Overlay}\n     */\n    value: function registerOverlay(type, overlayClass) {\n      if (Overlay.CLONE_TYPES.indexOf(type) === -1) {\n        throw new Error(\"Unsupported overlay (\".concat(type, \").\"));\n      }\n      registeredOverlays[type] = overlayClass;\n    }\n    /**\n     * Create new instance of overlay type.\n     *\n     * @param {String} type Overlay type, one of the CLONE_TYPES value\n     * @param {Walkontable} wot Walkontable instance\n     */\n  }, {\n    key: \"createOverlay\",\n    value: function createOverlay(type, wot) {\n      return new registeredOverlays[type](wot);\n    }\n    /**\n     * Check if specified overlay was registered.\n     *\n     * @param {String} type Overlay type, one of the CLONE_TYPES value\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"hasOverlay\",\n    value: function hasOverlay(type) {\n      return registeredOverlays[type] !== void 0;\n    }\n    /**\n     * Checks if overlay object (`overlay`) is instance of overlay type (`type`).\n     *\n     * @param {Overlay} overlay Overlay object\n     * @param {String} type Overlay type, one of the CLONE_TYPES value\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"isOverlayTypeOf\",\n    value: function isOverlayTypeOf(overlay, type) {\n      if (!overlay || !registeredOverlays[type]) {\n        return false;\n      }\n      return overlay instanceof registeredOverlays[type];\n    }\n    /**\n     * @param {Walkontable} wotInstance\n     */\n  }, {\n    key: \"CLONE_TOP\",\n    /**\n     * @type {String}\n     */\n    get: function get() {\n      return 'top';\n    }\n    /**\n     * @type {String}\n     */\n  }, {\n    key: \"CLONE_BOTTOM\",\n    get: function get() {\n      return 'bottom';\n    }\n    /**\n     * @type {String}\n     */\n  }, {\n    key: \"CLONE_LEFT\",\n    get: function get() {\n      return 'left';\n    }\n    /**\n     * @type {String}\n     */\n  }, {\n    key: \"CLONE_TOP_LEFT_CORNER\",\n    get: function get() {\n      return 'top_left_corner';\n    }\n    /**\n     * @type {String}\n     */\n  }, {\n    key: \"CLONE_BOTTOM_LEFT_CORNER\",\n    get: function get() {\n      return 'bottom_left_corner';\n    }\n    /**\n     * @type {String}\n     */\n  }, {\n    key: \"CLONE_DEBUG\",\n    get: function get() {\n      return 'debug';\n    }\n    /**\n     * List of all availables clone types\n     *\n     * @type {Array}\n     */\n  }, {\n    key: \"CLONE_TYPES\",\n    get: function get() {\n      return [Overlay.CLONE_TOP, Overlay.CLONE_BOTTOM, Overlay.CLONE_LEFT, Overlay.CLONE_TOP_LEFT_CORNER, Overlay.CLONE_BOTTOM_LEFT_CORNER, Overlay.CLONE_DEBUG];\n    }\n  }]);\n  function Overlay(wotInstance) {\n    _classCallCheck(this, Overlay);\n    defineGetter(this, 'wot', wotInstance, {\n      writable: false\n    });\n    var _this$wot$wtTable = this.wot.wtTable,\n      TABLE = _this$wot$wtTable.TABLE,\n      hider = _this$wot$wtTable.hider,\n      spreader = _this$wot$wtTable.spreader,\n      holder = _this$wot$wtTable.holder,\n      wtRootElement = _this$wot$wtTable.wtRootElement; // legacy support, deprecated in the future\n\n    this.instance = this.wot;\n    this.type = '';\n    this.mainTableScrollableElement = null;\n    this.TABLE = TABLE;\n    this.hider = hider;\n    this.spreader = spreader;\n    this.holder = holder;\n    this.wtRootElement = wtRootElement;\n    this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);\n    this.areElementSizesAdjusted = false;\n    this.updateStateOfRendering();\n  }\n  /**\n   * Update internal state of object with an information about the need of full rendering of the overlay.\n   *\n   * @returns {Boolean} Returns `true` if the state has changed since the last check.\n   */\n\n  _createClass(Overlay, [{\n    key: \"updateStateOfRendering\",\n    value: function updateStateOfRendering() {\n      var previousState = this.needFullRender;\n      this.needFullRender = this.shouldBeRendered();\n      var changed = previousState !== this.needFullRender;\n      if (changed && !this.needFullRender) {\n        this.reset();\n      }\n      return changed;\n    }\n    /**\n     * Checks if overlay should be fully rendered\n     *\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"shouldBeRendered\",\n    value: function shouldBeRendered() {\n      return true;\n    }\n    /**\n     * Update the trimming container.\n     */\n  }, {\n    key: \"updateTrimmingContainer\",\n    value: function updateTrimmingContainer() {\n      this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);\n    }\n    /**\n     * Update the main scrollable element.\n     */\n  }, {\n    key: \"updateMainScrollableElement\",\n    value: function updateMainScrollableElement() {\n      var _this$wot = this.wot,\n        wtTable = _this$wot.wtTable,\n        rootWindow = _this$wot.rootWindow;\n      if (rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue('overflow') === 'hidden') {\n        this.mainTableScrollableElement = this.wot.wtTable.holder;\n      } else {\n        this.mainTableScrollableElement = getScrollableElement(wtTable.TABLE);\n      }\n    }\n    /**\n     * Calculates coordinates of the provided element, relative to the root Handsontable element.\n     * NOTE: The element needs to be a child of the overlay in order for the method to work correctly.\n     *\n     * @param {HTMLElement} element The cell element to calculate the position for.\n     * @param {Number} rowIndex Visual row index.\n     * @param {Number} columnIndex Visual column index.\n     * @returns {{top: Number, left: Number}|undefined}\n     */\n  }, {\n    key: \"getRelativeCellPosition\",\n    value: function getRelativeCellPosition(element, rowIndex, columnIndex) {\n      if (this.clone.wtTable.holder.contains(element) === false) {\n        warn(\"The provided element is not a child of the \".concat(this.type, \" overlay\"));\n        return;\n      }\n      var windowScroll = this.mainTableScrollableElement === this.wot.rootWindow;\n      var fixedColumn = columnIndex < this.wot.getSetting('fixedColumnsLeft');\n      var fixedRowTop = rowIndex < this.wot.getSetting('fixedRowsTop');\n      var fixedRowBottom = rowIndex >= this.wot.getSetting('totalRows') - this.wot.getSetting('fixedRowsBottom');\n      var spreaderOffset = {\n        left: this.clone.wtTable.spreader.offsetLeft,\n        top: this.clone.wtTable.spreader.offsetTop\n      };\n      var elementOffset = {\n        left: element.offsetLeft,\n        top: element.offsetTop\n      };\n      var offsetObject = null;\n      if (windowScroll) {\n        offsetObject = this.getRelativeCellPositionWithinWindow(fixedRowTop, fixedColumn, elementOffset, spreaderOffset);\n      } else {\n        offsetObject = this.getRelativeCellPositionWithinHolder(fixedRowTop, fixedRowBottom, fixedColumn, elementOffset, spreaderOffset);\n      }\n      return offsetObject;\n    }\n    /**\n     * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window\n     * as a scrollable element.\n     *\n     * @private\n     * @param {Boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.\n     * @param {Boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.\n     * @param {Number} elementOffset Offset position of the cell element.\n     * @param {Number} spreaderOffset Offset position of the spreader element.\n     * @returns {{top: Number, left: Number}}\n     */\n  }, {\n    key: \"getRelativeCellPositionWithinWindow\",\n    value: function getRelativeCellPositionWithinWindow(onFixedRowTop, onFixedColumn, elementOffset, spreaderOffset) {\n      var absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect();\n      var horizontalOffset = 0;\n      var verticalOffset = 0;\n      if (!onFixedColumn) {\n        horizontalOffset = spreaderOffset.left;\n      } else {\n        horizontalOffset = absoluteRootElementPosition.left <= 0 ? -1 * absoluteRootElementPosition.left : 0;\n      }\n      if (onFixedRowTop) {\n        var absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect();\n        verticalOffset = absoluteOverlayPosition.top - absoluteRootElementPosition.top;\n      } else {\n        verticalOffset = spreaderOffset.top;\n      }\n      return {\n        left: elementOffset.left + horizontalOffset,\n        top: elementOffset.top + verticalOffset\n      };\n    }\n    /**\n     * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window\n     * as a scrollable element.\n     *\n     * @private\n     * @param {Boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.\n     * @param {Boolean} onFixedRowBottom `true` if the coordinates point to a place within the bottom fixed rows.\n     * @param {Boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.\n     * @param {Number} elementOffset Offset position of the cell element.\n     * @param {Number} spreaderOffset Offset position of the spreader element.\n     * @returns {{top: Number, left: Number}}\n     */\n  }, {\n    key: \"getRelativeCellPositionWithinHolder\",\n    value: function getRelativeCellPositionWithinHolder(onFixedRowTop, onFixedRowBottom, onFixedColumn, elementOffset, spreaderOffset) {\n      var tableScrollPosition = {\n        horizontal: this.clone.cloneSource.wtOverlays.leftOverlay.getScrollPosition(),\n        vertical: this.clone.cloneSource.wtOverlays.topOverlay.getScrollPosition()\n      };\n      var horizontalOffset = 0;\n      var verticalOffset = 0;\n      if (!onFixedColumn) {\n        horizontalOffset = tableScrollPosition.horizontal - spreaderOffset.left;\n      }\n      if (onFixedRowBottom) {\n        var absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect();\n        var absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect();\n        verticalOffset = absoluteOverlayPosition.top * -1 + absoluteRootElementPosition.top;\n      } else if (!onFixedRowTop) {\n        verticalOffset = tableScrollPosition.vertical - spreaderOffset.top;\n      }\n      return {\n        left: elementOffset.left - horizontalOffset,\n        top: elementOffset.top - verticalOffset\n      };\n    }\n    /**\n     * Make a clone of table for overlay\n     *\n     * @param {String} direction Can be `Overlay.CLONE_TOP`, `Overlay.CLONE_LEFT`,\n     *                           `Overlay.CLONE_TOP_LEFT_CORNER`, `Overlay.CLONE_DEBUG`\n     * @returns {Walkontable}\n     */\n  }, {\n    key: \"makeClone\",\n    value: function makeClone(direction) {\n      if (Overlay.CLONE_TYPES.indexOf(direction) === -1) {\n        throw new Error(\"Clone type \\\"\".concat(direction, \"\\\" is not supported.\"));\n      }\n      var _this$wot2 = this.wot,\n        wtTable = _this$wot2.wtTable,\n        rootDocument = _this$wot2.rootDocument,\n        rootWindow = _this$wot2.rootWindow;\n      var clone = rootDocument.createElement('DIV');\n      var clonedTable = rootDocument.createElement('TABLE');\n      clone.className = \"ht_clone_\".concat(direction, \" handsontable\");\n      clone.style.position = 'absolute';\n      clone.style.top = 0;\n      clone.style.left = 0;\n      clone.style.overflow = 'hidden';\n      clonedTable.className = wtTable.TABLE.className;\n      clone.appendChild(clonedTable);\n      this.type = direction;\n      wtTable.wtRootElement.parentNode.appendChild(clone);\n      var preventOverflow = this.wot.getSetting('preventOverflow');\n      if (preventOverflow === true || preventOverflow === 'horizontal' && this.type === Overlay.CLONE_TOP || preventOverflow === 'vertical' && this.type === Overlay.CLONE_LEFT) {\n        this.mainTableScrollableElement = rootWindow;\n      } else if (rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue('overflow') === 'hidden') {\n        this.mainTableScrollableElement = wtTable.holder;\n      } else {\n        this.mainTableScrollableElement = getScrollableElement(wtTable.TABLE);\n      }\n      return new Walkontable({\n        cloneSource: this.wot,\n        cloneOverlay: this,\n        table: clonedTable\n      });\n    }\n    /**\n     * Refresh/Redraw overlay\n     *\n     * @param {Boolean} [fastDraw=false]\n     */\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      // When hot settings are changed we allow to refresh overlay once before blocking\n      var nextCycleRenderFlag = this.shouldBeRendered();\n      if (this.clone && (this.needFullRender || nextCycleRenderFlag)) {\n        this.clone.draw(fastDraw);\n      }\n      this.needFullRender = nextCycleRenderFlag;\n    }\n    /**\n     * Reset overlay styles to initial values.\n     */\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      if (!this.clone) {\n        return;\n      }\n      var holder = this.clone.wtTable.holder;\n      var hider = this.clone.wtTable.hider;\n      var holderStyle = holder.style;\n      var hidderStyle = hider.style;\n      var rootStyle = holder.parentNode.style;\n      arrayEach([holderStyle, hidderStyle, rootStyle], function (style) {\n        style.width = '';\n        style.height = '';\n      });\n    }\n    /**\n     * Destroy overlay instance\n     */\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      new EventManager(this.clone).destroy();\n    }\n  }]);\n  return Overlay;\n}();\nexport default Overlay;","map":{"version":3,"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","getScrollableElement","getTrimmingContainer","defineGetter","arrayEach","warn","EventManager","Walkontable","registeredOverlays","Overlay","value","registerOverlay","type","overlayClass","CLONE_TYPES","indexOf","Error","concat","createOverlay","wot","hasOverlay","isOverlayTypeOf","overlay","get","CLONE_TOP","CLONE_BOTTOM","CLONE_LEFT","CLONE_TOP_LEFT_CORNER","CLONE_BOTTOM_LEFT_CORNER","CLONE_DEBUG","wotInstance","_this$wot$wtTable","wtTable","TABLE","hider","spreader","holder","wtRootElement","mainTableScrollableElement","trimmingContainer","parentNode","areElementSizesAdjusted","updateStateOfRendering","previousState","needFullRender","shouldBeRendered","changed","reset","updateTrimmingContainer","updateMainScrollableElement","_this$wot","rootWindow","getComputedStyle","getPropertyValue","getRelativeCellPosition","element","rowIndex","columnIndex","clone","contains","windowScroll","fixedColumn","getSetting","fixedRowTop","fixedRowBottom","spreaderOffset","left","offsetLeft","top","offsetTop","elementOffset","offsetObject","getRelativeCellPositionWithinWindow","getRelativeCellPositionWithinHolder","onFixedRowTop","onFixedColumn","absoluteRootElementPosition","getBoundingClientRect","horizontalOffset","verticalOffset","absoluteOverlayPosition","onFixedRowBottom","tableScrollPosition","horizontal","cloneSource","wtOverlays","leftOverlay","getScrollPosition","vertical","topOverlay","makeClone","direction","_this$wot2","rootDocument","createElement","clonedTable","className","style","position","overflow","appendChild","preventOverflow","cloneOverlay","table","refresh","fastDraw","arguments","undefined","nextCycleRenderFlag","draw","holderStyle","hidderStyle","rootStyle","width","height","destroy"],"sources":["C:/Users/mrezy/VSCode/internships-master/node_modules/handsontable/es/3rdparty/walkontable/src/overlay/_base.js"],"sourcesContent":["import \"core-js/modules/es.array.index-of\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport { getScrollableElement, getTrimmingContainer } from './../../../../helpers/dom/element';\nimport { defineGetter } from './../../../../helpers/object';\nimport { arrayEach } from './../../../../helpers/array';\nimport { warn } from './../../../../helpers/console';\nimport EventManager from './../../../../eventManager';\nimport Walkontable from './../core';\nvar registeredOverlays = {};\n/**\n * Creates an overlay over the original Walkontable instance. The overlay renders the clone of the original Walkontable\n * and (optionally) implements behavior needed for native horizontal and vertical scrolling.\n *\n * @class Overlay\n */\n\nvar Overlay =\n/*#__PURE__*/\nfunction () {\n  _createClass(Overlay, null, [{\n    key: \"registerOverlay\",\n\n    /**\n     * Register overlay class.\n     *\n     * @param {String} type Overlay type, one of the CLONE_TYPES value\n     * @param {Overlay} overlayClass Overlay class extended from base overlay class {@link Overlay}\n     */\n    value: function registerOverlay(type, overlayClass) {\n      if (Overlay.CLONE_TYPES.indexOf(type) === -1) {\n        throw new Error(\"Unsupported overlay (\".concat(type, \").\"));\n      }\n\n      registeredOverlays[type] = overlayClass;\n    }\n    /**\n     * Create new instance of overlay type.\n     *\n     * @param {String} type Overlay type, one of the CLONE_TYPES value\n     * @param {Walkontable} wot Walkontable instance\n     */\n\n  }, {\n    key: \"createOverlay\",\n    value: function createOverlay(type, wot) {\n      return new registeredOverlays[type](wot);\n    }\n    /**\n     * Check if specified overlay was registered.\n     *\n     * @param {String} type Overlay type, one of the CLONE_TYPES value\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"hasOverlay\",\n    value: function hasOverlay(type) {\n      return registeredOverlays[type] !== void 0;\n    }\n    /**\n     * Checks if overlay object (`overlay`) is instance of overlay type (`type`).\n     *\n     * @param {Overlay} overlay Overlay object\n     * @param {String} type Overlay type, one of the CLONE_TYPES value\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isOverlayTypeOf\",\n    value: function isOverlayTypeOf(overlay, type) {\n      if (!overlay || !registeredOverlays[type]) {\n        return false;\n      }\n\n      return overlay instanceof registeredOverlays[type];\n    }\n    /**\n     * @param {Walkontable} wotInstance\n     */\n\n  }, {\n    key: \"CLONE_TOP\",\n\n    /**\n     * @type {String}\n     */\n    get: function get() {\n      return 'top';\n    }\n    /**\n     * @type {String}\n     */\n\n  }, {\n    key: \"CLONE_BOTTOM\",\n    get: function get() {\n      return 'bottom';\n    }\n    /**\n     * @type {String}\n     */\n\n  }, {\n    key: \"CLONE_LEFT\",\n    get: function get() {\n      return 'left';\n    }\n    /**\n     * @type {String}\n     */\n\n  }, {\n    key: \"CLONE_TOP_LEFT_CORNER\",\n    get: function get() {\n      return 'top_left_corner';\n    }\n    /**\n     * @type {String}\n     */\n\n  }, {\n    key: \"CLONE_BOTTOM_LEFT_CORNER\",\n    get: function get() {\n      return 'bottom_left_corner';\n    }\n    /**\n     * @type {String}\n     */\n\n  }, {\n    key: \"CLONE_DEBUG\",\n    get: function get() {\n      return 'debug';\n    }\n    /**\n     * List of all availables clone types\n     *\n     * @type {Array}\n     */\n\n  }, {\n    key: \"CLONE_TYPES\",\n    get: function get() {\n      return [Overlay.CLONE_TOP, Overlay.CLONE_BOTTOM, Overlay.CLONE_LEFT, Overlay.CLONE_TOP_LEFT_CORNER, Overlay.CLONE_BOTTOM_LEFT_CORNER, Overlay.CLONE_DEBUG];\n    }\n  }]);\n\n  function Overlay(wotInstance) {\n    _classCallCheck(this, Overlay);\n\n    defineGetter(this, 'wot', wotInstance, {\n      writable: false\n    });\n    var _this$wot$wtTable = this.wot.wtTable,\n        TABLE = _this$wot$wtTable.TABLE,\n        hider = _this$wot$wtTable.hider,\n        spreader = _this$wot$wtTable.spreader,\n        holder = _this$wot$wtTable.holder,\n        wtRootElement = _this$wot$wtTable.wtRootElement; // legacy support, deprecated in the future\n\n    this.instance = this.wot;\n    this.type = '';\n    this.mainTableScrollableElement = null;\n    this.TABLE = TABLE;\n    this.hider = hider;\n    this.spreader = spreader;\n    this.holder = holder;\n    this.wtRootElement = wtRootElement;\n    this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);\n    this.areElementSizesAdjusted = false;\n    this.updateStateOfRendering();\n  }\n  /**\n   * Update internal state of object with an information about the need of full rendering of the overlay.\n   *\n   * @returns {Boolean} Returns `true` if the state has changed since the last check.\n   */\n\n\n  _createClass(Overlay, [{\n    key: \"updateStateOfRendering\",\n    value: function updateStateOfRendering() {\n      var previousState = this.needFullRender;\n      this.needFullRender = this.shouldBeRendered();\n      var changed = previousState !== this.needFullRender;\n\n      if (changed && !this.needFullRender) {\n        this.reset();\n      }\n\n      return changed;\n    }\n    /**\n     * Checks if overlay should be fully rendered\n     *\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"shouldBeRendered\",\n    value: function shouldBeRendered() {\n      return true;\n    }\n    /**\n     * Update the trimming container.\n     */\n\n  }, {\n    key: \"updateTrimmingContainer\",\n    value: function updateTrimmingContainer() {\n      this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);\n    }\n    /**\n     * Update the main scrollable element.\n     */\n\n  }, {\n    key: \"updateMainScrollableElement\",\n    value: function updateMainScrollableElement() {\n      var _this$wot = this.wot,\n          wtTable = _this$wot.wtTable,\n          rootWindow = _this$wot.rootWindow;\n\n      if (rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue('overflow') === 'hidden') {\n        this.mainTableScrollableElement = this.wot.wtTable.holder;\n      } else {\n        this.mainTableScrollableElement = getScrollableElement(wtTable.TABLE);\n      }\n    }\n    /**\n     * Calculates coordinates of the provided element, relative to the root Handsontable element.\n     * NOTE: The element needs to be a child of the overlay in order for the method to work correctly.\n     *\n     * @param {HTMLElement} element The cell element to calculate the position for.\n     * @param {Number} rowIndex Visual row index.\n     * @param {Number} columnIndex Visual column index.\n     * @returns {{top: Number, left: Number}|undefined}\n     */\n\n  }, {\n    key: \"getRelativeCellPosition\",\n    value: function getRelativeCellPosition(element, rowIndex, columnIndex) {\n      if (this.clone.wtTable.holder.contains(element) === false) {\n        warn(\"The provided element is not a child of the \".concat(this.type, \" overlay\"));\n        return;\n      }\n\n      var windowScroll = this.mainTableScrollableElement === this.wot.rootWindow;\n      var fixedColumn = columnIndex < this.wot.getSetting('fixedColumnsLeft');\n      var fixedRowTop = rowIndex < this.wot.getSetting('fixedRowsTop');\n      var fixedRowBottom = rowIndex >= this.wot.getSetting('totalRows') - this.wot.getSetting('fixedRowsBottom');\n      var spreaderOffset = {\n        left: this.clone.wtTable.spreader.offsetLeft,\n        top: this.clone.wtTable.spreader.offsetTop\n      };\n      var elementOffset = {\n        left: element.offsetLeft,\n        top: element.offsetTop\n      };\n      var offsetObject = null;\n\n      if (windowScroll) {\n        offsetObject = this.getRelativeCellPositionWithinWindow(fixedRowTop, fixedColumn, elementOffset, spreaderOffset);\n      } else {\n        offsetObject = this.getRelativeCellPositionWithinHolder(fixedRowTop, fixedRowBottom, fixedColumn, elementOffset, spreaderOffset);\n      }\n\n      return offsetObject;\n    }\n    /**\n     * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window\n     * as a scrollable element.\n     *\n     * @private\n     * @param {Boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.\n     * @param {Boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.\n     * @param {Number} elementOffset Offset position of the cell element.\n     * @param {Number} spreaderOffset Offset position of the spreader element.\n     * @returns {{top: Number, left: Number}}\n     */\n\n  }, {\n    key: \"getRelativeCellPositionWithinWindow\",\n    value: function getRelativeCellPositionWithinWindow(onFixedRowTop, onFixedColumn, elementOffset, spreaderOffset) {\n      var absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect();\n      var horizontalOffset = 0;\n      var verticalOffset = 0;\n\n      if (!onFixedColumn) {\n        horizontalOffset = spreaderOffset.left;\n      } else {\n        horizontalOffset = absoluteRootElementPosition.left <= 0 ? -1 * absoluteRootElementPosition.left : 0;\n      }\n\n      if (onFixedRowTop) {\n        var absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect();\n        verticalOffset = absoluteOverlayPosition.top - absoluteRootElementPosition.top;\n      } else {\n        verticalOffset = spreaderOffset.top;\n      }\n\n      return {\n        left: elementOffset.left + horizontalOffset,\n        top: elementOffset.top + verticalOffset\n      };\n    }\n    /**\n     * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window\n     * as a scrollable element.\n     *\n     * @private\n     * @param {Boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.\n     * @param {Boolean} onFixedRowBottom `true` if the coordinates point to a place within the bottom fixed rows.\n     * @param {Boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.\n     * @param {Number} elementOffset Offset position of the cell element.\n     * @param {Number} spreaderOffset Offset position of the spreader element.\n     * @returns {{top: Number, left: Number}}\n     */\n\n  }, {\n    key: \"getRelativeCellPositionWithinHolder\",\n    value: function getRelativeCellPositionWithinHolder(onFixedRowTop, onFixedRowBottom, onFixedColumn, elementOffset, spreaderOffset) {\n      var tableScrollPosition = {\n        horizontal: this.clone.cloneSource.wtOverlays.leftOverlay.getScrollPosition(),\n        vertical: this.clone.cloneSource.wtOverlays.topOverlay.getScrollPosition()\n      };\n      var horizontalOffset = 0;\n      var verticalOffset = 0;\n\n      if (!onFixedColumn) {\n        horizontalOffset = tableScrollPosition.horizontal - spreaderOffset.left;\n      }\n\n      if (onFixedRowBottom) {\n        var absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect();\n        var absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect();\n        verticalOffset = absoluteOverlayPosition.top * -1 + absoluteRootElementPosition.top;\n      } else if (!onFixedRowTop) {\n        verticalOffset = tableScrollPosition.vertical - spreaderOffset.top;\n      }\n\n      return {\n        left: elementOffset.left - horizontalOffset,\n        top: elementOffset.top - verticalOffset\n      };\n    }\n    /**\n     * Make a clone of table for overlay\n     *\n     * @param {String} direction Can be `Overlay.CLONE_TOP`, `Overlay.CLONE_LEFT`,\n     *                           `Overlay.CLONE_TOP_LEFT_CORNER`, `Overlay.CLONE_DEBUG`\n     * @returns {Walkontable}\n     */\n\n  }, {\n    key: \"makeClone\",\n    value: function makeClone(direction) {\n      if (Overlay.CLONE_TYPES.indexOf(direction) === -1) {\n        throw new Error(\"Clone type \\\"\".concat(direction, \"\\\" is not supported.\"));\n      }\n\n      var _this$wot2 = this.wot,\n          wtTable = _this$wot2.wtTable,\n          rootDocument = _this$wot2.rootDocument,\n          rootWindow = _this$wot2.rootWindow;\n      var clone = rootDocument.createElement('DIV');\n      var clonedTable = rootDocument.createElement('TABLE');\n      clone.className = \"ht_clone_\".concat(direction, \" handsontable\");\n      clone.style.position = 'absolute';\n      clone.style.top = 0;\n      clone.style.left = 0;\n      clone.style.overflow = 'hidden';\n      clonedTable.className = wtTable.TABLE.className;\n      clone.appendChild(clonedTable);\n      this.type = direction;\n      wtTable.wtRootElement.parentNode.appendChild(clone);\n      var preventOverflow = this.wot.getSetting('preventOverflow');\n\n      if (preventOverflow === true || preventOverflow === 'horizontal' && this.type === Overlay.CLONE_TOP || preventOverflow === 'vertical' && this.type === Overlay.CLONE_LEFT) {\n        this.mainTableScrollableElement = rootWindow;\n      } else if (rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue('overflow') === 'hidden') {\n        this.mainTableScrollableElement = wtTable.holder;\n      } else {\n        this.mainTableScrollableElement = getScrollableElement(wtTable.TABLE);\n      }\n\n      return new Walkontable({\n        cloneSource: this.wot,\n        cloneOverlay: this,\n        table: clonedTable\n      });\n    }\n    /**\n     * Refresh/Redraw overlay\n     *\n     * @param {Boolean} [fastDraw=false]\n     */\n\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      // When hot settings are changed we allow to refresh overlay once before blocking\n      var nextCycleRenderFlag = this.shouldBeRendered();\n\n      if (this.clone && (this.needFullRender || nextCycleRenderFlag)) {\n        this.clone.draw(fastDraw);\n      }\n\n      this.needFullRender = nextCycleRenderFlag;\n    }\n    /**\n     * Reset overlay styles to initial values.\n     */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      if (!this.clone) {\n        return;\n      }\n\n      var holder = this.clone.wtTable.holder;\n      var hider = this.clone.wtTable.hider;\n      var holderStyle = holder.style;\n      var hidderStyle = hider.style;\n      var rootStyle = holder.parentNode.style;\n      arrayEach([holderStyle, hidderStyle, rootStyle], function (style) {\n        style.width = '';\n        style.height = '';\n      });\n    }\n    /**\n     * Destroy overlay instance\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      new EventManager(this.clone).destroy();\n    }\n  }]);\n\n  return Overlay;\n}();\n\nexport default Overlay;"],"mappings":"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"},"metadata":{},"sourceType":"module"}