{"ast":null,"code":"import \"core-js/modules/es.symbol\";\nimport \"core-js/modules/es.symbol.description\";\nimport \"core-js/modules/es.symbol.iterator\";\nimport \"core-js/modules/es.array.index-of\";\nimport \"core-js/modules/es.array.iterator\";\nimport \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.regexp.to-string\";\nimport \"core-js/modules/es.string.iterator\";\nimport \"core-js/modules/web.dom-collections.iterator\";\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nimport { arrayEach } from '../../helpers/array';\nimport { warn } from '../../helpers/console';\nimport { getTranslator } from '../../utils/recordTranslator';\n/**\n * Class used to make all endpoint-related operations.\n *\n * @class Endpoints\n * @plugin ColumnSummary\n */\n\nvar Endpoints = /*#__PURE__*/\nfunction () {\n  function Endpoints(plugin, settings) {\n    _classCallCheck(this, Endpoints);\n\n    /**\n     * The main plugin instance.\n     */\n    this.plugin = plugin;\n    /**\n     * Handsontable instance.\n     *\n     * @type {Object}\n     */\n\n    this.hot = this.plugin.hot;\n    /**\n     * Array of declared plugin endpoints (calculation destination points).\n     *\n     * @type {Array}\n     * @default {Array} Empty array.\n     */\n\n    this.endpoints = [];\n    /**\n     * The plugin settings, taken from Handsontable configuration.\n     *\n     * @type {Object|Function}\n     * @default null\n     */\n\n    this.settings = settings;\n    /**\n     * Settings type. Can be either 'array' or 'function.\n     *\n     * @type {string}\n     * @default {'array'}\n     */\n\n    this.settingsType = 'array';\n    /**\n     * The current endpoint (calculation destination point) in question.\n     *\n     * @type {Object}\n     * @default null\n     */\n\n    this.currentEndpoint = null;\n    /**\n     * Array containing a list of changes to be applied.\n     *\n     * @private\n     * @type {Array}\n     * @default {[]}\n     */\n\n    this.cellsToSetCache = [];\n    /**\n     * A `recordTranslator` instance.\n     * @private\n     * @type {Object}\n     */\n\n    this.recordTranslator = getTranslator(this.hot);\n  }\n  /**\n   * Get a single endpoint object.\n   *\n   * @param {Number} index Index of the endpoint.\n   * @returns {Object}\n   */\n\n  _createClass(Endpoints, [{\n    key: \"getEndpoint\",\n    value: function getEndpoint(index) {\n      if (this.settingsType === 'function') {\n        return this.fillMissingEndpointData(this.settings)[index];\n      }\n      return this.endpoints[index];\n    }\n    /**\n     * Get an array with all the endpoints.\n     *\n     * @returns {Array}\n     */\n  }, {\n    key: \"getAllEndpoints\",\n    value: function getAllEndpoints() {\n      if (this.settingsType === 'function') {\n        return this.fillMissingEndpointData(this.settings);\n      }\n      return this.endpoints;\n    }\n    /**\n     * Used to fill the blanks in the endpoint data provided by a settings function.\n     *\n     * @private\n     * @param {Function} func Function provided in the HOT settings.\n     * @returns {Array} An array of endpoints.\n     */\n  }, {\n    key: \"fillMissingEndpointData\",\n    value: function fillMissingEndpointData(func) {\n      return this.parseSettings(func.call(this));\n    }\n    /**\n     * Parse plugin's settings.\n     *\n     * @param {Array} settings The settings array.\n     */\n  }, {\n    key: \"parseSettings\",\n    value: function parseSettings(settings) {\n      var _this = this;\n      var endpointsArray = [];\n      var settingsArray = settings;\n      if (!settingsArray && typeof this.settings === 'function') {\n        this.settingsType = 'function';\n        return;\n      }\n      if (!settingsArray) {\n        settingsArray = this.settings;\n      }\n      arrayEach(settingsArray, function (val) {\n        var newEndpoint = {};\n        _this.assignSetting(val, newEndpoint, 'ranges', [[0, _this.hot.countRows() - 1]]);\n        _this.assignSetting(val, newEndpoint, 'reversedRowCoords', false);\n        _this.assignSetting(val, newEndpoint, 'destinationRow', new Error(\"\\n        You must provide a destination row for the Column Summary plugin in order to work properly!\\n      \"));\n        _this.assignSetting(val, newEndpoint, 'destinationColumn', new Error(\"\\n        You must provide a destination column for the Column Summary plugin in order to work properly!\\n      \"));\n        _this.assignSetting(val, newEndpoint, 'sourceColumn', val.destinationColumn);\n        _this.assignSetting(val, newEndpoint, 'type', 'sum');\n        _this.assignSetting(val, newEndpoint, 'forceNumeric', false);\n        _this.assignSetting(val, newEndpoint, 'suppressDataTypeErrors', true);\n        _this.assignSetting(val, newEndpoint, 'suppressDataTypeErrors', true);\n        _this.assignSetting(val, newEndpoint, 'customFunction', null);\n        _this.assignSetting(val, newEndpoint, 'readOnly', true);\n        _this.assignSetting(val, newEndpoint, 'roundFloat', false);\n        endpointsArray.push(newEndpoint);\n      });\n      return endpointsArray;\n    }\n    /**\n     * Setter for the internal setting objects.\n     *\n     * @param {Object} settings Object with the settings.\n     * @param {Object} endpoint Contains information about the endpoint for the the calculation.\n     * @param {String} name Settings name.\n     * @param defaultValue Default value for the settings.\n     */\n  }, {\n    key: \"assignSetting\",\n    value: function assignSetting(settings, endpoint, name, defaultValue) {\n      if (name === 'ranges' && settings[name] === void 0) {\n        endpoint[name] = defaultValue;\n        return;\n      } else if (name === 'ranges' && settings[name].length === 0) {\n        return;\n      }\n      if (settings[name] === void 0) {\n        if (defaultValue instanceof Error) {\n          throw defaultValue;\n        }\n        endpoint[name] = defaultValue;\n      } else {\n        /* eslint-disable no-lonely-if */\n        if (name === 'destinationRow' && endpoint.reversedRowCoords) {\n          endpoint[name] = this.hot.countRows() - settings[name] - 1;\n        } else {\n          endpoint[name] = settings[name];\n        }\n      }\n    }\n    /**\n     * Resets the endpoint setup before the structure alteration (like inserting or removing rows/columns). Used for settings provided as a function.\n     *\n     * @private\n     * @param {String} action Type of the action performed.\n     * @param {Number} index Row/column index.\n     * @param {Number} number Number of rows/columns added/removed.\n     */\n  }, {\n    key: \"resetSetupBeforeStructureAlteration\",\n    value: function resetSetupBeforeStructureAlteration(action, index, number) {\n      if (this.settingsType !== 'function') {\n        return;\n      }\n      var type = action.indexOf('row') > -1 ? 'row' : 'col';\n      var endpoints = this.getAllEndpoints();\n      arrayEach(endpoints, function (val) {\n        if (type === 'row' && val.destinationRow >= index) {\n          if (action === 'insert_row') {\n            val.alterRowOffset = number;\n          } else if (action === 'remove_row') {\n            val.alterRowOffset = -1 * number;\n          }\n        }\n        if (type === 'col' && val.destinationColumn >= index) {\n          if (action === 'insert_col') {\n            val.alterColumnOffset = number;\n          } else if (action === 'remove_col') {\n            val.alterColumnOffset = -1 * number;\n          }\n        }\n      });\n      this.resetAllEndpoints(endpoints, false);\n    }\n    /**\n     * afterCreateRow/afterCreateRow/afterRemoveRow/afterRemoveCol hook callback. Reset and reenables the summary functionality\n     * after changing the table structure.\n     *\n     * @private\n     * @param {String} action Type of the action performed.\n     * @param {Number} index Row/column index.\n     * @param {Number} number Number of rows/columns added/removed.\n     * @param {Array} [logicRows] Array of the logical indexes.\n     * @param {String} [source] Source of change.\n     * @param {Boolean} [forceRefresh] `true` of the endpoints should refresh after completing the function.\n     */\n  }, {\n    key: \"resetSetupAfterStructureAlteration\",\n    value: function resetSetupAfterStructureAlteration(action, index, number, logicRows, source) {\n      var _this2 = this;\n      var forceRefresh = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n      if (this.settingsType === 'function') {\n        // We need to run it on a next avaiable hook, because the TrimRows' `afterCreateRow` hook triggers after this one,\n        // and it needs to be run to properly calculate the endpoint value.\n        var beforeRenderCallback = function beforeRenderCallback() {\n          _this2.hot.removeHook('beforeRender', beforeRenderCallback);\n          return _this2.refreshAllEndpoints();\n        };\n        this.hot.addHookOnce('beforeRender', beforeRenderCallback);\n        return;\n      }\n      var type = action.indexOf('row') > -1 ? 'row' : 'col';\n      var multiplier = action.indexOf('remove') > -1 ? -1 : 1;\n      var endpoints = this.getAllEndpoints();\n      var rowMoving = action.indexOf('move_row') === 0;\n      var placeOfAlteration = index;\n      arrayEach(endpoints, function (val) {\n        if (type === 'row' && val.destinationRow >= placeOfAlteration) {\n          val.alterRowOffset = multiplier * number;\n        }\n        if (type === 'col' && val.destinationColumn >= placeOfAlteration) {\n          val.alterColumnOffset = multiplier * number;\n        }\n      });\n      this.resetAllEndpoints(endpoints, !rowMoving);\n      if (rowMoving) {\n        arrayEach(endpoints, function (endpoint) {\n          _this2.extendEndpointRanges(endpoint, placeOfAlteration, logicRows[0], logicRows.length);\n          _this2.recreatePhysicalRanges(endpoint);\n          _this2.clearOffsetInformation(endpoint);\n        });\n      } else {\n        arrayEach(endpoints, function (endpoint) {\n          _this2.shiftEndpointCoordinates(endpoint, placeOfAlteration);\n        });\n      }\n      if (forceRefresh) {\n        this.refreshAllEndpoints();\n      }\n    }\n    /**\n     * Clear the offset information from the endpoint object.\n     *\n     * @private\n     * @param {Object} endpoint And endpoint object.\n     */\n  }, {\n    key: \"clearOffsetInformation\",\n    value: function clearOffsetInformation(endpoint) {\n      endpoint.alterRowOffset = void 0;\n      endpoint.alterColumnOffset = void 0;\n    }\n    /**\n     * Extend the row ranges for the provided endpoint.\n     *\n     * @private\n     * @param {Object} endpoint The endpoint object.\n     * @param {Number} placeOfAlteration Index of the row where the alteration takes place.\n     * @param {Number} previousPosition Previous endpoint result position.\n     * @param {Number} offset Offset generated by the alteration.\n     */\n  }, {\n    key: \"extendEndpointRanges\",\n    value: function extendEndpointRanges(endpoint, placeOfAlteration, previousPosition, offset) {\n      arrayEach(endpoint.ranges, function (range) {\n        // is a range, not a single row\n        if (range[1]) {\n          if (placeOfAlteration >= range[0] && placeOfAlteration <= range[1]) {\n            if (previousPosition > range[1]) {\n              range[1] += offset;\n            } else if (previousPosition < range[0]) {\n              range[0] -= offset;\n            }\n          } else if (previousPosition >= range[0] && previousPosition <= range[1]) {\n            range[1] -= offset;\n            if (placeOfAlteration <= range[0]) {\n              range[0] += 1;\n              range[1] += 1;\n            }\n          }\n        }\n      });\n    }\n    /**\n     * Recreate the physical ranges for the provided endpoint. Used (for example) when a row gets moved and extends an existing range.\n     *\n     * @private\n     * @param {Object} endpoint An endpoint object.\n     */\n  }, {\n    key: \"recreatePhysicalRanges\",\n    value: function recreatePhysicalRanges(endpoint) {\n      var _this3 = this;\n      var ranges = endpoint.ranges;\n      var newRanges = [];\n      var allIndexes = [];\n      arrayEach(ranges, function (range) {\n        var newRange = [];\n        if (range[1]) {\n          for (var i = range[0]; i <= range[1]; i++) {\n            newRange.push(_this3.recordTranslator.toPhysicalRow(i));\n          }\n        } else {\n          newRange.push(_this3.recordTranslator.toPhysicalRow(range[0]));\n        }\n        allIndexes.push(newRange);\n      });\n      arrayEach(allIndexes, function (range) {\n        var newRange = [];\n        arrayEach(range, function (coord, index) {\n          if (index === 0) {\n            newRange.push(coord);\n          } else if (range[index] !== range[index - 1] + 1) {\n            newRange.push(range[index - 1]);\n            newRanges.push(newRange);\n            newRange = [];\n            newRange.push(coord);\n          }\n          if (index === range.length - 1) {\n            newRange.push(coord);\n            newRanges.push(newRange);\n          }\n        });\n      });\n      endpoint.ranges = newRanges;\n    }\n    /**\n     * Shifts the endpoint coordinates by the defined offset.\n     *\n     * @private\n     * @param {Object} endpoint Endpoint object.\n     * @param {Number} offsetStartIndex Index of the performed change (if the change is located after the endpoint, nothing about the endpoint has to be changed.\n     */\n  }, {\n    key: \"shiftEndpointCoordinates\",\n    value: function shiftEndpointCoordinates(endpoint, offsetStartIndex) {\n      if (endpoint.alterRowOffset && endpoint.alterRowOffset !== 0) {\n        endpoint.destinationRow += endpoint.alterRowOffset || 0;\n        arrayEach(endpoint.ranges, function (element) {\n          arrayEach(element, function (subElement, j) {\n            if (subElement >= offsetStartIndex) {\n              element[j] += endpoint.alterRowOffset || 0;\n            }\n          });\n        });\n      } else if (endpoint.alterColumnOffset && endpoint.alterColumnOffset !== 0) {\n        endpoint.destinationColumn += endpoint.alterColumnOffset || 0;\n        endpoint.sourceColumn += endpoint.alterColumnOffset || 0;\n      }\n    }\n    /**\n     * Resets (removes) the endpoints from the table.\n     *\n     * @param {Array} endpoints Array containing the endpoints.\n     * @param {Boolean} [useOffset=true] Use the cell offset value.\n     */\n  }, {\n    key: \"resetAllEndpoints\",\n    value: function resetAllEndpoints(endpoints) {\n      var _this4 = this;\n      var useOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var endpointsArray = endpoints;\n      this.cellsToSetCache = [];\n      if (!endpointsArray) {\n        endpointsArray = this.getAllEndpoints();\n      }\n      arrayEach(endpointsArray, function (value) {\n        _this4.resetEndpointValue(value, useOffset);\n      });\n      this.hot.setDataAtCell(this.cellsToSetCache, 'ColumnSummary.reset');\n      this.cellsToSetCache = [];\n    }\n    /**\n     * Calculate and refresh all defined endpoints.\n     */\n  }, {\n    key: \"refreshAllEndpoints\",\n    value: function refreshAllEndpoints() {\n      var _this5 = this;\n      this.cellsToSetCache = [];\n      arrayEach(this.getAllEndpoints(), function (value) {\n        _this5.currentEndpoint = value;\n        _this5.plugin.calculate(value);\n        _this5.setEndpointValue(value, 'init');\n      });\n      this.currentEndpoint = null;\n      this.hot.setDataAtCell(this.cellsToSetCache, 'ColumnSummary.reset');\n      this.cellsToSetCache = [];\n    }\n    /**\n     * Calculate and refresh endpoints only in the changed columns.\n     *\n     * @param {Array} changes Array of changes from the `afterChange` hook.\n     */\n  }, {\n    key: \"refreshChangedEndpoints\",\n    value: function refreshChangedEndpoints(changes) {\n      var _this6 = this;\n      var needToRefresh = [];\n      this.cellsToSetCache = [];\n      arrayEach(changes, function (value, key, changesObj) {\n        // if nothing changed, dont update anything\n        if (\"\".concat(value[2] || '') === \"\".concat(value[3])) {\n          return;\n        }\n        arrayEach(_this6.getAllEndpoints(), function (endpoint, j) {\n          if (_this6.hot.propToCol(changesObj[key][1]) === endpoint.sourceColumn && needToRefresh.indexOf(j) === -1) {\n            needToRefresh.push(j);\n          }\n        });\n      });\n      arrayEach(needToRefresh, function (value) {\n        _this6.refreshEndpoint(_this6.getEndpoint(value));\n      });\n      this.hot.setDataAtCell(this.cellsToSetCache, 'ColumnSummary.reset');\n      this.cellsToSetCache = [];\n    }\n    /**\n     * Calculate and refresh a single endpoint.\n     *\n     * @param {Object} endpoint Contains the endpoint information.\n     */\n  }, {\n    key: \"refreshEndpoint\",\n    value: function refreshEndpoint(endpoint) {\n      this.currentEndpoint = endpoint;\n      this.plugin.calculate(endpoint);\n      this.setEndpointValue(endpoint);\n      this.currentEndpoint = null;\n    }\n    /**\n     * Reset the endpoint value.\n     *\n     * @param {Object} endpoint Contains the endpoint information.\n     * @param {Boolean} [useOffset=true] Use the cell offset value.\n     */\n  }, {\n    key: \"resetEndpointValue\",\n    value: function resetEndpointValue(endpoint) {\n      var useOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var alterRowOffset = endpoint.alterRowOffset || 0;\n      var alterColOffset = endpoint.alterColumnOffset || 0;\n      var _this$recordTranslato = this.recordTranslator.toVisual(endpoint.destinationRow, endpoint.destinationColumn),\n        _this$recordTranslato2 = _slicedToArray(_this$recordTranslato, 2),\n        visualRowIndex = _this$recordTranslato2[0],\n        visualColumnIndex = _this$recordTranslato2[1]; // Clear the meta on the \"old\" indexes\n\n      var cellMeta = this.hot.getCellMeta(visualRowIndex, visualColumnIndex);\n      cellMeta.readOnly = false;\n      cellMeta.className = '';\n      this.cellsToSetCache.push([this.recordTranslator.toVisualRow(endpoint.destinationRow + (useOffset ? alterRowOffset : 0)), this.recordTranslator.toVisualColumn(endpoint.destinationColumn + (useOffset ? alterColOffset : 0)), '']);\n    }\n    /**\n     * Set the endpoint value.\n     *\n     * @param {Object} endpoint Contains the endpoint information.\n     * @param {String} [source] Source of the call information.\n     * @param {Boolean} [render=false] `true` if it needs to render the table afterwards.\n     */\n  }, {\n    key: \"setEndpointValue\",\n    value: function setEndpointValue(endpoint, source) {\n      var render = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      // We'll need the reversed offset values, because cellMeta will be shifted AGAIN afterwards.\n      var reverseRowOffset = -1 * endpoint.alterRowOffset || 0;\n      var reverseColOffset = -1 * endpoint.alterColumnOffset || 0;\n      var visualEndpointRowIndex = this.getVisualRowIndex(endpoint.destinationRow);\n      var cellMeta = this.hot.getCellMeta(this.getVisualRowIndex(endpoint.destinationRow + reverseRowOffset), endpoint.destinationColumn + reverseColOffset);\n      if (visualEndpointRowIndex > this.hot.countRows() || endpoint.destinationColumn > this.hot.countCols()) {\n        this.throwOutOfBoundsWarning();\n        return;\n      }\n      if (source === 'init' || cellMeta.readOnly !== endpoint.readOnly) {\n        cellMeta.readOnly = endpoint.readOnly;\n        cellMeta.className = 'columnSummaryResult';\n      }\n      if (endpoint.roundFloat && !isNaN(endpoint.result)) {\n        endpoint.result = endpoint.result.toFixed(endpoint.roundFloat);\n      }\n      if (render) {\n        this.hot.setDataAtCell(visualEndpointRowIndex, endpoint.destinationColumn, endpoint.result, 'ColumnSummary.set');\n      } else {\n        this.cellsToSetCache.push([visualEndpointRowIndex, endpoint.destinationColumn, endpoint.result]);\n      }\n      endpoint.alterRowOffset = void 0;\n      endpoint.alterColumnOffset = void 0;\n    }\n    /**\n     * Get the visual row index for the provided row. Uses the `umodifyRow` hook.\n     *\n     * @private\n     * @param {Number} row Row index.\n     * @returns {Number}\n     */\n  }, {\n    key: \"getVisualRowIndex\",\n    value: function getVisualRowIndex(row) {\n      return this.hot.runHooks('unmodifyRow', row, 'columnSummary');\n    }\n    /**\n     * Get the visual column index for the provided column. Uses the `umodifyColumn` hook.\n     *\n     * @private\n     * @param {Number} column Column index.\n     * @returns {Number}\n     */\n  }, {\n    key: \"getVisualColumnIndex\",\n    value: function getVisualColumnIndex(column) {\n      return this.hot.runHooks('unmodifyCol', column, 'columnSummary');\n    }\n    /**\n     * Throw an error for the calculation range being out of boundaries.\n     *\n     * @private\n     */\n  }, {\n    key: \"throwOutOfBoundsWarning\",\n    value: function throwOutOfBoundsWarning() {\n      warn('One of the  Column Summary plugins\\' destination points you provided is beyond the table boundaries!');\n    }\n  }]);\n  return Endpoints;\n}();\nexport default Endpoints;","map":{"version":3,"names":["_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","TypeError","Symbol","iterator","Object","prototype","toString","call","_arr","_n","_d","_e","undefined","_i","_s","next","done","push","value","length","err","Array","isArray","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","arrayEach","warn","getTranslator","Endpoints","plugin","settings","hot","endpoints","settingsType","currentEndpoint","cellsToSetCache","recordTranslator","getEndpoint","index","fillMissingEndpointData","getAllEndpoints","func","parseSettings","_this","endpointsArray","settingsArray","val","newEndpoint","assignSetting","countRows","Error","destinationColumn","endpoint","name","defaultValue","reversedRowCoords","resetSetupBeforeStructureAlteration","action","number","type","indexOf","destinationRow","alterRowOffset","alterColumnOffset","resetAllEndpoints","resetSetupAfterStructureAlteration","logicRows","source","_this2","forceRefresh","arguments","beforeRenderCallback","removeHook","refreshAllEndpoints","addHookOnce","multiplier","rowMoving","placeOfAlteration","extendEndpointRanges","recreatePhysicalRanges","clearOffsetInformation","shiftEndpointCoordinates","previousPosition","offset","ranges","range","_this3","newRanges","allIndexes","newRange","toPhysicalRow","coord","offsetStartIndex","element","subElement","j","sourceColumn","_this4","useOffset","resetEndpointValue","setDataAtCell","_this5","calculate","setEndpointValue","refreshChangedEndpoints","changes","_this6","needToRefresh","changesObj","concat","propToCol","refreshEndpoint","alterColOffset","_this$recordTranslato","toVisual","_this$recordTranslato2","visualRowIndex","visualColumnIndex","cellMeta","getCellMeta","readOnly","className","toVisualRow","toVisualColumn","render","reverseRowOffset","reverseColOffset","visualEndpointRowIndex","getVisualRowIndex","countCols","throwOutOfBoundsWarning","roundFloat","isNaN","result","toFixed","row","runHooks","getVisualColumnIndex","column"],"sources":["C:/Users/mrezy/VSCode/internships-master/node_modules/handsontable/es/plugins/columnSummary/endpoints.js"],"sourcesContent":["import \"core-js/modules/es.symbol\";\nimport \"core-js/modules/es.symbol.description\";\nimport \"core-js/modules/es.symbol.iterator\";\nimport \"core-js/modules/es.array.index-of\";\nimport \"core-js/modules/es.array.iterator\";\nimport \"core-js/modules/es.number.to-fixed\";\nimport \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.regexp.to-string\";\nimport \"core-js/modules/es.string.iterator\";\nimport \"core-js/modules/web.dom-collections.iterator\";\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport { arrayEach } from '../../helpers/array';\nimport { warn } from '../../helpers/console';\nimport { getTranslator } from '../../utils/recordTranslator';\n/**\n * Class used to make all endpoint-related operations.\n *\n * @class Endpoints\n * @plugin ColumnSummary\n */\n\nvar Endpoints =\n/*#__PURE__*/\nfunction () {\n  function Endpoints(plugin, settings) {\n    _classCallCheck(this, Endpoints);\n\n    /**\n     * The main plugin instance.\n     */\n    this.plugin = plugin;\n    /**\n     * Handsontable instance.\n     *\n     * @type {Object}\n     */\n\n    this.hot = this.plugin.hot;\n    /**\n     * Array of declared plugin endpoints (calculation destination points).\n     *\n     * @type {Array}\n     * @default {Array} Empty array.\n     */\n\n    this.endpoints = [];\n    /**\n     * The plugin settings, taken from Handsontable configuration.\n     *\n     * @type {Object|Function}\n     * @default null\n     */\n\n    this.settings = settings;\n    /**\n     * Settings type. Can be either 'array' or 'function.\n     *\n     * @type {string}\n     * @default {'array'}\n     */\n\n    this.settingsType = 'array';\n    /**\n     * The current endpoint (calculation destination point) in question.\n     *\n     * @type {Object}\n     * @default null\n     */\n\n    this.currentEndpoint = null;\n    /**\n     * Array containing a list of changes to be applied.\n     *\n     * @private\n     * @type {Array}\n     * @default {[]}\n     */\n\n    this.cellsToSetCache = [];\n    /**\n     * A `recordTranslator` instance.\n     * @private\n     * @type {Object}\n     */\n\n    this.recordTranslator = getTranslator(this.hot);\n  }\n  /**\n   * Get a single endpoint object.\n   *\n   * @param {Number} index Index of the endpoint.\n   * @returns {Object}\n   */\n\n\n  _createClass(Endpoints, [{\n    key: \"getEndpoint\",\n    value: function getEndpoint(index) {\n      if (this.settingsType === 'function') {\n        return this.fillMissingEndpointData(this.settings)[index];\n      }\n\n      return this.endpoints[index];\n    }\n    /**\n     * Get an array with all the endpoints.\n     *\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getAllEndpoints\",\n    value: function getAllEndpoints() {\n      if (this.settingsType === 'function') {\n        return this.fillMissingEndpointData(this.settings);\n      }\n\n      return this.endpoints;\n    }\n    /**\n     * Used to fill the blanks in the endpoint data provided by a settings function.\n     *\n     * @private\n     * @param {Function} func Function provided in the HOT settings.\n     * @returns {Array} An array of endpoints.\n     */\n\n  }, {\n    key: \"fillMissingEndpointData\",\n    value: function fillMissingEndpointData(func) {\n      return this.parseSettings(func.call(this));\n    }\n    /**\n     * Parse plugin's settings.\n     *\n     * @param {Array} settings The settings array.\n     */\n\n  }, {\n    key: \"parseSettings\",\n    value: function parseSettings(settings) {\n      var _this = this;\n\n      var endpointsArray = [];\n      var settingsArray = settings;\n\n      if (!settingsArray && typeof this.settings === 'function') {\n        this.settingsType = 'function';\n        return;\n      }\n\n      if (!settingsArray) {\n        settingsArray = this.settings;\n      }\n\n      arrayEach(settingsArray, function (val) {\n        var newEndpoint = {};\n\n        _this.assignSetting(val, newEndpoint, 'ranges', [[0, _this.hot.countRows() - 1]]);\n\n        _this.assignSetting(val, newEndpoint, 'reversedRowCoords', false);\n\n        _this.assignSetting(val, newEndpoint, 'destinationRow', new Error(\"\\n        You must provide a destination row for the Column Summary plugin in order to work properly!\\n      \"));\n\n        _this.assignSetting(val, newEndpoint, 'destinationColumn', new Error(\"\\n        You must provide a destination column for the Column Summary plugin in order to work properly!\\n      \"));\n\n        _this.assignSetting(val, newEndpoint, 'sourceColumn', val.destinationColumn);\n\n        _this.assignSetting(val, newEndpoint, 'type', 'sum');\n\n        _this.assignSetting(val, newEndpoint, 'forceNumeric', false);\n\n        _this.assignSetting(val, newEndpoint, 'suppressDataTypeErrors', true);\n\n        _this.assignSetting(val, newEndpoint, 'suppressDataTypeErrors', true);\n\n        _this.assignSetting(val, newEndpoint, 'customFunction', null);\n\n        _this.assignSetting(val, newEndpoint, 'readOnly', true);\n\n        _this.assignSetting(val, newEndpoint, 'roundFloat', false);\n\n        endpointsArray.push(newEndpoint);\n      });\n      return endpointsArray;\n    }\n    /**\n     * Setter for the internal setting objects.\n     *\n     * @param {Object} settings Object with the settings.\n     * @param {Object} endpoint Contains information about the endpoint for the the calculation.\n     * @param {String} name Settings name.\n     * @param defaultValue Default value for the settings.\n     */\n\n  }, {\n    key: \"assignSetting\",\n    value: function assignSetting(settings, endpoint, name, defaultValue) {\n      if (name === 'ranges' && settings[name] === void 0) {\n        endpoint[name] = defaultValue;\n        return;\n      } else if (name === 'ranges' && settings[name].length === 0) {\n        return;\n      }\n\n      if (settings[name] === void 0) {\n        if (defaultValue instanceof Error) {\n          throw defaultValue;\n        }\n\n        endpoint[name] = defaultValue;\n      } else {\n        /* eslint-disable no-lonely-if */\n        if (name === 'destinationRow' && endpoint.reversedRowCoords) {\n          endpoint[name] = this.hot.countRows() - settings[name] - 1;\n        } else {\n          endpoint[name] = settings[name];\n        }\n      }\n    }\n    /**\n     * Resets the endpoint setup before the structure alteration (like inserting or removing rows/columns). Used for settings provided as a function.\n     *\n     * @private\n     * @param {String} action Type of the action performed.\n     * @param {Number} index Row/column index.\n     * @param {Number} number Number of rows/columns added/removed.\n     */\n\n  }, {\n    key: \"resetSetupBeforeStructureAlteration\",\n    value: function resetSetupBeforeStructureAlteration(action, index, number) {\n      if (this.settingsType !== 'function') {\n        return;\n      }\n\n      var type = action.indexOf('row') > -1 ? 'row' : 'col';\n      var endpoints = this.getAllEndpoints();\n      arrayEach(endpoints, function (val) {\n        if (type === 'row' && val.destinationRow >= index) {\n          if (action === 'insert_row') {\n            val.alterRowOffset = number;\n          } else if (action === 'remove_row') {\n            val.alterRowOffset = -1 * number;\n          }\n        }\n\n        if (type === 'col' && val.destinationColumn >= index) {\n          if (action === 'insert_col') {\n            val.alterColumnOffset = number;\n          } else if (action === 'remove_col') {\n            val.alterColumnOffset = -1 * number;\n          }\n        }\n      });\n      this.resetAllEndpoints(endpoints, false);\n    }\n    /**\n     * afterCreateRow/afterCreateRow/afterRemoveRow/afterRemoveCol hook callback. Reset and reenables the summary functionality\n     * after changing the table structure.\n     *\n     * @private\n     * @param {String} action Type of the action performed.\n     * @param {Number} index Row/column index.\n     * @param {Number} number Number of rows/columns added/removed.\n     * @param {Array} [logicRows] Array of the logical indexes.\n     * @param {String} [source] Source of change.\n     * @param {Boolean} [forceRefresh] `true` of the endpoints should refresh after completing the function.\n     */\n\n  }, {\n    key: \"resetSetupAfterStructureAlteration\",\n    value: function resetSetupAfterStructureAlteration(action, index, number, logicRows, source) {\n      var _this2 = this;\n\n      var forceRefresh = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n\n      if (this.settingsType === 'function') {\n        // We need to run it on a next avaiable hook, because the TrimRows' `afterCreateRow` hook triggers after this one,\n        // and it needs to be run to properly calculate the endpoint value.\n        var beforeRenderCallback = function beforeRenderCallback() {\n          _this2.hot.removeHook('beforeRender', beforeRenderCallback);\n\n          return _this2.refreshAllEndpoints();\n        };\n\n        this.hot.addHookOnce('beforeRender', beforeRenderCallback);\n        return;\n      }\n\n      var type = action.indexOf('row') > -1 ? 'row' : 'col';\n      var multiplier = action.indexOf('remove') > -1 ? -1 : 1;\n      var endpoints = this.getAllEndpoints();\n      var rowMoving = action.indexOf('move_row') === 0;\n      var placeOfAlteration = index;\n      arrayEach(endpoints, function (val) {\n        if (type === 'row' && val.destinationRow >= placeOfAlteration) {\n          val.alterRowOffset = multiplier * number;\n        }\n\n        if (type === 'col' && val.destinationColumn >= placeOfAlteration) {\n          val.alterColumnOffset = multiplier * number;\n        }\n      });\n      this.resetAllEndpoints(endpoints, !rowMoving);\n\n      if (rowMoving) {\n        arrayEach(endpoints, function (endpoint) {\n          _this2.extendEndpointRanges(endpoint, placeOfAlteration, logicRows[0], logicRows.length);\n\n          _this2.recreatePhysicalRanges(endpoint);\n\n          _this2.clearOffsetInformation(endpoint);\n        });\n      } else {\n        arrayEach(endpoints, function (endpoint) {\n          _this2.shiftEndpointCoordinates(endpoint, placeOfAlteration);\n        });\n      }\n\n      if (forceRefresh) {\n        this.refreshAllEndpoints();\n      }\n    }\n    /**\n     * Clear the offset information from the endpoint object.\n     *\n     * @private\n     * @param {Object} endpoint And endpoint object.\n     */\n\n  }, {\n    key: \"clearOffsetInformation\",\n    value: function clearOffsetInformation(endpoint) {\n      endpoint.alterRowOffset = void 0;\n      endpoint.alterColumnOffset = void 0;\n    }\n    /**\n     * Extend the row ranges for the provided endpoint.\n     *\n     * @private\n     * @param {Object} endpoint The endpoint object.\n     * @param {Number} placeOfAlteration Index of the row where the alteration takes place.\n     * @param {Number} previousPosition Previous endpoint result position.\n     * @param {Number} offset Offset generated by the alteration.\n     */\n\n  }, {\n    key: \"extendEndpointRanges\",\n    value: function extendEndpointRanges(endpoint, placeOfAlteration, previousPosition, offset) {\n      arrayEach(endpoint.ranges, function (range) {\n        // is a range, not a single row\n        if (range[1]) {\n          if (placeOfAlteration >= range[0] && placeOfAlteration <= range[1]) {\n            if (previousPosition > range[1]) {\n              range[1] += offset;\n            } else if (previousPosition < range[0]) {\n              range[0] -= offset;\n            }\n          } else if (previousPosition >= range[0] && previousPosition <= range[1]) {\n            range[1] -= offset;\n\n            if (placeOfAlteration <= range[0]) {\n              range[0] += 1;\n              range[1] += 1;\n            }\n          }\n        }\n      });\n    }\n    /**\n     * Recreate the physical ranges for the provided endpoint. Used (for example) when a row gets moved and extends an existing range.\n     *\n     * @private\n     * @param {Object} endpoint An endpoint object.\n     */\n\n  }, {\n    key: \"recreatePhysicalRanges\",\n    value: function recreatePhysicalRanges(endpoint) {\n      var _this3 = this;\n\n      var ranges = endpoint.ranges;\n      var newRanges = [];\n      var allIndexes = [];\n      arrayEach(ranges, function (range) {\n        var newRange = [];\n\n        if (range[1]) {\n          for (var i = range[0]; i <= range[1]; i++) {\n            newRange.push(_this3.recordTranslator.toPhysicalRow(i));\n          }\n        } else {\n          newRange.push(_this3.recordTranslator.toPhysicalRow(range[0]));\n        }\n\n        allIndexes.push(newRange);\n      });\n      arrayEach(allIndexes, function (range) {\n        var newRange = [];\n        arrayEach(range, function (coord, index) {\n          if (index === 0) {\n            newRange.push(coord);\n          } else if (range[index] !== range[index - 1] + 1) {\n            newRange.push(range[index - 1]);\n            newRanges.push(newRange);\n            newRange = [];\n            newRange.push(coord);\n          }\n\n          if (index === range.length - 1) {\n            newRange.push(coord);\n            newRanges.push(newRange);\n          }\n        });\n      });\n      endpoint.ranges = newRanges;\n    }\n    /**\n     * Shifts the endpoint coordinates by the defined offset.\n     *\n     * @private\n     * @param {Object} endpoint Endpoint object.\n     * @param {Number} offsetStartIndex Index of the performed change (if the change is located after the endpoint, nothing about the endpoint has to be changed.\n     */\n\n  }, {\n    key: \"shiftEndpointCoordinates\",\n    value: function shiftEndpointCoordinates(endpoint, offsetStartIndex) {\n      if (endpoint.alterRowOffset && endpoint.alterRowOffset !== 0) {\n        endpoint.destinationRow += endpoint.alterRowOffset || 0;\n        arrayEach(endpoint.ranges, function (element) {\n          arrayEach(element, function (subElement, j) {\n            if (subElement >= offsetStartIndex) {\n              element[j] += endpoint.alterRowOffset || 0;\n            }\n          });\n        });\n      } else if (endpoint.alterColumnOffset && endpoint.alterColumnOffset !== 0) {\n        endpoint.destinationColumn += endpoint.alterColumnOffset || 0;\n        endpoint.sourceColumn += endpoint.alterColumnOffset || 0;\n      }\n    }\n    /**\n     * Resets (removes) the endpoints from the table.\n     *\n     * @param {Array} endpoints Array containing the endpoints.\n     * @param {Boolean} [useOffset=true] Use the cell offset value.\n     */\n\n  }, {\n    key: \"resetAllEndpoints\",\n    value: function resetAllEndpoints(endpoints) {\n      var _this4 = this;\n\n      var useOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var endpointsArray = endpoints;\n      this.cellsToSetCache = [];\n\n      if (!endpointsArray) {\n        endpointsArray = this.getAllEndpoints();\n      }\n\n      arrayEach(endpointsArray, function (value) {\n        _this4.resetEndpointValue(value, useOffset);\n      });\n      this.hot.setDataAtCell(this.cellsToSetCache, 'ColumnSummary.reset');\n      this.cellsToSetCache = [];\n    }\n    /**\n     * Calculate and refresh all defined endpoints.\n     */\n\n  }, {\n    key: \"refreshAllEndpoints\",\n    value: function refreshAllEndpoints() {\n      var _this5 = this;\n\n      this.cellsToSetCache = [];\n      arrayEach(this.getAllEndpoints(), function (value) {\n        _this5.currentEndpoint = value;\n\n        _this5.plugin.calculate(value);\n\n        _this5.setEndpointValue(value, 'init');\n      });\n      this.currentEndpoint = null;\n      this.hot.setDataAtCell(this.cellsToSetCache, 'ColumnSummary.reset');\n      this.cellsToSetCache = [];\n    }\n    /**\n     * Calculate and refresh endpoints only in the changed columns.\n     *\n     * @param {Array} changes Array of changes from the `afterChange` hook.\n     */\n\n  }, {\n    key: \"refreshChangedEndpoints\",\n    value: function refreshChangedEndpoints(changes) {\n      var _this6 = this;\n\n      var needToRefresh = [];\n      this.cellsToSetCache = [];\n      arrayEach(changes, function (value, key, changesObj) {\n        // if nothing changed, dont update anything\n        if (\"\".concat(value[2] || '') === \"\".concat(value[3])) {\n          return;\n        }\n\n        arrayEach(_this6.getAllEndpoints(), function (endpoint, j) {\n          if (_this6.hot.propToCol(changesObj[key][1]) === endpoint.sourceColumn && needToRefresh.indexOf(j) === -1) {\n            needToRefresh.push(j);\n          }\n        });\n      });\n      arrayEach(needToRefresh, function (value) {\n        _this6.refreshEndpoint(_this6.getEndpoint(value));\n      });\n      this.hot.setDataAtCell(this.cellsToSetCache, 'ColumnSummary.reset');\n      this.cellsToSetCache = [];\n    }\n    /**\n     * Calculate and refresh a single endpoint.\n     *\n     * @param {Object} endpoint Contains the endpoint information.\n     */\n\n  }, {\n    key: \"refreshEndpoint\",\n    value: function refreshEndpoint(endpoint) {\n      this.currentEndpoint = endpoint;\n      this.plugin.calculate(endpoint);\n      this.setEndpointValue(endpoint);\n      this.currentEndpoint = null;\n    }\n    /**\n     * Reset the endpoint value.\n     *\n     * @param {Object} endpoint Contains the endpoint information.\n     * @param {Boolean} [useOffset=true] Use the cell offset value.\n     */\n\n  }, {\n    key: \"resetEndpointValue\",\n    value: function resetEndpointValue(endpoint) {\n      var useOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var alterRowOffset = endpoint.alterRowOffset || 0;\n      var alterColOffset = endpoint.alterColumnOffset || 0;\n\n      var _this$recordTranslato = this.recordTranslator.toVisual(endpoint.destinationRow, endpoint.destinationColumn),\n          _this$recordTranslato2 = _slicedToArray(_this$recordTranslato, 2),\n          visualRowIndex = _this$recordTranslato2[0],\n          visualColumnIndex = _this$recordTranslato2[1]; // Clear the meta on the \"old\" indexes\n\n\n      var cellMeta = this.hot.getCellMeta(visualRowIndex, visualColumnIndex);\n      cellMeta.readOnly = false;\n      cellMeta.className = '';\n      this.cellsToSetCache.push([this.recordTranslator.toVisualRow(endpoint.destinationRow + (useOffset ? alterRowOffset : 0)), this.recordTranslator.toVisualColumn(endpoint.destinationColumn + (useOffset ? alterColOffset : 0)), '']);\n    }\n    /**\n     * Set the endpoint value.\n     *\n     * @param {Object} endpoint Contains the endpoint information.\n     * @param {String} [source] Source of the call information.\n     * @param {Boolean} [render=false] `true` if it needs to render the table afterwards.\n     */\n\n  }, {\n    key: \"setEndpointValue\",\n    value: function setEndpointValue(endpoint, source) {\n      var render = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      // We'll need the reversed offset values, because cellMeta will be shifted AGAIN afterwards.\n      var reverseRowOffset = -1 * endpoint.alterRowOffset || 0;\n      var reverseColOffset = -1 * endpoint.alterColumnOffset || 0;\n      var visualEndpointRowIndex = this.getVisualRowIndex(endpoint.destinationRow);\n      var cellMeta = this.hot.getCellMeta(this.getVisualRowIndex(endpoint.destinationRow + reverseRowOffset), endpoint.destinationColumn + reverseColOffset);\n\n      if (visualEndpointRowIndex > this.hot.countRows() || endpoint.destinationColumn > this.hot.countCols()) {\n        this.throwOutOfBoundsWarning();\n        return;\n      }\n\n      if (source === 'init' || cellMeta.readOnly !== endpoint.readOnly) {\n        cellMeta.readOnly = endpoint.readOnly;\n        cellMeta.className = 'columnSummaryResult';\n      }\n\n      if (endpoint.roundFloat && !isNaN(endpoint.result)) {\n        endpoint.result = endpoint.result.toFixed(endpoint.roundFloat);\n      }\n\n      if (render) {\n        this.hot.setDataAtCell(visualEndpointRowIndex, endpoint.destinationColumn, endpoint.result, 'ColumnSummary.set');\n      } else {\n        this.cellsToSetCache.push([visualEndpointRowIndex, endpoint.destinationColumn, endpoint.result]);\n      }\n\n      endpoint.alterRowOffset = void 0;\n      endpoint.alterColumnOffset = void 0;\n    }\n    /**\n     * Get the visual row index for the provided row. Uses the `umodifyRow` hook.\n     *\n     * @private\n     * @param {Number} row Row index.\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"getVisualRowIndex\",\n    value: function getVisualRowIndex(row) {\n      return this.hot.runHooks('unmodifyRow', row, 'columnSummary');\n    }\n    /**\n     * Get the visual column index for the provided column. Uses the `umodifyColumn` hook.\n     *\n     * @private\n     * @param {Number} column Column index.\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"getVisualColumnIndex\",\n    value: function getVisualColumnIndex(column) {\n      return this.hot.runHooks('unmodifyCol', column, 'columnSummary');\n    }\n    /**\n     * Throw an error for the calculation range being out of boundaries.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"throwOutOfBoundsWarning\",\n    value: function throwOutOfBoundsWarning() {\n      warn('One of the  Column Summary plugins\\' destination points you provided is beyond the table boundaries!');\n    }\n  }]);\n\n  return Endpoints;\n}();\n\nexport default Endpoints;"],"mappings":"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"},"metadata":{},"sourceType":"module"}