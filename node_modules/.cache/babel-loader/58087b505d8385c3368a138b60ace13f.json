{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nimport SheetClip from './../lib/SheetClip/SheetClip';\nimport { cellMethodLookupFactory } from './helpers/data';\nimport { columnFactory } from './helpers/setting';\nimport { createObjectPropListener, deepClone, deepExtend, deepObjectSize, duckSchema, hasOwnProperty, isObject, objectEach } from './helpers/object';\nimport { extendArray, to2dArray } from './helpers/array';\nimport Interval from './utils/interval';\nimport { rangeEach } from './helpers/number';\nvar copyableLookup = cellMethodLookupFactory('copyable', false);\n/**\n * Utility class that gets and saves data from/to the data source using mapping of columns numbers to object property names\n * @todo refactor arguments of methods getRange, getText to be numbers (not objects)\n * @todo remove priv, GridSettings from object constructor\n *\n * @util\n * @class DataMap\n * @private\n */\n\nvar DataMap = /*#__PURE__*/\nfunction () {\n  _createClass(DataMap, null, [{\n    key: \"DESTINATION_RENDERER\",\n    /**\n     * @type {Number}\n     */\n    get: function get() {\n      return 1;\n    }\n    /**\n     * @type {Number}\n     */\n  }, {\n    key: \"DESTINATION_CLIPBOARD_GENERATOR\",\n    get: function get() {\n      return 2;\n    }\n    /**\n     * @param {Object} instance Instance of Handsontable\n     * @param {*} priv\n     * @param {GridSettings} GridSettings Grid settings\n     */\n  }]);\n\n  function DataMap(instance, priv, GridSettings) {\n    var _this = this;\n    _classCallCheck(this, DataMap);\n\n    /**\n     * Instance of {@link Handsontable}\n     *\n     * @private\n     * @type {Handsontable}\n     */\n    this.instance = instance;\n    /**\n     * Private settings object.\n     *\n     * @private\n     * @type {Object}\n     */\n\n    this.priv = priv;\n    /**\n     * Instance of {@link GridSettings}\n     *\n     * @private\n     * @type {GridSettings}\n     */\n\n    this.GridSettings = GridSettings;\n    /**\n     * Reference to the original dataset.\n     *\n     * @type {*}\n     */\n\n    this.dataSource = this.instance.getSettings().data;\n    /**\n     * Cached rows number.\n     *\n     * @type {Number}\n     */\n\n    this.cachedLength = null;\n    /**\n     * Flag determines if the cache should be used.\n     *\n     * @type {Boolean}\n     */\n\n    this.skipCache = false;\n    /**\n     * Cached sourceData rows number.\n     *\n     * @type {Number}\n     */\n\n    this.latestSourceRowsCount = 0;\n    /**\n     * Generated schema based on the first row from the source data.\n     *\n     * @type {Object}\n     */\n\n    this.duckSchema = this.dataSource && this.dataSource[0] ? duckSchema(this.dataSource[0]) : {};\n    /**\n     * Cached array of properties to columns.\n     *\n     * @type {Array}\n     */\n\n    this.colToPropCache = void 0;\n    /**\n     * Cached map of properties to columns.\n     *\n     * @type {Map}\n     */\n\n    this.propToColCache = void 0;\n    this.createMap();\n    /**\n     * Instance of {@link Interval}\n     *\n     * @type {Interval}\n     */\n\n    this.interval = Interval.create(function () {\n      return _this.clearLengthCache();\n    }, '15fps');\n    this.instance.addHook('skipLengthCache', function (delay) {\n      return _this.onSkipLengthCache(delay);\n    });\n    this.onSkipLengthCache(500);\n  }\n  /**\n   * Generates cache for property to and from column addressation.\n   */\n\n  _createClass(DataMap, [{\n    key: \"createMap\",\n    value: function createMap() {\n      var schema = this.getSchema();\n      var i;\n      if (typeof schema === 'undefined') {\n        throw new Error('trying to create `columns` definition but you didn\\'t provide `schema` nor `data`');\n      }\n      this.colToPropCache = [];\n      this.propToColCache = new Map();\n      var columns = this.instance.getSettings().columns;\n      if (columns) {\n        var maxCols = this.instance.getSettings().maxCols;\n        var columnsLen = Math.min(maxCols, columns.length);\n        var filteredIndex = 0;\n        var columnsAsFunc = false;\n        var schemaLen = deepObjectSize(schema);\n        if (typeof columns === 'function') {\n          columnsLen = schemaLen > 0 ? schemaLen : this.instance.countSourceCols();\n          columnsAsFunc = true;\n        }\n        for (i = 0; i < columnsLen; i++) {\n          var column = columnsAsFunc ? columns(i) : columns[i];\n          if (isObject(column)) {\n            if (typeof column.data !== 'undefined') {\n              var index = columnsAsFunc ? filteredIndex : i;\n              this.colToPropCache[index] = column.data;\n              this.propToColCache.set(column.data, index);\n            }\n            filteredIndex += 1;\n          }\n        }\n      } else {\n        this.recursiveDuckColumns(schema);\n      }\n    }\n    /**\n     * Generates columns' translation cache.\n     *\n     * @param {Object} schema\n     * @param {Number} lastCol\n     * @param {Number} parent\n     * @returns {Number}\n     */\n  }, {\n    key: \"recursiveDuckColumns\",\n    value: function recursiveDuckColumns(schema, lastCol, parent) {\n      var _this2 = this;\n      var lastColumn = lastCol;\n      var propertyParent = parent;\n      var prop;\n      if (typeof lastColumn === 'undefined') {\n        lastColumn = 0;\n        propertyParent = '';\n      }\n      if (_typeof(schema) === 'object' && !Array.isArray(schema)) {\n        objectEach(schema, function (value, key) {\n          if (value === null) {\n            prop = propertyParent + key;\n            _this2.colToPropCache.push(prop);\n            _this2.propToColCache.set(prop, lastColumn);\n            lastColumn += 1;\n          } else {\n            lastColumn = _this2.recursiveDuckColumns(value, lastColumn, \"\".concat(key, \".\"));\n          }\n        });\n      }\n      return lastColumn;\n    }\n    /**\n     * Returns property name that corresponds with the given column index.\n     *\n     * @param {Number} col Visual column index.\n     * @returns {Number} Physical column index.\n     */\n  }, {\n    key: \"colToProp\",\n    value: function colToProp(col) {\n      var physicalColumn = this.instance.toPhysicalColumn(col);\n      if (!isNaN(physicalColumn) && this.colToPropCache && typeof this.colToPropCache[physicalColumn] !== 'undefined') {\n        return this.colToPropCache[physicalColumn];\n      }\n      return physicalColumn;\n    }\n    /**\n     * Translates property into visual column index.\n     *\n     * @param {Object} prop\n     * @fires Hooks#modifyCol\n     * @returns {Number}\n     */\n  }, {\n    key: \"propToCol\",\n    value: function propToCol(prop) {\n      var col;\n      if (typeof this.propToColCache.get(prop) === 'undefined') {\n        col = prop;\n      } else {\n        col = this.propToColCache.get(prop);\n      }\n      col = this.instance.toVisualColumn(col);\n      return col;\n    }\n    /**\n     * Returns data's schema.\n     *\n     * @returns {Object}\n     */\n  }, {\n    key: \"getSchema\",\n    value: function getSchema() {\n      var schema = this.instance.getSettings().dataSchema;\n      if (schema) {\n        if (typeof schema === 'function') {\n          return schema();\n        }\n        return schema;\n      }\n      return this.duckSchema;\n    }\n    /**\n     * Creates row at the bottom of the data array.\n     *\n     * @param {Number} [index] Physical index of the row before which the new row will be inserted.\n     * @param {Number} [amount=1] An amount of rows to add.\n     * @param {String} [source] Source of method call.\n     * @fires Hooks#afterCreateRow\n     * @returns {Number} Returns number of created rows.\n     */\n  }, {\n    key: \"createRow\",\n    value: function createRow(index) {\n      var _this3 = this;\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var source = arguments.length > 2 ? arguments[2] : undefined;\n      var numberOfCreatedRows = 0;\n      var rowIndex = index;\n      if (typeof rowIndex !== 'number' || rowIndex >= this.instance.countSourceRows()) {\n        rowIndex = this.instance.countSourceRows();\n      }\n      var continueProcess = this.instance.runHooks('beforeCreateRow', rowIndex, amount, source);\n      if (continueProcess === false) {\n        return 0;\n      }\n      var maxRows = this.instance.getSettings().maxRows;\n      var columnCount = this.instance.countCols();\n      var _loop = function _loop() {\n        var row = null;\n        if (_this3.instance.dataType === 'array') {\n          if (_this3.instance.getSettings().dataSchema) {\n            // Clone template array\n            row = deepClone(_this3.getSchema());\n          } else {\n            row = [];\n            /* eslint-disable no-loop-func */\n\n            rangeEach(columnCount - 1, function () {\n              return row.push(null);\n            });\n          }\n        } else if (_this3.instance.dataType === 'function') {\n          row = _this3.instance.getSettings().dataSchema(rowIndex);\n        } else {\n          row = {};\n          deepExtend(row, _this3.getSchema());\n        }\n        if (rowIndex === _this3.instance.countSourceRows()) {\n          _this3.dataSource.push(row);\n        } else {\n          _this3.spliceData(rowIndex, 0, row);\n        }\n        numberOfCreatedRows += 1;\n      };\n      while (numberOfCreatedRows < amount && this.instance.countSourceRows() < maxRows) {\n        _loop();\n      }\n      this.instance.runHooks('afterCreateRow', rowIndex, numberOfCreatedRows, source);\n      this.instance.forceFullRender = true; // used when data was changed\n\n      return numberOfCreatedRows;\n    }\n    /**\n     * Creates column at the right of the data array.\n     *\n     * @param {Number} [index] Visual index of the column before which the new column will be inserted\n     * @param {Number} [amount=1] An amount of columns to add.\n     * @param {String} [source] Source of method call.\n     * @fires Hooks#afterCreateCol\n     * @returns {Number} Returns number of created columns\n     */\n  }, {\n    key: \"createCol\",\n    value: function createCol(index) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var source = arguments.length > 2 ? arguments[2] : undefined;\n      if (!this.instance.isColumnModificationAllowed()) {\n        throw new Error('Cannot create new column. When data source in an object, ' + 'you can only have as much columns as defined in first data row, data schema or in the \\'columns\\' setting.' + 'If you want to be able to add new columns, you have to use array datasource.');\n      }\n      var rlen = this.instance.countSourceRows();\n      var data = this.dataSource;\n      var countColumns = this.instance.countCols();\n      var columnIndex = typeof index !== 'number' || index >= countColumns ? countColumns : index;\n      var numberOfCreatedCols = 0;\n      var currentIndex;\n      var continueProcess = this.instance.runHooks('beforeCreateCol', columnIndex, amount, source);\n      if (continueProcess === false) {\n        return 0;\n      }\n      currentIndex = columnIndex;\n      var maxCols = this.instance.getSettings().maxCols;\n      while (numberOfCreatedCols < amount && this.instance.countCols() < maxCols) {\n        var _constructor = columnFactory(this.GridSettings, this.priv.columnsSettingConflicts);\n        if (typeof columnIndex !== 'number' || columnIndex >= this.instance.countCols()) {\n          if (rlen > 0) {\n            for (var r = 0; r < rlen; r++) {\n              if (typeof data[r] === 'undefined') {\n                data[r] = [];\n              }\n              data[r].push(null);\n            }\n          } else {\n            data.push([null]);\n          } // Add new column constructor\n\n          this.priv.columnSettings.push(_constructor);\n        } else {\n          for (var row = 0; row < rlen; row++) {\n            data[row].splice(currentIndex, 0, null);\n          } // Add new column constructor at given index\n\n          this.priv.columnSettings.splice(currentIndex, 0, _constructor);\n        }\n        numberOfCreatedCols += 1;\n        currentIndex += 1;\n      }\n      this.instance.runHooks('afterCreateCol', columnIndex, numberOfCreatedCols, source);\n      this.instance.forceFullRender = true; // used when data was changed\n\n      return numberOfCreatedCols;\n    }\n    /**\n     * Removes row from the data array.\n     *\n     * @param {Number} [index] Visual index of the row to be removed. If not provided, the last row will be removed\n     * @param {Number} [amount=1] Amount of the rows to be removed. If not provided, one row will be removed\n     * @param {String} [source] Source of method call.\n     * @fires Hooks#beforeRemoveRow\n     * @fires Hooks#afterRemoveRow\n     */\n  }, {\n    key: \"removeRow\",\n    value: function removeRow(index) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var source = arguments.length > 2 ? arguments[2] : undefined;\n      var rowIndex = typeof index !== 'number' ? -amount : index;\n      var rowsAmount = this.instance.runHooks('modifyRemovedAmount', amount, rowIndex);\n      var sourceRowsLength = this.instance.countSourceRows();\n      rowIndex = (sourceRowsLength + rowIndex) % sourceRowsLength;\n      var logicRows = this.visualRowsToPhysical(rowIndex, rowsAmount);\n      var actionWasNotCancelled = this.instance.runHooks('beforeRemoveRow', rowIndex, rowsAmount, logicRows, source);\n      if (actionWasNotCancelled === false) {\n        return;\n      }\n      var data = this.dataSource;\n      var newData = this.filterData(rowIndex, rowsAmount);\n      if (newData) {\n        data.length = 0;\n        Array.prototype.push.apply(data, newData);\n      }\n      this.instance.runHooks('afterRemoveRow', rowIndex, rowsAmount, logicRows, source);\n      this.instance.forceFullRender = true; // used when data was changed\n    }\n    /**\n     * Removes column from the data array.\n     *\n     * @param {Number} [index] Visual index of the column to be removed. If not provided, the last column will be removed\n     * @param {Number} [amount=1] Amount of the columns to be removed. If not provided, one column will be removed\n     * @param {String} [source] Source of method call.\n     * @fires Hooks#beforeRemoveCol\n     * @fires Hooks#afterRemoveCol\n     */\n  }, {\n    key: \"removeCol\",\n    value: function removeCol(index) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var source = arguments.length > 2 ? arguments[2] : undefined;\n      if (this.instance.dataType === 'object' || this.instance.getSettings().columns) {\n        throw new Error('cannot remove column with object data source or columns option specified');\n      }\n      var columnIndex = typeof index !== 'number' ? -amount : index;\n      columnIndex = (this.instance.countCols() + columnIndex) % this.instance.countCols();\n      var logicColumns = this.visualColumnsToPhysical(columnIndex, amount);\n      var descendingLogicColumns = logicColumns.slice(0).sort(function (a, b) {\n        return b - a;\n      });\n      var actionWasNotCancelled = this.instance.runHooks('beforeRemoveCol', columnIndex, amount, logicColumns, source);\n      if (actionWasNotCancelled === false) {\n        return;\n      }\n      var isTableUniform = true;\n      var removedColumnsCount = descendingLogicColumns.length;\n      var data = this.dataSource;\n      for (var c = 0; c < removedColumnsCount; c++) {\n        if (isTableUniform && logicColumns[0] !== logicColumns[c] - c) {\n          isTableUniform = false;\n        }\n      }\n      if (isTableUniform) {\n        for (var r = 0, rlen = this.instance.countSourceRows(); r < rlen; r++) {\n          data[r].splice(logicColumns[0], amount);\n        }\n      } else {\n        for (var _r = 0, _rlen = this.instance.countSourceRows(); _r < _rlen; _r++) {\n          for (var _c = 0; _c < removedColumnsCount; _c++) {\n            data[_r].splice(descendingLogicColumns[_c], 1);\n          }\n        }\n        for (var _c2 = 0; _c2 < removedColumnsCount; _c2++) {\n          this.priv.columnSettings.splice(logicColumns[_c2], 1);\n        }\n      }\n      this.instance.runHooks('afterRemoveCol', columnIndex, amount, logicColumns, source);\n      this.instance.forceFullRender = true; // used when data was changed\n    }\n    /**\n     * Add/Removes data from the column.\n     *\n     * @param {Number} col Physical index of column in which do you want to do splice\n     * @param {Number} index Index at which to start changing the array. If negative, will begin that many elements from the end\n     * @param {Number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed\n     * @param {Array} [elements]\n     * @returns {Array} Returns removed portion of columns\n     */\n  }, {\n    key: \"spliceCol\",\n    value: function spliceCol(col, index, amount) {\n      var colData = this.instance.getDataAtCol(col);\n      var removed = colData.slice(index, index + amount);\n      var after = colData.slice(index + amount);\n      for (var _len = arguments.length, elements = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n        elements[_key - 3] = arguments[_key];\n      }\n      extendArray(elements, after);\n      var i = 0;\n      while (i < amount) {\n        elements.push(null); // add null in place of removed elements\n\n        i += 1;\n      }\n      to2dArray(elements);\n      this.instance.populateFromArray(index, col, elements, null, null, 'spliceCol');\n      return removed;\n    }\n    /**\n     * Add/Removes data from the row.\n     *\n     * @param {Number} row Physical index of row in which do you want to do splice\n     * @param {Number} index Index at which to start changing the array. If negative, will begin that many elements from the end.\n     * @param {Number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed.\n     * @param {Array} [elements]\n     * @returns {Array} Returns removed portion of rows\n     */\n  }, {\n    key: \"spliceRow\",\n    value: function spliceRow(row, index, amount) {\n      var rowData = this.instance.getSourceDataAtRow(row);\n      var removed = rowData.slice(index, index + amount);\n      var after = rowData.slice(index + amount);\n      for (var _len2 = arguments.length, elements = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n        elements[_key2 - 3] = arguments[_key2];\n      }\n      extendArray(elements, after);\n      var i = 0;\n      while (i < amount) {\n        elements.push(null); // add null in place of removed elements\n\n        i += 1;\n      }\n      this.instance.populateFromArray(row, index, [elements], null, null, 'spliceRow');\n      return removed;\n    }\n    /**\n     * Add/remove row(s) to/from the data source.\n     *\n     * @param {Number} index Physical index of the element to remove.\n     * @param {Number} amount Number of rows to add/remove.\n     * @param {Object} element Row to add.\n     */\n  }, {\n    key: \"spliceData\",\n    value: function spliceData(index, amount, element) {\n      var continueSplicing = this.instance.runHooks('beforeDataSplice', index, amount, element);\n      if (continueSplicing !== false) {\n        this.dataSource.splice(index, amount, element);\n      }\n    }\n    /**\n     * Filter unwanted data elements from the data source.\n     *\n     * @param {Number} index Visual index of the element to remove.\n     * @param {Number} amount Number of rows to add/remove.\n     * @returns {Array}\n     */\n  }, {\n    key: \"filterData\",\n    value: function filterData(index, amount) {\n      var physicalRows = this.visualRowsToPhysical(index, amount);\n      var continueSplicing = this.instance.runHooks('beforeDataFilter', index, amount, physicalRows);\n      if (continueSplicing !== false) {\n        var newData = this.dataSource.filter(function (row, rowIndex) {\n          return physicalRows.indexOf(rowIndex) === -1;\n        });\n        return newData;\n      }\n    }\n    /**\n     * Returns single value from the data array.\n     *\n     * @param {Number} row Visual row index.\n     * @param {Number} prop\n     * @returns {*}\n     */\n  }, {\n    key: \"get\",\n    value: function get(row, prop) {\n      var physicalRow = this.instance.toPhysicalRow(row);\n      var dataRow = this.dataSource[physicalRow]; // TODO: To remove, use 'modifyData' hook instead (see below)\n\n      var modifiedRowData = this.instance.runHooks('modifyRowData', physicalRow);\n      dataRow = isNaN(modifiedRowData) ? modifiedRowData : dataRow; //\n\n      var value = null; // try to get value under property `prop` (includes dot)\n\n      if (dataRow && dataRow.hasOwnProperty && hasOwnProperty(dataRow, prop)) {\n        value = dataRow[prop];\n      } else if (typeof prop === 'string' && prop.indexOf('.') > -1) {\n        var sliced = prop.split('.');\n        var out = dataRow;\n        if (!out) {\n          return null;\n        }\n        for (var i = 0, ilen = sliced.length; i < ilen; i++) {\n          out = out[sliced[i]];\n          if (typeof out === 'undefined') {\n            return null;\n          }\n        }\n        value = out;\n      } else if (typeof prop === 'function') {\n        /**\n         *  allows for interacting with complex structures, for example\n         *  d3/jQuery getter/setter properties:\n         *\n         *    {columns: [{\n         *      data: function(row, value){\n         *        if(arguments.length === 1){\n         *          return row.property();\n         *        }\n         *        row.property(value);\n         *      }\n         *    }]}\n         */\n        value = prop(this.dataSource.slice(physicalRow, physicalRow + 1)[0]);\n      }\n      if (this.instance.hasHook('modifyData')) {\n        var valueHolder = createObjectPropListener(value);\n        this.instance.runHooks('modifyData', physicalRow, this.propToCol(prop), valueHolder, 'get');\n        if (valueHolder.isTouched()) {\n          value = valueHolder.value;\n        }\n      }\n      return value;\n    }\n    /**\n     * Returns single value from the data array (intended for clipboard copy to an external application).\n     *\n     * @param {Number} row Physical row index.\n     * @param {Number} prop\n     * @returns {String}\n     */\n  }, {\n    key: \"getCopyable\",\n    value: function getCopyable(row, prop) {\n      if (copyableLookup.call(this.instance, row, this.propToCol(prop))) {\n        return this.get(row, prop);\n      }\n      return '';\n    }\n    /**\n     * Saves single value to the data array.\n     *\n     * @param {Number} row Visual row index.\n     * @param {Number} prop\n     * @param {String} value\n     * @param {String} [source] Source of hook runner.\n     */\n  }, {\n    key: \"set\",\n    value: function set(row, prop, value, source) {\n      var physicalRow = this.instance.runHooks('modifyRow', row, source || 'datamapGet');\n      var newValue = value;\n      var dataRow = this.dataSource[physicalRow]; // TODO: To remove, use 'modifyData' hook instead (see below)\n\n      var modifiedRowData = this.instance.runHooks('modifyRowData', physicalRow);\n      dataRow = isNaN(modifiedRowData) ? modifiedRowData : dataRow; //\n\n      if (this.instance.hasHook('modifyData')) {\n        var valueHolder = createObjectPropListener(newValue);\n        this.instance.runHooks('modifyData', physicalRow, this.propToCol(prop), valueHolder, 'set');\n        if (valueHolder.isTouched()) {\n          newValue = valueHolder.value;\n        }\n      } // try to set value under property `prop` (includes dot)\n\n      if (dataRow && dataRow.hasOwnProperty && hasOwnProperty(dataRow, prop)) {\n        dataRow[prop] = newValue;\n      } else if (typeof prop === 'string' && prop.indexOf('.') > -1) {\n        var sliced = prop.split('.');\n        var out = dataRow;\n        var i = 0;\n        var ilen;\n        for (i = 0, ilen = sliced.length - 1; i < ilen; i++) {\n          if (typeof out[sliced[i]] === 'undefined') {\n            out[sliced[i]] = {};\n          }\n          out = out[sliced[i]];\n        }\n        out[sliced[i]] = newValue;\n      } else if (typeof prop === 'function') {\n        /* see the `function` handler in `get` */\n        prop(this.dataSource.slice(physicalRow, physicalRow + 1)[0], newValue);\n      } else {\n        dataRow[prop] = newValue;\n      }\n    }\n    /**\n     * This ridiculous piece of code maps rows Id that are present in table data to those displayed for user.\n     * The trick is, the physical row id (stored in settings.data) is not necessary the same\n     * as the visual (displayed) row id (e.g. when sorting is applied).\n     *\n     * @param {Number} index Visual row index.\n     * @param {Number} amount\n     * @fires Hooks#modifyRow\n     * @returns {Number}\n     */\n  }, {\n    key: \"visualRowsToPhysical\",\n    value: function visualRowsToPhysical(index, amount) {\n      var totalRows = this.instance.countSourceRows();\n      var logicRows = [];\n      var physicRow = (totalRows + index) % totalRows;\n      var rowsToRemove = amount;\n      var row;\n      while (physicRow < totalRows && rowsToRemove) {\n        row = this.instance.toPhysicalRow(physicRow);\n        logicRows.push(row);\n        rowsToRemove -= 1;\n        physicRow += 1;\n      }\n      return logicRows;\n    }\n    /**\n     *\n     * @param index Visual column index.\n     * @param amount\n     * @returns {Array}\n     */\n  }, {\n    key: \"visualColumnsToPhysical\",\n    value: function visualColumnsToPhysical(index, amount) {\n      var totalCols = this.instance.countCols();\n      var visualCols = [];\n      var physicalCol = (totalCols + index) % totalCols;\n      var colsToRemove = amount;\n      while (physicalCol < totalCols && colsToRemove) {\n        var col = this.instance.toPhysicalColumn(physicalCol);\n        visualCols.push(col);\n        colsToRemove -= 1;\n        physicalCol += 1;\n      }\n      return visualCols;\n    }\n    /**\n     * Clears the data array.\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      for (var r = 0; r < this.instance.countSourceRows(); r++) {\n        for (var c = 0; c < this.instance.countCols(); c++) {\n          this.set(r, this.colToProp(c), '');\n        }\n      }\n    }\n    /**\n     * Clear cached data length.\n     */\n  }, {\n    key: \"clearLengthCache\",\n    value: function clearLengthCache() {\n      this.cachedLength = null;\n    }\n    /**\n     * Get data length.\n     *\n     * @returns {Number}\n     */\n  }, {\n    key: \"getLength\",\n    value: function getLength() {\n      var _this4 = this;\n      var maxRowsFromSettings = this.instance.getSettings().maxRows;\n      var maxRows;\n      if (maxRowsFromSettings < 0 || maxRowsFromSettings === 0) {\n        maxRows = 0;\n      } else {\n        maxRows = maxRowsFromSettings || Infinity;\n      }\n      var length = this.instance.countSourceRows();\n      if (this.instance.hasHook('modifyRow')) {\n        var reValidate = this.skipCache;\n        this.interval.start();\n        if (length !== this.latestSourceRowsCount) {\n          reValidate = true;\n        }\n        this.latestSourceRowsCount = length;\n        if (this.cachedLength === null || reValidate) {\n          rangeEach(length - 1, function (row) {\n            var physicalRow = _this4.instance.toPhysicalRow(row);\n            if (physicalRow === null) {\n              length -= 1;\n            }\n          });\n          this.cachedLength = length;\n        } else {\n          length = this.cachedLength;\n        }\n      } else {\n        this.interval.stop();\n      }\n      return Math.min(length, maxRows);\n    }\n    /**\n     * Returns the data array.\n     *\n     * @returns {Array}\n     */\n  }, {\n    key: \"getAll\",\n    value: function getAll() {\n      var start = {\n        row: 0,\n        col: 0\n      };\n      var end = {\n        row: Math.max(this.instance.countSourceRows() - 1, 0),\n        col: Math.max(this.instance.countCols() - 1, 0)\n      };\n      if (start.row - end.row === 0 && !this.instance.countSourceRows()) {\n        return [];\n      }\n      return this.getRange(start, end, DataMap.DESTINATION_RENDERER);\n    }\n    /**\n     * Returns data range as array.\n     *\n     * @param {Object} [start] Start selection position. Visual indexes.\n     * @param {Object} [end] End selection position. Visual indexes.\n     * @param {Number} destination Destination of datamap.get\n     * @returns {Array}\n     */\n  }, {\n    key: \"getRange\",\n    value: function getRange(start, end, destination) {\n      var output = [];\n      var r;\n      var c;\n      var row;\n      var maxRows = this.instance.getSettings().maxRows;\n      var maxCols = this.instance.getSettings().maxCols;\n      if (maxRows === 0 || maxCols === 0) {\n        return [];\n      }\n      var getFn = destination === DataMap.DESTINATION_CLIPBOARD_GENERATOR ? this.getCopyable : this.get;\n      var rlen = Math.min(Math.max(maxRows - 1, 0), Math.max(start.row, end.row));\n      var clen = Math.min(Math.max(maxCols - 1, 0), Math.max(start.col, end.col));\n      for (r = Math.min(start.row, end.row); r <= rlen; r++) {\n        row = [];\n        var physicalRow = this.instance.toPhysicalRow(r);\n        for (c = Math.min(start.col, end.col); c <= clen; c++) {\n          if (physicalRow === null) {\n            break;\n          }\n          row.push(getFn.call(this, r, this.colToProp(c)));\n        }\n        if (physicalRow !== null) {\n          output.push(row);\n        }\n      }\n      return output;\n    }\n    /**\n     * Return data as text (tab separated columns).\n     *\n     * @param {Object} [start] Start selection position. Visual indexes.\n     * @param {Object} [end] End selection position. Visual indexes.\n     * @returns {String}\n     */\n  }, {\n    key: \"getText\",\n    value: function getText(start, end) {\n      return SheetClip.stringify(this.getRange(start, end, DataMap.DESTINATION_RENDERER));\n    }\n    /**\n     * Return data as copyable text (tab separated columns intended for clipboard copy to an external application).\n     *\n     * @param {Object} [start] Start selection position. Visual indexes.\n     * @param {Object} [end] End selection position. Visual indexes.\n     * @returns {String}\n     */\n  }, {\n    key: \"getCopyableText\",\n    value: function getCopyableText(start, end) {\n      return SheetClip.stringify(this.getRange(start, end, DataMap.DESTINATION_CLIPBOARD_GENERATOR));\n    }\n    /**\n     * `skipLengthCache` callback.\n     *\n     * @private\n     * @param {Number} delay Time of the delay in milliseconds.\n     */\n  }, {\n    key: \"onSkipLengthCache\",\n    value: function onSkipLengthCache(delay) {\n      var _this5 = this;\n      this.skipCache = true;\n      setTimeout(function () {\n        _this5.skipCache = false;\n      }, delay);\n    }\n    /**\n     * Destroy instance.\n     */\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.interval.stop();\n      this.interval = null;\n      this.instance = null;\n      this.priv = null;\n      this.GridSettings = null;\n      this.dataSource = null;\n      this.cachedLength = null;\n      this.duckSchema = null;\n      this.colToPropCache.length = 0;\n      this.propToColCache.clear();\n      this.propToColCache = void 0;\n    }\n  }]);\n  return DataMap;\n}();\nexport default DataMap;","map":{"version":3,"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","SheetClip","cellMethodLookupFactory","columnFactory","createObjectPropListener","deepClone","deepExtend","deepObjectSize","duckSchema","hasOwnProperty","isObject","objectEach","extendArray","to2dArray","Interval","rangeEach","copyableLookup","DataMap","get","priv","GridSettings","_this","dataSource","getSettings","data","cachedLength","skipCache","latestSourceRowsCount","colToPropCache","propToColCache","createMap","interval","create","clearLengthCache","addHook","delay","onSkipLengthCache","value","schema","getSchema","Error","Map","columns","maxCols","columnsLen","Math","min","filteredIndex","columnsAsFunc","schemaLen","countSourceCols","column","index","set","recursiveDuckColumns","lastCol","parent","_this2","lastColumn","propertyParent","prop","Array","isArray","push","concat","colToProp","col","physicalColumn","toPhysicalColumn","isNaN","propToCol","toVisualColumn","dataSchema","createRow","_this3","amount","arguments","undefined","source","numberOfCreatedRows","rowIndex","countSourceRows","continueProcess","runHooks","maxRows","columnCount","countCols","_loop","row","dataType","spliceData","forceFullRender","createCol","isColumnModificationAllowed","rlen","countColumns","columnIndex","numberOfCreatedCols","currentIndex","_constructor","columnsSettingConflicts","r","columnSettings","splice","removeRow","rowsAmount","sourceRowsLength","logicRows","visualRowsToPhysical","actionWasNotCancelled","newData","filterData","apply","removeCol","logicColumns","visualColumnsToPhysical","descendingLogicColumns","slice","sort","a","b","isTableUniform","removedColumnsCount","c","_r","_rlen","_c","_c2","spliceCol","colData","getDataAtCol","removed","after","_len","elements","_key","populateFromArray","spliceRow","rowData","getSourceDataAtRow","_len2","_key2","element","continueSplicing","physicalRows","filter","indexOf","physicalRow","toPhysicalRow","dataRow","modifiedRowData","sliced","split","out","ilen","hasHook","valueHolder","isTouched","getCopyable","call","newValue","totalRows","physicRow","rowsToRemove","totalCols","visualCols","physicalCol","colsToRemove","clear","getLength","_this4","maxRowsFromSettings","Infinity","reValidate","start","stop","getAll","end","max","getRange","DESTINATION_RENDERER","destination","output","getFn","DESTINATION_CLIPBOARD_GENERATOR","clen","getText","stringify","getCopyableText","_this5","setTimeout","destroy"],"sources":["C:/Users/mrezy/VSCode/internships-master/node_modules/handsontable/es/dataMap.js"],"sourcesContent":["import \"core-js/modules/es.symbol\";\nimport \"core-js/modules/es.symbol.description\";\nimport \"core-js/modules/es.symbol.iterator\";\nimport \"core-js/modules/es.array.filter\";\nimport \"core-js/modules/es.array.index-of\";\nimport \"core-js/modules/es.array.iterator\";\nimport \"core-js/modules/es.array.slice\";\nimport \"core-js/modules/es.array.sort\";\nimport \"core-js/modules/es.array.splice\";\nimport \"core-js/modules/es.map\";\nimport \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.regexp.exec\";\nimport \"core-js/modules/es.string.iterator\";\nimport \"core-js/modules/es.string.split\";\nimport \"core-js/modules/web.dom-collections.iterator\";\nimport \"core-js/modules/web.timers\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport SheetClip from './../lib/SheetClip/SheetClip';\nimport { cellMethodLookupFactory } from './helpers/data';\nimport { columnFactory } from './helpers/setting';\nimport { createObjectPropListener, deepClone, deepExtend, deepObjectSize, duckSchema, hasOwnProperty, isObject, objectEach } from './helpers/object';\nimport { extendArray, to2dArray } from './helpers/array';\nimport Interval from './utils/interval';\nimport { rangeEach } from './helpers/number';\nvar copyableLookup = cellMethodLookupFactory('copyable', false);\n/**\n * Utility class that gets and saves data from/to the data source using mapping of columns numbers to object property names\n * @todo refactor arguments of methods getRange, getText to be numbers (not objects)\n * @todo remove priv, GridSettings from object constructor\n *\n * @util\n * @class DataMap\n * @private\n */\n\nvar DataMap =\n/*#__PURE__*/\nfunction () {\n  _createClass(DataMap, null, [{\n    key: \"DESTINATION_RENDERER\",\n\n    /**\n     * @type {Number}\n     */\n    get: function get() {\n      return 1;\n    }\n    /**\n     * @type {Number}\n     */\n\n  }, {\n    key: \"DESTINATION_CLIPBOARD_GENERATOR\",\n    get: function get() {\n      return 2;\n    }\n    /**\n     * @param {Object} instance Instance of Handsontable\n     * @param {*} priv\n     * @param {GridSettings} GridSettings Grid settings\n     */\n\n  }]);\n\n  function DataMap(instance, priv, GridSettings) {\n    var _this = this;\n\n    _classCallCheck(this, DataMap);\n\n    /**\n     * Instance of {@link Handsontable}\n     *\n     * @private\n     * @type {Handsontable}\n     */\n    this.instance = instance;\n    /**\n     * Private settings object.\n     *\n     * @private\n     * @type {Object}\n     */\n\n    this.priv = priv;\n    /**\n     * Instance of {@link GridSettings}\n     *\n     * @private\n     * @type {GridSettings}\n     */\n\n    this.GridSettings = GridSettings;\n    /**\n     * Reference to the original dataset.\n     *\n     * @type {*}\n     */\n\n    this.dataSource = this.instance.getSettings().data;\n    /**\n     * Cached rows number.\n     *\n     * @type {Number}\n     */\n\n    this.cachedLength = null;\n    /**\n     * Flag determines if the cache should be used.\n     *\n     * @type {Boolean}\n     */\n\n    this.skipCache = false;\n    /**\n     * Cached sourceData rows number.\n     *\n     * @type {Number}\n     */\n\n    this.latestSourceRowsCount = 0;\n    /**\n     * Generated schema based on the first row from the source data.\n     *\n     * @type {Object}\n     */\n\n    this.duckSchema = this.dataSource && this.dataSource[0] ? duckSchema(this.dataSource[0]) : {};\n    /**\n     * Cached array of properties to columns.\n     *\n     * @type {Array}\n     */\n\n    this.colToPropCache = void 0;\n    /**\n     * Cached map of properties to columns.\n     *\n     * @type {Map}\n     */\n\n    this.propToColCache = void 0;\n    this.createMap();\n    /**\n     * Instance of {@link Interval}\n     *\n     * @type {Interval}\n     */\n\n    this.interval = Interval.create(function () {\n      return _this.clearLengthCache();\n    }, '15fps');\n    this.instance.addHook('skipLengthCache', function (delay) {\n      return _this.onSkipLengthCache(delay);\n    });\n    this.onSkipLengthCache(500);\n  }\n  /**\n   * Generates cache for property to and from column addressation.\n   */\n\n\n  _createClass(DataMap, [{\n    key: \"createMap\",\n    value: function createMap() {\n      var schema = this.getSchema();\n      var i;\n\n      if (typeof schema === 'undefined') {\n        throw new Error('trying to create `columns` definition but you didn\\'t provide `schema` nor `data`');\n      }\n\n      this.colToPropCache = [];\n      this.propToColCache = new Map();\n      var columns = this.instance.getSettings().columns;\n\n      if (columns) {\n        var maxCols = this.instance.getSettings().maxCols;\n        var columnsLen = Math.min(maxCols, columns.length);\n        var filteredIndex = 0;\n        var columnsAsFunc = false;\n        var schemaLen = deepObjectSize(schema);\n\n        if (typeof columns === 'function') {\n          columnsLen = schemaLen > 0 ? schemaLen : this.instance.countSourceCols();\n          columnsAsFunc = true;\n        }\n\n        for (i = 0; i < columnsLen; i++) {\n          var column = columnsAsFunc ? columns(i) : columns[i];\n\n          if (isObject(column)) {\n            if (typeof column.data !== 'undefined') {\n              var index = columnsAsFunc ? filteredIndex : i;\n              this.colToPropCache[index] = column.data;\n              this.propToColCache.set(column.data, index);\n            }\n\n            filteredIndex += 1;\n          }\n        }\n      } else {\n        this.recursiveDuckColumns(schema);\n      }\n    }\n    /**\n     * Generates columns' translation cache.\n     *\n     * @param {Object} schema\n     * @param {Number} lastCol\n     * @param {Number} parent\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"recursiveDuckColumns\",\n    value: function recursiveDuckColumns(schema, lastCol, parent) {\n      var _this2 = this;\n\n      var lastColumn = lastCol;\n      var propertyParent = parent;\n      var prop;\n\n      if (typeof lastColumn === 'undefined') {\n        lastColumn = 0;\n        propertyParent = '';\n      }\n\n      if (_typeof(schema) === 'object' && !Array.isArray(schema)) {\n        objectEach(schema, function (value, key) {\n          if (value === null) {\n            prop = propertyParent + key;\n\n            _this2.colToPropCache.push(prop);\n\n            _this2.propToColCache.set(prop, lastColumn);\n\n            lastColumn += 1;\n          } else {\n            lastColumn = _this2.recursiveDuckColumns(value, lastColumn, \"\".concat(key, \".\"));\n          }\n        });\n      }\n\n      return lastColumn;\n    }\n    /**\n     * Returns property name that corresponds with the given column index.\n     *\n     * @param {Number} col Visual column index.\n     * @returns {Number} Physical column index.\n     */\n\n  }, {\n    key: \"colToProp\",\n    value: function colToProp(col) {\n      var physicalColumn = this.instance.toPhysicalColumn(col);\n\n      if (!isNaN(physicalColumn) && this.colToPropCache && typeof this.colToPropCache[physicalColumn] !== 'undefined') {\n        return this.colToPropCache[physicalColumn];\n      }\n\n      return physicalColumn;\n    }\n    /**\n     * Translates property into visual column index.\n     *\n     * @param {Object} prop\n     * @fires Hooks#modifyCol\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"propToCol\",\n    value: function propToCol(prop) {\n      var col;\n\n      if (typeof this.propToColCache.get(prop) === 'undefined') {\n        col = prop;\n      } else {\n        col = this.propToColCache.get(prop);\n      }\n\n      col = this.instance.toVisualColumn(col);\n      return col;\n    }\n    /**\n     * Returns data's schema.\n     *\n     * @returns {Object}\n     */\n\n  }, {\n    key: \"getSchema\",\n    value: function getSchema() {\n      var schema = this.instance.getSettings().dataSchema;\n\n      if (schema) {\n        if (typeof schema === 'function') {\n          return schema();\n        }\n\n        return schema;\n      }\n\n      return this.duckSchema;\n    }\n    /**\n     * Creates row at the bottom of the data array.\n     *\n     * @param {Number} [index] Physical index of the row before which the new row will be inserted.\n     * @param {Number} [amount=1] An amount of rows to add.\n     * @param {String} [source] Source of method call.\n     * @fires Hooks#afterCreateRow\n     * @returns {Number} Returns number of created rows.\n     */\n\n  }, {\n    key: \"createRow\",\n    value: function createRow(index) {\n      var _this3 = this;\n\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var source = arguments.length > 2 ? arguments[2] : undefined;\n      var numberOfCreatedRows = 0;\n      var rowIndex = index;\n\n      if (typeof rowIndex !== 'number' || rowIndex >= this.instance.countSourceRows()) {\n        rowIndex = this.instance.countSourceRows();\n      }\n\n      var continueProcess = this.instance.runHooks('beforeCreateRow', rowIndex, amount, source);\n\n      if (continueProcess === false) {\n        return 0;\n      }\n\n      var maxRows = this.instance.getSettings().maxRows;\n      var columnCount = this.instance.countCols();\n\n      var _loop = function _loop() {\n        var row = null;\n\n        if (_this3.instance.dataType === 'array') {\n          if (_this3.instance.getSettings().dataSchema) {\n            // Clone template array\n            row = deepClone(_this3.getSchema());\n          } else {\n            row = [];\n            /* eslint-disable no-loop-func */\n\n            rangeEach(columnCount - 1, function () {\n              return row.push(null);\n            });\n          }\n        } else if (_this3.instance.dataType === 'function') {\n          row = _this3.instance.getSettings().dataSchema(rowIndex);\n        } else {\n          row = {};\n          deepExtend(row, _this3.getSchema());\n        }\n\n        if (rowIndex === _this3.instance.countSourceRows()) {\n          _this3.dataSource.push(row);\n        } else {\n          _this3.spliceData(rowIndex, 0, row);\n        }\n\n        numberOfCreatedRows += 1;\n      };\n\n      while (numberOfCreatedRows < amount && this.instance.countSourceRows() < maxRows) {\n        _loop();\n      }\n\n      this.instance.runHooks('afterCreateRow', rowIndex, numberOfCreatedRows, source);\n      this.instance.forceFullRender = true; // used when data was changed\n\n      return numberOfCreatedRows;\n    }\n    /**\n     * Creates column at the right of the data array.\n     *\n     * @param {Number} [index] Visual index of the column before which the new column will be inserted\n     * @param {Number} [amount=1] An amount of columns to add.\n     * @param {String} [source] Source of method call.\n     * @fires Hooks#afterCreateCol\n     * @returns {Number} Returns number of created columns\n     */\n\n  }, {\n    key: \"createCol\",\n    value: function createCol(index) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var source = arguments.length > 2 ? arguments[2] : undefined;\n\n      if (!this.instance.isColumnModificationAllowed()) {\n        throw new Error('Cannot create new column. When data source in an object, ' + 'you can only have as much columns as defined in first data row, data schema or in the \\'columns\\' setting.' + 'If you want to be able to add new columns, you have to use array datasource.');\n      }\n\n      var rlen = this.instance.countSourceRows();\n      var data = this.dataSource;\n      var countColumns = this.instance.countCols();\n      var columnIndex = typeof index !== 'number' || index >= countColumns ? countColumns : index;\n      var numberOfCreatedCols = 0;\n      var currentIndex;\n      var continueProcess = this.instance.runHooks('beforeCreateCol', columnIndex, amount, source);\n\n      if (continueProcess === false) {\n        return 0;\n      }\n\n      currentIndex = columnIndex;\n      var maxCols = this.instance.getSettings().maxCols;\n\n      while (numberOfCreatedCols < amount && this.instance.countCols() < maxCols) {\n        var _constructor = columnFactory(this.GridSettings, this.priv.columnsSettingConflicts);\n\n        if (typeof columnIndex !== 'number' || columnIndex >= this.instance.countCols()) {\n          if (rlen > 0) {\n            for (var r = 0; r < rlen; r++) {\n              if (typeof data[r] === 'undefined') {\n                data[r] = [];\n              }\n\n              data[r].push(null);\n            }\n          } else {\n            data.push([null]);\n          } // Add new column constructor\n\n\n          this.priv.columnSettings.push(_constructor);\n        } else {\n          for (var row = 0; row < rlen; row++) {\n            data[row].splice(currentIndex, 0, null);\n          } // Add new column constructor at given index\n\n\n          this.priv.columnSettings.splice(currentIndex, 0, _constructor);\n        }\n\n        numberOfCreatedCols += 1;\n        currentIndex += 1;\n      }\n\n      this.instance.runHooks('afterCreateCol', columnIndex, numberOfCreatedCols, source);\n      this.instance.forceFullRender = true; // used when data was changed\n\n      return numberOfCreatedCols;\n    }\n    /**\n     * Removes row from the data array.\n     *\n     * @param {Number} [index] Visual index of the row to be removed. If not provided, the last row will be removed\n     * @param {Number} [amount=1] Amount of the rows to be removed. If not provided, one row will be removed\n     * @param {String} [source] Source of method call.\n     * @fires Hooks#beforeRemoveRow\n     * @fires Hooks#afterRemoveRow\n     */\n\n  }, {\n    key: \"removeRow\",\n    value: function removeRow(index) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var source = arguments.length > 2 ? arguments[2] : undefined;\n      var rowIndex = typeof index !== 'number' ? -amount : index;\n      var rowsAmount = this.instance.runHooks('modifyRemovedAmount', amount, rowIndex);\n      var sourceRowsLength = this.instance.countSourceRows();\n      rowIndex = (sourceRowsLength + rowIndex) % sourceRowsLength;\n      var logicRows = this.visualRowsToPhysical(rowIndex, rowsAmount);\n      var actionWasNotCancelled = this.instance.runHooks('beforeRemoveRow', rowIndex, rowsAmount, logicRows, source);\n\n      if (actionWasNotCancelled === false) {\n        return;\n      }\n\n      var data = this.dataSource;\n      var newData = this.filterData(rowIndex, rowsAmount);\n\n      if (newData) {\n        data.length = 0;\n        Array.prototype.push.apply(data, newData);\n      }\n\n      this.instance.runHooks('afterRemoveRow', rowIndex, rowsAmount, logicRows, source);\n      this.instance.forceFullRender = true; // used when data was changed\n    }\n    /**\n     * Removes column from the data array.\n     *\n     * @param {Number} [index] Visual index of the column to be removed. If not provided, the last column will be removed\n     * @param {Number} [amount=1] Amount of the columns to be removed. If not provided, one column will be removed\n     * @param {String} [source] Source of method call.\n     * @fires Hooks#beforeRemoveCol\n     * @fires Hooks#afterRemoveCol\n     */\n\n  }, {\n    key: \"removeCol\",\n    value: function removeCol(index) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var source = arguments.length > 2 ? arguments[2] : undefined;\n\n      if (this.instance.dataType === 'object' || this.instance.getSettings().columns) {\n        throw new Error('cannot remove column with object data source or columns option specified');\n      }\n\n      var columnIndex = typeof index !== 'number' ? -amount : index;\n      columnIndex = (this.instance.countCols() + columnIndex) % this.instance.countCols();\n      var logicColumns = this.visualColumnsToPhysical(columnIndex, amount);\n      var descendingLogicColumns = logicColumns.slice(0).sort(function (a, b) {\n        return b - a;\n      });\n      var actionWasNotCancelled = this.instance.runHooks('beforeRemoveCol', columnIndex, amount, logicColumns, source);\n\n      if (actionWasNotCancelled === false) {\n        return;\n      }\n\n      var isTableUniform = true;\n      var removedColumnsCount = descendingLogicColumns.length;\n      var data = this.dataSource;\n\n      for (var c = 0; c < removedColumnsCount; c++) {\n        if (isTableUniform && logicColumns[0] !== logicColumns[c] - c) {\n          isTableUniform = false;\n        }\n      }\n\n      if (isTableUniform) {\n        for (var r = 0, rlen = this.instance.countSourceRows(); r < rlen; r++) {\n          data[r].splice(logicColumns[0], amount);\n        }\n      } else {\n        for (var _r = 0, _rlen = this.instance.countSourceRows(); _r < _rlen; _r++) {\n          for (var _c = 0; _c < removedColumnsCount; _c++) {\n            data[_r].splice(descendingLogicColumns[_c], 1);\n          }\n        }\n\n        for (var _c2 = 0; _c2 < removedColumnsCount; _c2++) {\n          this.priv.columnSettings.splice(logicColumns[_c2], 1);\n        }\n      }\n\n      this.instance.runHooks('afterRemoveCol', columnIndex, amount, logicColumns, source);\n      this.instance.forceFullRender = true; // used when data was changed\n    }\n    /**\n     * Add/Removes data from the column.\n     *\n     * @param {Number} col Physical index of column in which do you want to do splice\n     * @param {Number} index Index at which to start changing the array. If negative, will begin that many elements from the end\n     * @param {Number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed\n     * @param {Array} [elements]\n     * @returns {Array} Returns removed portion of columns\n     */\n\n  }, {\n    key: \"spliceCol\",\n    value: function spliceCol(col, index, amount) {\n      var colData = this.instance.getDataAtCol(col);\n      var removed = colData.slice(index, index + amount);\n      var after = colData.slice(index + amount);\n\n      for (var _len = arguments.length, elements = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n        elements[_key - 3] = arguments[_key];\n      }\n\n      extendArray(elements, after);\n      var i = 0;\n\n      while (i < amount) {\n        elements.push(null); // add null in place of removed elements\n\n        i += 1;\n      }\n\n      to2dArray(elements);\n      this.instance.populateFromArray(index, col, elements, null, null, 'spliceCol');\n      return removed;\n    }\n    /**\n     * Add/Removes data from the row.\n     *\n     * @param {Number} row Physical index of row in which do you want to do splice\n     * @param {Number} index Index at which to start changing the array. If negative, will begin that many elements from the end.\n     * @param {Number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed.\n     * @param {Array} [elements]\n     * @returns {Array} Returns removed portion of rows\n     */\n\n  }, {\n    key: \"spliceRow\",\n    value: function spliceRow(row, index, amount) {\n      var rowData = this.instance.getSourceDataAtRow(row);\n      var removed = rowData.slice(index, index + amount);\n      var after = rowData.slice(index + amount);\n\n      for (var _len2 = arguments.length, elements = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n        elements[_key2 - 3] = arguments[_key2];\n      }\n\n      extendArray(elements, after);\n      var i = 0;\n\n      while (i < amount) {\n        elements.push(null); // add null in place of removed elements\n\n        i += 1;\n      }\n\n      this.instance.populateFromArray(row, index, [elements], null, null, 'spliceRow');\n      return removed;\n    }\n    /**\n     * Add/remove row(s) to/from the data source.\n     *\n     * @param {Number} index Physical index of the element to remove.\n     * @param {Number} amount Number of rows to add/remove.\n     * @param {Object} element Row to add.\n     */\n\n  }, {\n    key: \"spliceData\",\n    value: function spliceData(index, amount, element) {\n      var continueSplicing = this.instance.runHooks('beforeDataSplice', index, amount, element);\n\n      if (continueSplicing !== false) {\n        this.dataSource.splice(index, amount, element);\n      }\n    }\n    /**\n     * Filter unwanted data elements from the data source.\n     *\n     * @param {Number} index Visual index of the element to remove.\n     * @param {Number} amount Number of rows to add/remove.\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"filterData\",\n    value: function filterData(index, amount) {\n      var physicalRows = this.visualRowsToPhysical(index, amount);\n      var continueSplicing = this.instance.runHooks('beforeDataFilter', index, amount, physicalRows);\n\n      if (continueSplicing !== false) {\n        var newData = this.dataSource.filter(function (row, rowIndex) {\n          return physicalRows.indexOf(rowIndex) === -1;\n        });\n        return newData;\n      }\n    }\n    /**\n     * Returns single value from the data array.\n     *\n     * @param {Number} row Visual row index.\n     * @param {Number} prop\n     * @returns {*}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(row, prop) {\n      var physicalRow = this.instance.toPhysicalRow(row);\n      var dataRow = this.dataSource[physicalRow]; // TODO: To remove, use 'modifyData' hook instead (see below)\n\n      var modifiedRowData = this.instance.runHooks('modifyRowData', physicalRow);\n      dataRow = isNaN(modifiedRowData) ? modifiedRowData : dataRow; //\n\n      var value = null; // try to get value under property `prop` (includes dot)\n\n      if (dataRow && dataRow.hasOwnProperty && hasOwnProperty(dataRow, prop)) {\n        value = dataRow[prop];\n      } else if (typeof prop === 'string' && prop.indexOf('.') > -1) {\n        var sliced = prop.split('.');\n        var out = dataRow;\n\n        if (!out) {\n          return null;\n        }\n\n        for (var i = 0, ilen = sliced.length; i < ilen; i++) {\n          out = out[sliced[i]];\n\n          if (typeof out === 'undefined') {\n            return null;\n          }\n        }\n\n        value = out;\n      } else if (typeof prop === 'function') {\n        /**\n         *  allows for interacting with complex structures, for example\n         *  d3/jQuery getter/setter properties:\n         *\n         *    {columns: [{\n         *      data: function(row, value){\n         *        if(arguments.length === 1){\n         *          return row.property();\n         *        }\n         *        row.property(value);\n         *      }\n         *    }]}\n         */\n        value = prop(this.dataSource.slice(physicalRow, physicalRow + 1)[0]);\n      }\n\n      if (this.instance.hasHook('modifyData')) {\n        var valueHolder = createObjectPropListener(value);\n        this.instance.runHooks('modifyData', physicalRow, this.propToCol(prop), valueHolder, 'get');\n\n        if (valueHolder.isTouched()) {\n          value = valueHolder.value;\n        }\n      }\n\n      return value;\n    }\n    /**\n     * Returns single value from the data array (intended for clipboard copy to an external application).\n     *\n     * @param {Number} row Physical row index.\n     * @param {Number} prop\n     * @returns {String}\n     */\n\n  }, {\n    key: \"getCopyable\",\n    value: function getCopyable(row, prop) {\n      if (copyableLookup.call(this.instance, row, this.propToCol(prop))) {\n        return this.get(row, prop);\n      }\n\n      return '';\n    }\n    /**\n     * Saves single value to the data array.\n     *\n     * @param {Number} row Visual row index.\n     * @param {Number} prop\n     * @param {String} value\n     * @param {String} [source] Source of hook runner.\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(row, prop, value, source) {\n      var physicalRow = this.instance.runHooks('modifyRow', row, source || 'datamapGet');\n      var newValue = value;\n      var dataRow = this.dataSource[physicalRow]; // TODO: To remove, use 'modifyData' hook instead (see below)\n\n      var modifiedRowData = this.instance.runHooks('modifyRowData', physicalRow);\n      dataRow = isNaN(modifiedRowData) ? modifiedRowData : dataRow; //\n\n      if (this.instance.hasHook('modifyData')) {\n        var valueHolder = createObjectPropListener(newValue);\n        this.instance.runHooks('modifyData', physicalRow, this.propToCol(prop), valueHolder, 'set');\n\n        if (valueHolder.isTouched()) {\n          newValue = valueHolder.value;\n        }\n      } // try to set value under property `prop` (includes dot)\n\n\n      if (dataRow && dataRow.hasOwnProperty && hasOwnProperty(dataRow, prop)) {\n        dataRow[prop] = newValue;\n      } else if (typeof prop === 'string' && prop.indexOf('.') > -1) {\n        var sliced = prop.split('.');\n        var out = dataRow;\n        var i = 0;\n        var ilen;\n\n        for (i = 0, ilen = sliced.length - 1; i < ilen; i++) {\n          if (typeof out[sliced[i]] === 'undefined') {\n            out[sliced[i]] = {};\n          }\n\n          out = out[sliced[i]];\n        }\n\n        out[sliced[i]] = newValue;\n      } else if (typeof prop === 'function') {\n        /* see the `function` handler in `get` */\n        prop(this.dataSource.slice(physicalRow, physicalRow + 1)[0], newValue);\n      } else {\n        dataRow[prop] = newValue;\n      }\n    }\n    /**\n     * This ridiculous piece of code maps rows Id that are present in table data to those displayed for user.\n     * The trick is, the physical row id (stored in settings.data) is not necessary the same\n     * as the visual (displayed) row id (e.g. when sorting is applied).\n     *\n     * @param {Number} index Visual row index.\n     * @param {Number} amount\n     * @fires Hooks#modifyRow\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"visualRowsToPhysical\",\n    value: function visualRowsToPhysical(index, amount) {\n      var totalRows = this.instance.countSourceRows();\n      var logicRows = [];\n      var physicRow = (totalRows + index) % totalRows;\n      var rowsToRemove = amount;\n      var row;\n\n      while (physicRow < totalRows && rowsToRemove) {\n        row = this.instance.toPhysicalRow(physicRow);\n        logicRows.push(row);\n        rowsToRemove -= 1;\n        physicRow += 1;\n      }\n\n      return logicRows;\n    }\n    /**\n     *\n     * @param index Visual column index.\n     * @param amount\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"visualColumnsToPhysical\",\n    value: function visualColumnsToPhysical(index, amount) {\n      var totalCols = this.instance.countCols();\n      var visualCols = [];\n      var physicalCol = (totalCols + index) % totalCols;\n      var colsToRemove = amount;\n\n      while (physicalCol < totalCols && colsToRemove) {\n        var col = this.instance.toPhysicalColumn(physicalCol);\n        visualCols.push(col);\n        colsToRemove -= 1;\n        physicalCol += 1;\n      }\n\n      return visualCols;\n    }\n    /**\n     * Clears the data array.\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      for (var r = 0; r < this.instance.countSourceRows(); r++) {\n        for (var c = 0; c < this.instance.countCols(); c++) {\n          this.set(r, this.colToProp(c), '');\n        }\n      }\n    }\n    /**\n     * Clear cached data length.\n     */\n\n  }, {\n    key: \"clearLengthCache\",\n    value: function clearLengthCache() {\n      this.cachedLength = null;\n    }\n    /**\n     * Get data length.\n     *\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"getLength\",\n    value: function getLength() {\n      var _this4 = this;\n\n      var maxRowsFromSettings = this.instance.getSettings().maxRows;\n      var maxRows;\n\n      if (maxRowsFromSettings < 0 || maxRowsFromSettings === 0) {\n        maxRows = 0;\n      } else {\n        maxRows = maxRowsFromSettings || Infinity;\n      }\n\n      var length = this.instance.countSourceRows();\n\n      if (this.instance.hasHook('modifyRow')) {\n        var reValidate = this.skipCache;\n        this.interval.start();\n\n        if (length !== this.latestSourceRowsCount) {\n          reValidate = true;\n        }\n\n        this.latestSourceRowsCount = length;\n\n        if (this.cachedLength === null || reValidate) {\n          rangeEach(length - 1, function (row) {\n            var physicalRow = _this4.instance.toPhysicalRow(row);\n\n            if (physicalRow === null) {\n              length -= 1;\n            }\n          });\n          this.cachedLength = length;\n        } else {\n          length = this.cachedLength;\n        }\n      } else {\n        this.interval.stop();\n      }\n\n      return Math.min(length, maxRows);\n    }\n    /**\n     * Returns the data array.\n     *\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getAll\",\n    value: function getAll() {\n      var start = {\n        row: 0,\n        col: 0\n      };\n      var end = {\n        row: Math.max(this.instance.countSourceRows() - 1, 0),\n        col: Math.max(this.instance.countCols() - 1, 0)\n      };\n\n      if (start.row - end.row === 0 && !this.instance.countSourceRows()) {\n        return [];\n      }\n\n      return this.getRange(start, end, DataMap.DESTINATION_RENDERER);\n    }\n    /**\n     * Returns data range as array.\n     *\n     * @param {Object} [start] Start selection position. Visual indexes.\n     * @param {Object} [end] End selection position. Visual indexes.\n     * @param {Number} destination Destination of datamap.get\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getRange\",\n    value: function getRange(start, end, destination) {\n      var output = [];\n      var r;\n      var c;\n      var row;\n      var maxRows = this.instance.getSettings().maxRows;\n      var maxCols = this.instance.getSettings().maxCols;\n\n      if (maxRows === 0 || maxCols === 0) {\n        return [];\n      }\n\n      var getFn = destination === DataMap.DESTINATION_CLIPBOARD_GENERATOR ? this.getCopyable : this.get;\n      var rlen = Math.min(Math.max(maxRows - 1, 0), Math.max(start.row, end.row));\n      var clen = Math.min(Math.max(maxCols - 1, 0), Math.max(start.col, end.col));\n\n      for (r = Math.min(start.row, end.row); r <= rlen; r++) {\n        row = [];\n        var physicalRow = this.instance.toPhysicalRow(r);\n\n        for (c = Math.min(start.col, end.col); c <= clen; c++) {\n          if (physicalRow === null) {\n            break;\n          }\n\n          row.push(getFn.call(this, r, this.colToProp(c)));\n        }\n\n        if (physicalRow !== null) {\n          output.push(row);\n        }\n      }\n\n      return output;\n    }\n    /**\n     * Return data as text (tab separated columns).\n     *\n     * @param {Object} [start] Start selection position. Visual indexes.\n     * @param {Object} [end] End selection position. Visual indexes.\n     * @returns {String}\n     */\n\n  }, {\n    key: \"getText\",\n    value: function getText(start, end) {\n      return SheetClip.stringify(this.getRange(start, end, DataMap.DESTINATION_RENDERER));\n    }\n    /**\n     * Return data as copyable text (tab separated columns intended for clipboard copy to an external application).\n     *\n     * @param {Object} [start] Start selection position. Visual indexes.\n     * @param {Object} [end] End selection position. Visual indexes.\n     * @returns {String}\n     */\n\n  }, {\n    key: \"getCopyableText\",\n    value: function getCopyableText(start, end) {\n      return SheetClip.stringify(this.getRange(start, end, DataMap.DESTINATION_CLIPBOARD_GENERATOR));\n    }\n    /**\n     * `skipLengthCache` callback.\n     *\n     * @private\n     * @param {Number} delay Time of the delay in milliseconds.\n     */\n\n  }, {\n    key: \"onSkipLengthCache\",\n    value: function onSkipLengthCache(delay) {\n      var _this5 = this;\n\n      this.skipCache = true;\n      setTimeout(function () {\n        _this5.skipCache = false;\n      }, delay);\n    }\n    /**\n     * Destroy instance.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.interval.stop();\n      this.interval = null;\n      this.instance = null;\n      this.priv = null;\n      this.GridSettings = null;\n      this.dataSource = null;\n      this.cachedLength = null;\n      this.duckSchema = null;\n      this.colToPropCache.length = 0;\n      this.propToColCache.clear();\n      this.propToColCache = void 0;\n    }\n  }]);\n\n  return DataMap;\n}();\n\nexport default DataMap;"],"mappings":"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"},"metadata":{},"sourceType":"module"}