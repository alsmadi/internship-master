{"ast":null,"code":"function _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nimport { toLabel as _toLabel, extractLabel, error, ERROR_REF } from 'hot-formula-parser';\nimport { arrayEach, arrayFilter } from '../../helpers/array';\nimport { mixin } from '../../helpers/object';\nimport localHooks from '../../mixins/localHooks';\nimport { toUpperCaseFormula } from './utils';\nvar BARE_CELL_STRICT_REGEX = /^\\$?[A-Z]+\\$?\\d+$/;\nvar BARE_CELL_REGEX = /\\$?[A-Z]+\\$?\\d+/;\nvar CELL_REGEX = /(?:[^0-9A-Z$: ]|^)\\s*(\\$?[A-Z]+\\$?\\d+)\\s*(?![0-9A-Z_: ])/g;\nvar RANGE_REGEX = /\\$?[A-Z]+\\$?\\d+\\s*:\\s*\\$?[A-Z]+\\$?\\d+/g;\nvar CELL_AND_RANGE_REGEX = /((?:[^0-9A-Z$: ]|^)\\s*(\\$?[A-Z]+\\$?\\d+)\\s*(?![0-9A-Z_: ]))|(\\$?[A-Z]+\\$?\\d+\\s*:\\s*\\$?[A-Z]+\\$?\\d+)/g;\n/**\n * Component adds an ability to parse and modify formula expressions. It is designed for translating cell\n * coordinates and cell ranges in any direction. By default, component translates only relative coordinates but this\n * behavior can be overwritten by passing custom modifier which controls translating process.\n *\n * @class ExpressionModifier\n * @util\n */\n\nvar ExpressionModifier = /*#__PURE__*/\nfunction () {\n  function ExpressionModifier(expression) {\n    _classCallCheck(this, ExpressionModifier);\n\n    /**\n     * Formula expression to modify.\n     *\n     * @type {String}\n     */\n    this.expression = '';\n    /**\n     * Extracted cells and cells ranges.\n     *\n     * @type {Array}\n     */\n\n    this.cells = [];\n    /**\n     * Function which can modify default behaviour of how cells and cell ranges will be translated.\n     *\n     * @type {null|Function}\n     */\n\n    this.customModifier = null;\n    if (typeof expression === 'string') {\n      this.setExpression(expression);\n    }\n  }\n  /**\n   * Set formula expression to modify.\n   *\n   * @param {String} expression Formula expression to process.\n   * @returns {ExpressionModifier}\n   */\n\n  _createClass(ExpressionModifier, [{\n    key: \"setExpression\",\n    value: function setExpression(expression) {\n      this.cells.length = 0;\n      this.expression = toUpperCaseFormula(expression);\n      this._extractCells();\n      this._extractCellsRange();\n      return this;\n    }\n    /**\n     * Set function which can modify default behavior of how cells and cell ranges will be translated.\n     * The passed function will be called with 4 arguments:\n     *  - cell, A cell object with structure\n     *            like this: {start: {row, column}, end: {row, column}, origLabel, type: 'cell|range', refError, toLabel: () => {}}\n     *  - axis, Type of currently processing axis ('row' or 'column')\n     *  - delta, Number as distance to translate. Can be positive or negative.\n     *  - startFromIndex, Base index which translation will be applied from.\n     *\n     * the function must return an array with 3 items, where:\n     *  [\n     *    deltaStart, Number as a delta to translate first part of coordinates.\n     *    deltaEnd,   Number as a delta to translate second part of coordinates (if cell range is modified).\n     *    refError,   Defines an error which refers to the situation when translated cell overcrossed the data boundary.\n     *  ]\n     *\n     *\n     * @param {Function} customModifier Function with custom logic.\n     */\n  }, {\n    key: \"useCustomModifier\",\n    value: function useCustomModifier(customModifier) {\n      this.customModifier = customModifier;\n    }\n    /**\n     * Translate formula expression cells.\n     *\n     * @param {Object} delta Distance to move in proper direction.\n     * @param {Object} [startFrom] Coordinates which translation will be applied from.\n     * @returns {ExpressionModifier}\n     */\n  }, {\n    key: \"translate\",\n    value: function translate(_ref) {\n      var _this = this;\n      var deltaRow = _ref.row,\n        deltaColumn = _ref.column;\n      var startFrom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      arrayEach(this.cells, function (cell) {\n        if (deltaRow !== null && deltaRow !== void 0) {\n          _this._translateCell(cell, 'row', deltaRow, startFrom.row);\n        }\n        if (deltaColumn !== null && deltaColumn !== void 0) {\n          _this._translateCell(cell, 'column', deltaColumn, startFrom.column);\n        }\n      });\n      return this;\n    }\n    /**\n     * Translate object into string representation.\n     *\n     * @returns {String}\n     */\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var _this2 = this;\n      var expression = this.expression.replace(CELL_AND_RANGE_REGEX, function (match, p1, p2) {\n        var isSingleCell = match.indexOf(':') === -1;\n        var result = match;\n        var cellLabel = match;\n        var translatedCellLabel = null;\n        if (isSingleCell) {\n          cellLabel = BARE_CELL_STRICT_REGEX.test(p1) ? p1 : p2;\n        }\n        var cell = _this2._searchCell(cellLabel);\n        if (cell) {\n          translatedCellLabel = cell.refError ? error(ERROR_REF) : cell.toLabel();\n          if (isSingleCell) {\n            result = match.replace(cellLabel, translatedCellLabel);\n          } else {\n            result = translatedCellLabel;\n          }\n        }\n        return result;\n      });\n      if (!expression.startsWith('=')) {\n        expression = \"=\".concat(expression);\n      }\n      return expression;\n    }\n    /**\n     * Translate single cell.\n     *\n     * @param {Object} cell Cell object.\n     * @param {String} axis Axis to modify.\n     * @param {Number} delta Distance to move.\n     * @param {Number} [startFromIndex] Base index which translation will be applied from.\n     * @private\n     */\n  }, {\n    key: \"_translateCell\",\n    value: function _translateCell(cell, axis, delta, startFromIndex) {\n      var start = cell.start,\n        end = cell.end;\n      var startIndex = start[axis].index;\n      var endIndex = end[axis].index;\n      var deltaStart = delta;\n      var deltaEnd = delta;\n      var refError = false;\n      if (this.customModifier) {\n        var _this$customModifier = this.customModifier(cell, axis, delta, startFromIndex);\n        var _this$customModifier2 = _slicedToArray(_this$customModifier, 3);\n        deltaStart = _this$customModifier2[0];\n        deltaEnd = _this$customModifier2[1];\n        refError = _this$customModifier2[2];\n      } else {\n        // By default only relative cells are translated, if meets absolute reset deltas to 0\n        if (start[axis].isAbsolute) {\n          deltaStart = 0;\n        }\n        if (end[axis].isAbsolute) {\n          deltaEnd = 0;\n        }\n      }\n      if (deltaStart && !refError) {\n        if (startIndex + deltaStart < 0) {\n          refError = true;\n        }\n        start[axis].index = Math.max(startIndex + deltaStart, 0);\n      }\n      if (deltaEnd && !refError) {\n        if (endIndex + deltaEnd < 0) {\n          refError = true;\n        }\n        end[axis].index = Math.max(endIndex + deltaEnd, 0);\n      }\n      if (refError) {\n        cell.refError = true;\n      }\n    }\n    /**\n     * Extract all cells from the formula expression.\n     *\n     * @private\n     */\n  }, {\n    key: \"_extractCells\",\n    value: function _extractCells() {\n      var _this3 = this;\n      var matches = this.expression.match(CELL_REGEX);\n      if (!matches) {\n        return;\n      }\n      arrayEach(matches, function (coord) {\n        var cellCoords = coord.match(BARE_CELL_REGEX);\n        if (!cellCoords) {\n          return;\n        }\n        var _extractLabel = extractLabel(cellCoords[0]),\n          _extractLabel2 = _slicedToArray(_extractLabel, 2),\n          row = _extractLabel2[0],\n          column = _extractLabel2[1];\n        _this3.cells.push(_this3._createCell({\n          row: row,\n          column: column\n        }, {\n          row: row,\n          column: column\n        }, cellCoords[0]));\n      });\n    }\n    /**\n     * Extract all cells range from the formula expression.\n     *\n     * @private\n     */\n  }, {\n    key: \"_extractCellsRange\",\n    value: function _extractCellsRange() {\n      var _this4 = this;\n      var matches = this.expression.match(RANGE_REGEX);\n      if (!matches) {\n        return;\n      }\n      arrayEach(matches, function (match) {\n        var _match$split = match.split(':'),\n          _match$split2 = _slicedToArray(_match$split, 2),\n          start = _match$split2[0],\n          end = _match$split2[1];\n        var _extractLabel3 = extractLabel(start),\n          _extractLabel4 = _slicedToArray(_extractLabel3, 2),\n          startRow = _extractLabel4[0],\n          startColumn = _extractLabel4[1];\n        var _extractLabel5 = extractLabel(end),\n          _extractLabel6 = _slicedToArray(_extractLabel5, 2),\n          endRow = _extractLabel6[0],\n          endColumn = _extractLabel6[1];\n        var startCell = {\n          row: startRow,\n          column: startColumn\n        };\n        var endCell = {\n          row: endRow,\n          column: endColumn\n        };\n        _this4.cells.push(_this4._createCell(startCell, endCell, match));\n      });\n    }\n    /**\n     * Search cell by its label.\n     *\n     * @param {String} label Cell label eq. `B4` or `$B$6`.\n     * @returns {Object|null}\n     * @private\n     */\n  }, {\n    key: \"_searchCell\",\n    value: function _searchCell(label) {\n      var _arrayFilter = arrayFilter(this.cells, function (cellMeta) {\n          return cellMeta.origLabel === label;\n        }),\n        _arrayFilter2 = _slicedToArray(_arrayFilter, 1),\n        cell = _arrayFilter2[0];\n      return cell || null;\n    }\n    /**\n     * Create object cell.\n     *\n     * @param {Object} start Start coordinates (top-left).\n     * @param {Object} end End coordinates (bottom-right).\n     * @param {String} label Original label name.\n     * @returns {Object}\n     * @private\n     */\n  }, {\n    key: \"_createCell\",\n    value: function _createCell(start, end, label) {\n      return {\n        start: start,\n        end: end,\n        origLabel: label,\n        type: label.indexOf(':') === -1 ? 'cell' : 'range',\n        refError: false,\n        toLabel: function toLabel() {\n          var newLabel = _toLabel(this.start.row, this.start.column);\n          if (this.type === 'range') {\n            newLabel += \":\".concat(_toLabel(this.end.row, this.end.column));\n          }\n          return newLabel;\n        }\n      };\n    }\n  }]);\n  return ExpressionModifier;\n}();\nmixin(ExpressionModifier, localHooks);\nexport default ExpressionModifier;","map":{"version":3,"names":["_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","TypeError","Symbol","iterator","Object","prototype","toString","call","_arr","_n","_d","_e","undefined","_i","_s","next","done","push","value","length","err","Array","isArray","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","toLabel","_toLabel","extractLabel","error","ERROR_REF","arrayEach","arrayFilter","mixin","localHooks","toUpperCaseFormula","BARE_CELL_STRICT_REGEX","BARE_CELL_REGEX","CELL_REGEX","RANGE_REGEX","CELL_AND_RANGE_REGEX","ExpressionModifier","expression","cells","customModifier","setExpression","_extractCells","_extractCellsRange","useCustomModifier","translate","_ref","_this","deltaRow","row","deltaColumn","column","startFrom","arguments","cell","_translateCell","_this2","replace","match","p1","p2","isSingleCell","indexOf","result","cellLabel","translatedCellLabel","test","_searchCell","refError","startsWith","concat","axis","delta","startFromIndex","start","end","startIndex","index","endIndex","deltaStart","deltaEnd","_this$customModifier","_this$customModifier2","isAbsolute","Math","max","_this3","matches","coord","cellCoords","_extractLabel","_extractLabel2","_createCell","_this4","_match$split","split","_match$split2","_extractLabel3","_extractLabel4","startRow","startColumn","_extractLabel5","_extractLabel6","endRow","endColumn","startCell","endCell","label","_arrayFilter","cellMeta","origLabel","_arrayFilter2","type","newLabel"],"sources":["C:/Users/mrezy/VSCode/internships-master/node_modules/handsontable/es/plugins/formulas/expressionModifier.js"],"sourcesContent":["import \"core-js/modules/es.symbol\";\nimport \"core-js/modules/es.symbol.description\";\nimport \"core-js/modules/es.symbol.iterator\";\nimport \"core-js/modules/es.array.index-of\";\nimport \"core-js/modules/es.array.iterator\";\nimport \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.regexp.exec\";\nimport \"core-js/modules/es.regexp.to-string\";\nimport \"core-js/modules/es.string.iterator\";\nimport \"core-js/modules/es.string.match\";\nimport \"core-js/modules/es.string.replace\";\nimport \"core-js/modules/es.string.split\";\nimport \"core-js/modules/es.string.starts-with\";\nimport \"core-js/modules/web.dom-collections.iterator\";\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport { toLabel as _toLabel, extractLabel, error, ERROR_REF } from 'hot-formula-parser';\nimport { arrayEach, arrayFilter } from '../../helpers/array';\nimport { mixin } from '../../helpers/object';\nimport localHooks from '../../mixins/localHooks';\nimport { toUpperCaseFormula } from './utils';\nvar BARE_CELL_STRICT_REGEX = /^\\$?[A-Z]+\\$?\\d+$/;\nvar BARE_CELL_REGEX = /\\$?[A-Z]+\\$?\\d+/;\nvar CELL_REGEX = /(?:[^0-9A-Z$: ]|^)\\s*(\\$?[A-Z]+\\$?\\d+)\\s*(?![0-9A-Z_: ])/g;\nvar RANGE_REGEX = /\\$?[A-Z]+\\$?\\d+\\s*:\\s*\\$?[A-Z]+\\$?\\d+/g;\nvar CELL_AND_RANGE_REGEX = /((?:[^0-9A-Z$: ]|^)\\s*(\\$?[A-Z]+\\$?\\d+)\\s*(?![0-9A-Z_: ]))|(\\$?[A-Z]+\\$?\\d+\\s*:\\s*\\$?[A-Z]+\\$?\\d+)/g;\n/**\n * Component adds an ability to parse and modify formula expressions. It is designed for translating cell\n * coordinates and cell ranges in any direction. By default, component translates only relative coordinates but this\n * behavior can be overwritten by passing custom modifier which controls translating process.\n *\n * @class ExpressionModifier\n * @util\n */\n\nvar ExpressionModifier =\n/*#__PURE__*/\nfunction () {\n  function ExpressionModifier(expression) {\n    _classCallCheck(this, ExpressionModifier);\n\n    /**\n     * Formula expression to modify.\n     *\n     * @type {String}\n     */\n    this.expression = '';\n    /**\n     * Extracted cells and cells ranges.\n     *\n     * @type {Array}\n     */\n\n    this.cells = [];\n    /**\n     * Function which can modify default behaviour of how cells and cell ranges will be translated.\n     *\n     * @type {null|Function}\n     */\n\n    this.customModifier = null;\n\n    if (typeof expression === 'string') {\n      this.setExpression(expression);\n    }\n  }\n  /**\n   * Set formula expression to modify.\n   *\n   * @param {String} expression Formula expression to process.\n   * @returns {ExpressionModifier}\n   */\n\n\n  _createClass(ExpressionModifier, [{\n    key: \"setExpression\",\n    value: function setExpression(expression) {\n      this.cells.length = 0;\n      this.expression = toUpperCaseFormula(expression);\n\n      this._extractCells();\n\n      this._extractCellsRange();\n\n      return this;\n    }\n    /**\n     * Set function which can modify default behavior of how cells and cell ranges will be translated.\n     * The passed function will be called with 4 arguments:\n     *  - cell, A cell object with structure\n     *            like this: {start: {row, column}, end: {row, column}, origLabel, type: 'cell|range', refError, toLabel: () => {}}\n     *  - axis, Type of currently processing axis ('row' or 'column')\n     *  - delta, Number as distance to translate. Can be positive or negative.\n     *  - startFromIndex, Base index which translation will be applied from.\n     *\n     * the function must return an array with 3 items, where:\n     *  [\n     *    deltaStart, Number as a delta to translate first part of coordinates.\n     *    deltaEnd,   Number as a delta to translate second part of coordinates (if cell range is modified).\n     *    refError,   Defines an error which refers to the situation when translated cell overcrossed the data boundary.\n     *  ]\n     *\n     *\n     * @param {Function} customModifier Function with custom logic.\n     */\n\n  }, {\n    key: \"useCustomModifier\",\n    value: function useCustomModifier(customModifier) {\n      this.customModifier = customModifier;\n    }\n    /**\n     * Translate formula expression cells.\n     *\n     * @param {Object} delta Distance to move in proper direction.\n     * @param {Object} [startFrom] Coordinates which translation will be applied from.\n     * @returns {ExpressionModifier}\n     */\n\n  }, {\n    key: \"translate\",\n    value: function translate(_ref) {\n      var _this = this;\n\n      var deltaRow = _ref.row,\n          deltaColumn = _ref.column;\n      var startFrom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      arrayEach(this.cells, function (cell) {\n        if (deltaRow !== null && deltaRow !== void 0) {\n          _this._translateCell(cell, 'row', deltaRow, startFrom.row);\n        }\n\n        if (deltaColumn !== null && deltaColumn !== void 0) {\n          _this._translateCell(cell, 'column', deltaColumn, startFrom.column);\n        }\n      });\n      return this;\n    }\n    /**\n     * Translate object into string representation.\n     *\n     * @returns {String}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var _this2 = this;\n\n      var expression = this.expression.replace(CELL_AND_RANGE_REGEX, function (match, p1, p2) {\n        var isSingleCell = match.indexOf(':') === -1;\n        var result = match;\n        var cellLabel = match;\n        var translatedCellLabel = null;\n\n        if (isSingleCell) {\n          cellLabel = BARE_CELL_STRICT_REGEX.test(p1) ? p1 : p2;\n        }\n\n        var cell = _this2._searchCell(cellLabel);\n\n        if (cell) {\n          translatedCellLabel = cell.refError ? error(ERROR_REF) : cell.toLabel();\n\n          if (isSingleCell) {\n            result = match.replace(cellLabel, translatedCellLabel);\n          } else {\n            result = translatedCellLabel;\n          }\n        }\n\n        return result;\n      });\n\n      if (!expression.startsWith('=')) {\n        expression = \"=\".concat(expression);\n      }\n\n      return expression;\n    }\n    /**\n     * Translate single cell.\n     *\n     * @param {Object} cell Cell object.\n     * @param {String} axis Axis to modify.\n     * @param {Number} delta Distance to move.\n     * @param {Number} [startFromIndex] Base index which translation will be applied from.\n     * @private\n     */\n\n  }, {\n    key: \"_translateCell\",\n    value: function _translateCell(cell, axis, delta, startFromIndex) {\n      var start = cell.start,\n          end = cell.end;\n      var startIndex = start[axis].index;\n      var endIndex = end[axis].index;\n      var deltaStart = delta;\n      var deltaEnd = delta;\n      var refError = false;\n\n      if (this.customModifier) {\n        var _this$customModifier = this.customModifier(cell, axis, delta, startFromIndex);\n\n        var _this$customModifier2 = _slicedToArray(_this$customModifier, 3);\n\n        deltaStart = _this$customModifier2[0];\n        deltaEnd = _this$customModifier2[1];\n        refError = _this$customModifier2[2];\n      } else {\n        // By default only relative cells are translated, if meets absolute reset deltas to 0\n        if (start[axis].isAbsolute) {\n          deltaStart = 0;\n        }\n\n        if (end[axis].isAbsolute) {\n          deltaEnd = 0;\n        }\n      }\n\n      if (deltaStart && !refError) {\n        if (startIndex + deltaStart < 0) {\n          refError = true;\n        }\n\n        start[axis].index = Math.max(startIndex + deltaStart, 0);\n      }\n\n      if (deltaEnd && !refError) {\n        if (endIndex + deltaEnd < 0) {\n          refError = true;\n        }\n\n        end[axis].index = Math.max(endIndex + deltaEnd, 0);\n      }\n\n      if (refError) {\n        cell.refError = true;\n      }\n    }\n    /**\n     * Extract all cells from the formula expression.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_extractCells\",\n    value: function _extractCells() {\n      var _this3 = this;\n\n      var matches = this.expression.match(CELL_REGEX);\n\n      if (!matches) {\n        return;\n      }\n\n      arrayEach(matches, function (coord) {\n        var cellCoords = coord.match(BARE_CELL_REGEX);\n\n        if (!cellCoords) {\n          return;\n        }\n\n        var _extractLabel = extractLabel(cellCoords[0]),\n            _extractLabel2 = _slicedToArray(_extractLabel, 2),\n            row = _extractLabel2[0],\n            column = _extractLabel2[1];\n\n        _this3.cells.push(_this3._createCell({\n          row: row,\n          column: column\n        }, {\n          row: row,\n          column: column\n        }, cellCoords[0]));\n      });\n    }\n    /**\n     * Extract all cells range from the formula expression.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_extractCellsRange\",\n    value: function _extractCellsRange() {\n      var _this4 = this;\n\n      var matches = this.expression.match(RANGE_REGEX);\n\n      if (!matches) {\n        return;\n      }\n\n      arrayEach(matches, function (match) {\n        var _match$split = match.split(':'),\n            _match$split2 = _slicedToArray(_match$split, 2),\n            start = _match$split2[0],\n            end = _match$split2[1];\n\n        var _extractLabel3 = extractLabel(start),\n            _extractLabel4 = _slicedToArray(_extractLabel3, 2),\n            startRow = _extractLabel4[0],\n            startColumn = _extractLabel4[1];\n\n        var _extractLabel5 = extractLabel(end),\n            _extractLabel6 = _slicedToArray(_extractLabel5, 2),\n            endRow = _extractLabel6[0],\n            endColumn = _extractLabel6[1];\n\n        var startCell = {\n          row: startRow,\n          column: startColumn\n        };\n        var endCell = {\n          row: endRow,\n          column: endColumn\n        };\n\n        _this4.cells.push(_this4._createCell(startCell, endCell, match));\n      });\n    }\n    /**\n     * Search cell by its label.\n     *\n     * @param {String} label Cell label eq. `B4` or `$B$6`.\n     * @returns {Object|null}\n     * @private\n     */\n\n  }, {\n    key: \"_searchCell\",\n    value: function _searchCell(label) {\n      var _arrayFilter = arrayFilter(this.cells, function (cellMeta) {\n        return cellMeta.origLabel === label;\n      }),\n          _arrayFilter2 = _slicedToArray(_arrayFilter, 1),\n          cell = _arrayFilter2[0];\n\n      return cell || null;\n    }\n    /**\n     * Create object cell.\n     *\n     * @param {Object} start Start coordinates (top-left).\n     * @param {Object} end End coordinates (bottom-right).\n     * @param {String} label Original label name.\n     * @returns {Object}\n     * @private\n     */\n\n  }, {\n    key: \"_createCell\",\n    value: function _createCell(start, end, label) {\n      return {\n        start: start,\n        end: end,\n        origLabel: label,\n        type: label.indexOf(':') === -1 ? 'cell' : 'range',\n        refError: false,\n        toLabel: function toLabel() {\n          var newLabel = _toLabel(this.start.row, this.start.column);\n\n          if (this.type === 'range') {\n            newLabel += \":\".concat(_toLabel(this.end.row, this.end.column));\n          }\n\n          return newLabel;\n        }\n      };\n    }\n  }]);\n\n  return ExpressionModifier;\n}();\n\nmixin(ExpressionModifier, localHooks);\nexport default ExpressionModifier;"],"mappings":"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"},"metadata":{},"sourceType":"module"}