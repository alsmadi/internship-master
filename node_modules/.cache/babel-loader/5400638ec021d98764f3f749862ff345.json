{"ast":null,"code":"import { arrayEach } from '../../../helpers/array';\nimport { cellCoordFactory, isFormulaExpression } from '../utils';\nimport CellValue from '../cell/value';\nimport ExpressionModifier from '../expressionModifier';\n/**\n * When \"remove_row\" is triggered the following operations must be performed:\n *\n * - All formulas which contain cell coordinates must be updated and saved into source data - Row must be decreased\n *   by \"amount\" of times (eq: D4 to D3, $F$5 to $F$4);\n * - Mark all formulas which need update with \"STATE_OUT_OFF_DATE\" flag, so they can be recalculated after the operation.\n */\n\nexport var OPERATION_NAME = 'remove_row';\n/**\n * Execute changes.\n *\n * @param {Number} start Index row from which the operation starts.\n * @param {Number} amount Count of rows to be removed.\n * @param {Boolean} [modifyFormula=true] If `true` all formula expressions will be modified according to the changes.\n *                                       `false` value is used by UndoRedo plugin which saves snapshoots before alter\n *                                       operation so it doesn't modify formulas if undo action is triggered.\n */\n\nexport function operate(start, amount) {\n  var modifyFormula = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  var rowsAmount = -amount;\n  var matrix = this.matrix,\n    dataProvider = this.dataProvider,\n    sheet = this.sheet;\n  var translate = [rowsAmount, 0];\n  var indexOffset = Math.abs(rowsAmount) - 1;\n  var removedCellRef = matrix.removeCellRefsAtRange({\n    row: start\n  }, {\n    row: start + indexOffset\n  });\n  var toRemove = [];\n  arrayEach(matrix.data, function (cell) {\n    arrayEach(removedCellRef, function (cellRef) {\n      if (!cell.hasPrecedent(cellRef)) {\n        return;\n      }\n      cell.removePrecedent(cellRef);\n      cell.setState(CellValue.STATE_OUT_OFF_DATE);\n      arrayEach(sheet.getCellDependencies(cell.row, cell.column), function (cellValue) {\n        cellValue.setState(CellValue.STATE_OUT_OFF_DATE);\n      });\n    });\n    if (cell.row >= start && cell.row <= start + indexOffset) {\n      toRemove.push(cell);\n    }\n  });\n  matrix.remove(toRemove);\n  arrayEach(matrix.cellReferences, function (cell) {\n    if (cell.row >= start) {\n      cell.translateTo.apply(cell, translate);\n    }\n  });\n  arrayEach(matrix.data, function (cell) {\n    var origRow = cell.row,\n      origColumn = cell.column;\n    if (cell.row >= start) {\n      cell.translateTo.apply(cell, translate);\n      cell.setState(CellValue.STATE_OUT_OFF_DATE);\n    }\n    if (modifyFormula) {\n      var row = cell.row,\n        column = cell.column;\n      var value = dataProvider.getSourceDataAtCell(row, column);\n      if (isFormulaExpression(value)) {\n        var startCoord = cellCoordFactory('row', start);\n        var expModifier = new ExpressionModifier(value);\n        expModifier.useCustomModifier(customTranslateModifier);\n        expModifier.translate({\n          row: rowsAmount\n        }, startCoord({\n          row: origRow,\n          column: origColumn\n        }));\n        dataProvider.updateSourceData(row, column, expModifier.toString());\n      }\n    }\n  });\n}\nfunction customTranslateModifier(cell, axis, delta, startFromIndex) {\n  var start = cell.start,\n    end = cell.end,\n    type = cell.type;\n  var startIndex = start[axis].index;\n  var endIndex = end[axis].index;\n  var indexOffset = Math.abs(delta) - 1;\n  var deltaStart = delta;\n  var deltaEnd = delta;\n  var refError = false; // Mark all cells as #REF! which refer to removed cells between startFromIndex and startFromIndex + delta\n\n  if (startIndex >= startFromIndex && endIndex <= startFromIndex + indexOffset) {\n    refError = true;\n  } // Decrement all cells below startFromIndex\n\n  if (!refError && type === 'cell') {\n    if (startFromIndex >= startIndex) {\n      deltaStart = 0;\n      deltaEnd = 0;\n    }\n  }\n  if (!refError && type === 'range') {\n    if (startFromIndex >= startIndex) {\n      deltaStart = 0;\n    }\n    if (startFromIndex > endIndex) {\n      deltaEnd = 0;\n    } else if (endIndex <= startFromIndex + indexOffset) {\n      deltaEnd -= Math.min(endIndex - (startFromIndex + indexOffset), 0);\n    }\n  }\n  if (startIndex + deltaStart < 0) {\n    deltaStart -= startIndex + deltaStart;\n  }\n  return [deltaStart, deltaEnd, refError];\n}","map":{"version":3,"names":["arrayEach","cellCoordFactory","isFormulaExpression","CellValue","ExpressionModifier","OPERATION_NAME","operate","start","amount","modifyFormula","arguments","length","undefined","rowsAmount","matrix","dataProvider","sheet","translate","indexOffset","Math","abs","removedCellRef","removeCellRefsAtRange","row","toRemove","data","cell","cellRef","hasPrecedent","removePrecedent","setState","STATE_OUT_OFF_DATE","getCellDependencies","column","cellValue","push","remove","cellReferences","translateTo","apply","origRow","origColumn","value","getSourceDataAtCell","startCoord","expModifier","useCustomModifier","customTranslateModifier","updateSourceData","toString","axis","delta","startFromIndex","end","type","startIndex","index","endIndex","deltaStart","deltaEnd","refError","min"],"sources":["C:/Users/mrezy/VSCode/internships-master/node_modules/handsontable/es/plugins/formulas/alterOperation/removeRow.js"],"sourcesContent":["import \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.regexp.to-string\";\nimport { arrayEach } from '../../../helpers/array';\nimport { cellCoordFactory, isFormulaExpression } from '../utils';\nimport CellValue from '../cell/value';\nimport ExpressionModifier from '../expressionModifier';\n/**\n * When \"remove_row\" is triggered the following operations must be performed:\n *\n * - All formulas which contain cell coordinates must be updated and saved into source data - Row must be decreased\n *   by \"amount\" of times (eq: D4 to D3, $F$5 to $F$4);\n * - Mark all formulas which need update with \"STATE_OUT_OFF_DATE\" flag, so they can be recalculated after the operation.\n */\n\nexport var OPERATION_NAME = 'remove_row';\n/**\n * Execute changes.\n *\n * @param {Number} start Index row from which the operation starts.\n * @param {Number} amount Count of rows to be removed.\n * @param {Boolean} [modifyFormula=true] If `true` all formula expressions will be modified according to the changes.\n *                                       `false` value is used by UndoRedo plugin which saves snapshoots before alter\n *                                       operation so it doesn't modify formulas if undo action is triggered.\n */\n\nexport function operate(start, amount) {\n  var modifyFormula = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  var rowsAmount = -amount;\n  var matrix = this.matrix,\n      dataProvider = this.dataProvider,\n      sheet = this.sheet;\n  var translate = [rowsAmount, 0];\n  var indexOffset = Math.abs(rowsAmount) - 1;\n  var removedCellRef = matrix.removeCellRefsAtRange({\n    row: start\n  }, {\n    row: start + indexOffset\n  });\n  var toRemove = [];\n  arrayEach(matrix.data, function (cell) {\n    arrayEach(removedCellRef, function (cellRef) {\n      if (!cell.hasPrecedent(cellRef)) {\n        return;\n      }\n\n      cell.removePrecedent(cellRef);\n      cell.setState(CellValue.STATE_OUT_OFF_DATE);\n      arrayEach(sheet.getCellDependencies(cell.row, cell.column), function (cellValue) {\n        cellValue.setState(CellValue.STATE_OUT_OFF_DATE);\n      });\n    });\n\n    if (cell.row >= start && cell.row <= start + indexOffset) {\n      toRemove.push(cell);\n    }\n  });\n  matrix.remove(toRemove);\n  arrayEach(matrix.cellReferences, function (cell) {\n    if (cell.row >= start) {\n      cell.translateTo.apply(cell, translate);\n    }\n  });\n  arrayEach(matrix.data, function (cell) {\n    var origRow = cell.row,\n        origColumn = cell.column;\n\n    if (cell.row >= start) {\n      cell.translateTo.apply(cell, translate);\n      cell.setState(CellValue.STATE_OUT_OFF_DATE);\n    }\n\n    if (modifyFormula) {\n      var row = cell.row,\n          column = cell.column;\n      var value = dataProvider.getSourceDataAtCell(row, column);\n\n      if (isFormulaExpression(value)) {\n        var startCoord = cellCoordFactory('row', start);\n        var expModifier = new ExpressionModifier(value);\n        expModifier.useCustomModifier(customTranslateModifier);\n        expModifier.translate({\n          row: rowsAmount\n        }, startCoord({\n          row: origRow,\n          column: origColumn\n        }));\n        dataProvider.updateSourceData(row, column, expModifier.toString());\n      }\n    }\n  });\n}\n\nfunction customTranslateModifier(cell, axis, delta, startFromIndex) {\n  var start = cell.start,\n      end = cell.end,\n      type = cell.type;\n  var startIndex = start[axis].index;\n  var endIndex = end[axis].index;\n  var indexOffset = Math.abs(delta) - 1;\n  var deltaStart = delta;\n  var deltaEnd = delta;\n  var refError = false; // Mark all cells as #REF! which refer to removed cells between startFromIndex and startFromIndex + delta\n\n  if (startIndex >= startFromIndex && endIndex <= startFromIndex + indexOffset) {\n    refError = true;\n  } // Decrement all cells below startFromIndex\n\n\n  if (!refError && type === 'cell') {\n    if (startFromIndex >= startIndex) {\n      deltaStart = 0;\n      deltaEnd = 0;\n    }\n  }\n\n  if (!refError && type === 'range') {\n    if (startFromIndex >= startIndex) {\n      deltaStart = 0;\n    }\n\n    if (startFromIndex > endIndex) {\n      deltaEnd = 0;\n    } else if (endIndex <= startFromIndex + indexOffset) {\n      deltaEnd -= Math.min(endIndex - (startFromIndex + indexOffset), 0);\n    }\n  }\n\n  if (startIndex + deltaStart < 0) {\n    deltaStart -= startIndex + deltaStart;\n  }\n\n  return [deltaStart, deltaEnd, refError];\n}"],"mappings":"AAEA,SAASA,SAAS,QAAQ,wBAAwB;AAClD,SAASC,gBAAgB,EAAEC,mBAAmB,QAAQ,UAAU;AAChE,OAAOC,SAAS,MAAM,eAAe;AACrC,OAAOC,kBAAkB,MAAM,uBAAuB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,IAAIC,cAAc,GAAG,YAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASC,OAAO,CAACC,KAAK,EAAEC,MAAM,EAAE;EACrC,IAAIC,aAAa,GAAGC,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,IAAI;EAC5F,IAAIG,UAAU,GAAG,CAACL,MAAM;EACxB,IAAIM,MAAM,GAAG,IAAI,CAACA,MAAM;IACpBC,YAAY,GAAG,IAAI,CAACA,YAAY;IAChCC,KAAK,GAAG,IAAI,CAACA,KAAK;EACtB,IAAIC,SAAS,GAAG,CAACJ,UAAU,EAAE,CAAC,CAAC;EAC/B,IAAIK,WAAW,GAAGC,IAAI,CAACC,GAAG,CAACP,UAAU,CAAC,GAAG,CAAC;EAC1C,IAAIQ,cAAc,GAAGP,MAAM,CAACQ,qBAAqB,CAAC;IAChDC,GAAG,EAAEhB;EACP,CAAC,EAAE;IACDgB,GAAG,EAAEhB,KAAK,GAAGW;EACf,CAAC,CAAC;EACF,IAAIM,QAAQ,GAAG,EAAE;EACjBxB,SAAS,CAACc,MAAM,CAACW,IAAI,EAAE,UAAUC,IAAI,EAAE;IACrC1B,SAAS,CAACqB,cAAc,EAAE,UAAUM,OAAO,EAAE;MAC3C,IAAI,CAACD,IAAI,CAACE,YAAY,CAACD,OAAO,CAAC,EAAE;QAC/B;MACF;MAEAD,IAAI,CAACG,eAAe,CAACF,OAAO,CAAC;MAC7BD,IAAI,CAACI,QAAQ,CAAC3B,SAAS,CAAC4B,kBAAkB,CAAC;MAC3C/B,SAAS,CAACgB,KAAK,CAACgB,mBAAmB,CAACN,IAAI,CAACH,GAAG,EAAEG,IAAI,CAACO,MAAM,CAAC,EAAE,UAAUC,SAAS,EAAE;QAC/EA,SAAS,CAACJ,QAAQ,CAAC3B,SAAS,CAAC4B,kBAAkB,CAAC;MAClD,CAAC,CAAC;IACJ,CAAC,CAAC;IAEF,IAAIL,IAAI,CAACH,GAAG,IAAIhB,KAAK,IAAImB,IAAI,CAACH,GAAG,IAAIhB,KAAK,GAAGW,WAAW,EAAE;MACxDM,QAAQ,CAACW,IAAI,CAACT,IAAI,CAAC;IACrB;EACF,CAAC,CAAC;EACFZ,MAAM,CAACsB,MAAM,CAACZ,QAAQ,CAAC;EACvBxB,SAAS,CAACc,MAAM,CAACuB,cAAc,EAAE,UAAUX,IAAI,EAAE;IAC/C,IAAIA,IAAI,CAACH,GAAG,IAAIhB,KAAK,EAAE;MACrBmB,IAAI,CAACY,WAAW,CAACC,KAAK,CAACb,IAAI,EAAET,SAAS,CAAC;IACzC;EACF,CAAC,CAAC;EACFjB,SAAS,CAACc,MAAM,CAACW,IAAI,EAAE,UAAUC,IAAI,EAAE;IACrC,IAAIc,OAAO,GAAGd,IAAI,CAACH,GAAG;MAClBkB,UAAU,GAAGf,IAAI,CAACO,MAAM;IAE5B,IAAIP,IAAI,CAACH,GAAG,IAAIhB,KAAK,EAAE;MACrBmB,IAAI,CAACY,WAAW,CAACC,KAAK,CAACb,IAAI,EAAET,SAAS,CAAC;MACvCS,IAAI,CAACI,QAAQ,CAAC3B,SAAS,CAAC4B,kBAAkB,CAAC;IAC7C;IAEA,IAAItB,aAAa,EAAE;MACjB,IAAIc,GAAG,GAAGG,IAAI,CAACH,GAAG;QACdU,MAAM,GAAGP,IAAI,CAACO,MAAM;MACxB,IAAIS,KAAK,GAAG3B,YAAY,CAAC4B,mBAAmB,CAACpB,GAAG,EAAEU,MAAM,CAAC;MAEzD,IAAI/B,mBAAmB,CAACwC,KAAK,CAAC,EAAE;QAC9B,IAAIE,UAAU,GAAG3C,gBAAgB,CAAC,KAAK,EAAEM,KAAK,CAAC;QAC/C,IAAIsC,WAAW,GAAG,IAAIzC,kBAAkB,CAACsC,KAAK,CAAC;QAC/CG,WAAW,CAACC,iBAAiB,CAACC,uBAAuB,CAAC;QACtDF,WAAW,CAAC5B,SAAS,CAAC;UACpBM,GAAG,EAAEV;QACP,CAAC,EAAE+B,UAAU,CAAC;UACZrB,GAAG,EAAEiB,OAAO;UACZP,MAAM,EAAEQ;QACV,CAAC,CAAC,CAAC;QACH1B,YAAY,CAACiC,gBAAgB,CAACzB,GAAG,EAAEU,MAAM,EAAEY,WAAW,CAACI,QAAQ,EAAE,CAAC;MACpE;IACF;EACF,CAAC,CAAC;AACJ;AAEA,SAASF,uBAAuB,CAACrB,IAAI,EAAEwB,IAAI,EAAEC,KAAK,EAAEC,cAAc,EAAE;EAClE,IAAI7C,KAAK,GAAGmB,IAAI,CAACnB,KAAK;IAClB8C,GAAG,GAAG3B,IAAI,CAAC2B,GAAG;IACdC,IAAI,GAAG5B,IAAI,CAAC4B,IAAI;EACpB,IAAIC,UAAU,GAAGhD,KAAK,CAAC2C,IAAI,CAAC,CAACM,KAAK;EAClC,IAAIC,QAAQ,GAAGJ,GAAG,CAACH,IAAI,CAAC,CAACM,KAAK;EAC9B,IAAItC,WAAW,GAAGC,IAAI,CAACC,GAAG,CAAC+B,KAAK,CAAC,GAAG,CAAC;EACrC,IAAIO,UAAU,GAAGP,KAAK;EACtB,IAAIQ,QAAQ,GAAGR,KAAK;EACpB,IAAIS,QAAQ,GAAG,KAAK,CAAC,CAAC;;EAEtB,IAAIL,UAAU,IAAIH,cAAc,IAAIK,QAAQ,IAAIL,cAAc,GAAGlC,WAAW,EAAE;IAC5E0C,QAAQ,GAAG,IAAI;EACjB,CAAC,CAAC;;EAGF,IAAI,CAACA,QAAQ,IAAIN,IAAI,KAAK,MAAM,EAAE;IAChC,IAAIF,cAAc,IAAIG,UAAU,EAAE;MAChCG,UAAU,GAAG,CAAC;MACdC,QAAQ,GAAG,CAAC;IACd;EACF;EAEA,IAAI,CAACC,QAAQ,IAAIN,IAAI,KAAK,OAAO,EAAE;IACjC,IAAIF,cAAc,IAAIG,UAAU,EAAE;MAChCG,UAAU,GAAG,CAAC;IAChB;IAEA,IAAIN,cAAc,GAAGK,QAAQ,EAAE;MAC7BE,QAAQ,GAAG,CAAC;IACd,CAAC,MAAM,IAAIF,QAAQ,IAAIL,cAAc,GAAGlC,WAAW,EAAE;MACnDyC,QAAQ,IAAIxC,IAAI,CAAC0C,GAAG,CAACJ,QAAQ,IAAIL,cAAc,GAAGlC,WAAW,CAAC,EAAE,CAAC,CAAC;IACpE;EACF;EAEA,IAAIqC,UAAU,GAAGG,UAAU,GAAG,CAAC,EAAE;IAC/BA,UAAU,IAAIH,UAAU,GAAGG,UAAU;EACvC;EAEA,OAAO,CAACA,UAAU,EAAEC,QAAQ,EAAEC,QAAQ,CAAC;AACzC"},"metadata":{},"sourceType":"module"}