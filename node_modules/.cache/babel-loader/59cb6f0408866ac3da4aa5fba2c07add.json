{"ast":null,"code":"function _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nimport { CellCoords, CellRange } from './../../../3rdparty/walkontable/src';\n/**\n * Class responsible for all of the Selection-related operations on merged cells.\n *\n * @class SelectionCalculations\n * @plugin MergeCells\n * @util\n */\n\nvar SelectionCalculations = /*#__PURE__*/\nfunction () {\n  function SelectionCalculations(plugin) {\n    _classCallCheck(this, SelectionCalculations);\n\n    /**\n     * Reference to the Merge Cells plugin.\n     *\n     * @type {MergeCells}\n     */\n    this.plugin = plugin;\n    /**\n     * Class name used for fully selected merged cells.\n     *\n     * @type {String}\n     */\n\n    this.fullySelectedMergedCellClassName = 'fullySelectedMergedCell';\n  }\n  /**\n   * \"Snap\" the delta value according to defined merged cells. (In other words, compensate the rowspan -\n   * e.g. going up with `delta.row = -1` over a merged cell with `rowspan = 3`, `delta.row` should change to `-3`.)\n   *\n   * @param {Object} delta The delta object containing `row` and `col` properties.\n   * @param {CellRange} selectionRange The selection range.\n   * @param {Object} mergedCell A merged cell object.\n   */\n\n  _createClass(SelectionCalculations, [{\n    key: \"snapDelta\",\n    value: function snapDelta(delta, selectionRange, mergedCell) {\n      var cellCoords = selectionRange.to;\n      var newRow = cellCoords.row + delta.row;\n      var newColumn = cellCoords.col + delta.col;\n      if (delta.row) {\n        this.jumpOverMergedCell(delta, mergedCell, newRow);\n      } else if (delta.col) {\n        this.jumpOverMergedCell(delta, mergedCell, newColumn);\n      }\n    }\n    /**\n     * \"Jump\" over the merged cell (compensate for the indexes within the merged cell to get past it)\n     *\n     * @private\n     * @param {Object} delta The delta object.\n     * @param {MergedCellCoords} mergedCell The merge cell object.\n     * @param {Number} newIndex New row/column index, created with the delta.\n     */\n  }, {\n    key: \"jumpOverMergedCell\",\n    value: function jumpOverMergedCell(delta, mergedCell, newIndex) {\n      var flatDelta = delta.row || delta.col;\n      var includesIndex = null;\n      var firstIndex = null;\n      var lastIndex = null;\n      if (delta.row) {\n        includesIndex = mergedCell.includesVertically(newIndex);\n        firstIndex = mergedCell.row;\n        lastIndex = mergedCell.getLastRow();\n      } else if (delta.col) {\n        includesIndex = mergedCell.includesHorizontally(newIndex);\n        firstIndex = mergedCell.col;\n        lastIndex = mergedCell.getLastColumn();\n      }\n      if (flatDelta === 0) {\n        return;\n      } else if (flatDelta > 0) {\n        if (includesIndex && newIndex !== firstIndex) {\n          flatDelta += lastIndex - newIndex + 1;\n        }\n      } else if (includesIndex && newIndex !== lastIndex) {\n        flatDelta -= newIndex - firstIndex + 1;\n      }\n      if (delta.row) {\n        delta.row = flatDelta;\n      } else if (delta.col) {\n        delta.col = flatDelta;\n      }\n    }\n    /**\n     * Get a selection range with `to` property incremented by the provided delta.\n     *\n     * @param {CellRange} oldSelectionRange The base selection range.\n     * @param {Object} delta The delta object with `row` and `col` properties.\n     * @returns {CellRange} A new `CellRange` object.\n     */\n  }, {\n    key: \"getUpdatedSelectionRange\",\n    value: function getUpdatedSelectionRange(oldSelectionRange, delta) {\n      return new CellRange(oldSelectionRange.highlight, oldSelectionRange.from, new CellCoords(oldSelectionRange.to.row + delta.row, oldSelectionRange.to.col + delta.col));\n    }\n    /**\n     * Generate an additional class name for the entirely-selected merged cells.\n     *\n     * @param {Number} currentRow Row index of the currently processed cell.\n     * @param {Number} currentColumn Column index of the currently cell.\n     * @param {Array} cornersOfSelection Array of the current selection in a form of `[startRow, startColumn, endRow, endColumn]`.\n     * @param {Number|undefined} layerLevel Number indicating which layer of selection is currently processed.\n     * @returns {String|undefined} A `String`, which will act as an additional `className` to be added to the currently processed cell.\n     */\n  }, {\n    key: \"getSelectedMergedCellClassName\",\n    value: function getSelectedMergedCellClassName(currentRow, currentColumn, cornersOfSelection, layerLevel) {\n      var _cornersOfSelection = _slicedToArray(cornersOfSelection, 4),\n        startRow = _cornersOfSelection[0],\n        startColumn = _cornersOfSelection[1],\n        endRow = _cornersOfSelection[2],\n        endColumn = _cornersOfSelection[3];\n      if (layerLevel === void 0) {\n        return;\n      }\n      if (currentRow >= startRow && currentRow <= endRow && currentColumn >= startColumn && currentColumn <= endColumn) {\n        var isMergedCellParent = this.plugin.mergedCellsCollection.isMergedParent(currentRow, currentColumn);\n        if (!isMergedCellParent) {\n          return;\n        }\n        var mergedCell = this.plugin.mergedCellsCollection.get(currentRow, currentColumn);\n        if (!mergedCell) {\n          return;\n        }\n        if (mergedCell.row + mergedCell.rowspan - 1 <= endRow && mergedCell.col + mergedCell.colspan - 1 <= endColumn) {\n          return \"\".concat(this.fullySelectedMergedCellClassName, \"-\").concat(layerLevel);\n        } else if (this.plugin.selectionCalculations.isMergeCellFullySelected(mergedCell, this.plugin.hot.getSelectedRange())) {\n          return \"\".concat(this.fullySelectedMergedCellClassName, \"-multiple\");\n        }\n      }\n    }\n    /**\n     * Check if the provided merged cell is fully selected (by one or many layers of selection)\n     *\n     * @param {MergedCellCoords} mergedCell The merged cell to be processed.\n     * @param {CellRange[]} selectionRangesArray Array of selection ranges.\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"isMergeCellFullySelected\",\n    value: function isMergeCellFullySelected(mergedCell, selectionRangesArray) {\n      var mergedCellIndividualCoords = [];\n      if (!selectionRangesArray || !mergedCell) {\n        return false;\n      }\n      for (var r = 0; r < mergedCell.rowspan; r += 1) {\n        for (var c = 0; c < mergedCell.colspan; c += 1) {\n          mergedCellIndividualCoords.push(new CellCoords(mergedCell.row + r, mergedCell.col + c));\n        }\n      }\n      for (var i = 0; i < mergedCellIndividualCoords.length; i += 1) {\n        var insideSelections = [];\n        for (var s = 0; s < selectionRangesArray.length; s += 1) {\n          insideSelections[s] = selectionRangesArray[s].includes(mergedCellIndividualCoords[i]);\n        }\n        if (!insideSelections.includes(true)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    /**\n     * Generate an array of the entirely-selected merged cells' class names.\n     *\n     * @returns {String[]} An `Array` of `String`s. Each of these strings will act like class names to be removed from all the cells in the table.\n     */\n  }, {\n    key: \"getSelectedMergedCellClassNameToRemove\",\n    value: function getSelectedMergedCellClassNameToRemove() {\n      var classNames = [];\n      for (var i = 0; i <= 7; i += 1) {\n        classNames.push(\"\".concat(this.fullySelectedMergedCellClassName, \"-\").concat(i));\n      }\n      classNames.push(\"\".concat(this.fullySelectedMergedCellClassName, \"-multiple\"));\n      return classNames;\n    }\n  }]);\n  return SelectionCalculations;\n}();\nexport default SelectionCalculations;","map":{"version":3,"names":["_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","TypeError","Symbol","iterator","Object","prototype","toString","call","_arr","_n","_d","_e","undefined","_i","_s","next","done","push","value","length","err","Array","isArray","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","CellCoords","CellRange","SelectionCalculations","plugin","fullySelectedMergedCellClassName","snapDelta","delta","selectionRange","mergedCell","cellCoords","to","newRow","row","newColumn","col","jumpOverMergedCell","newIndex","flatDelta","includesIndex","firstIndex","lastIndex","includesVertically","getLastRow","includesHorizontally","getLastColumn","getUpdatedSelectionRange","oldSelectionRange","highlight","from","getSelectedMergedCellClassName","currentRow","currentColumn","cornersOfSelection","layerLevel","_cornersOfSelection","startRow","startColumn","endRow","endColumn","isMergedCellParent","mergedCellsCollection","isMergedParent","get","rowspan","colspan","concat","selectionCalculations","isMergeCellFullySelected","hot","getSelectedRange","selectionRangesArray","mergedCellIndividualCoords","r","c","insideSelections","s","includes","getSelectedMergedCellClassNameToRemove","classNames"],"sources":["C:/Users/mrezy/VSCode/internships-master/node_modules/handsontable/es/plugins/mergeCells/calculations/selection.js"],"sourcesContent":["import \"core-js/modules/es.symbol\";\nimport \"core-js/modules/es.symbol.description\";\nimport \"core-js/modules/es.symbol.iterator\";\nimport \"core-js/modules/es.array.concat\";\nimport \"core-js/modules/es.array.includes\";\nimport \"core-js/modules/es.array.iterator\";\nimport \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.regexp.to-string\";\nimport \"core-js/modules/es.string.includes\";\nimport \"core-js/modules/es.string.iterator\";\nimport \"core-js/modules/web.dom-collections.iterator\";\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport { CellCoords, CellRange } from './../../../3rdparty/walkontable/src';\n/**\n * Class responsible for all of the Selection-related operations on merged cells.\n *\n * @class SelectionCalculations\n * @plugin MergeCells\n * @util\n */\n\nvar SelectionCalculations =\n/*#__PURE__*/\nfunction () {\n  function SelectionCalculations(plugin) {\n    _classCallCheck(this, SelectionCalculations);\n\n    /**\n     * Reference to the Merge Cells plugin.\n     *\n     * @type {MergeCells}\n     */\n    this.plugin = plugin;\n    /**\n     * Class name used for fully selected merged cells.\n     *\n     * @type {String}\n     */\n\n    this.fullySelectedMergedCellClassName = 'fullySelectedMergedCell';\n  }\n  /**\n   * \"Snap\" the delta value according to defined merged cells. (In other words, compensate the rowspan -\n   * e.g. going up with `delta.row = -1` over a merged cell with `rowspan = 3`, `delta.row` should change to `-3`.)\n   *\n   * @param {Object} delta The delta object containing `row` and `col` properties.\n   * @param {CellRange} selectionRange The selection range.\n   * @param {Object} mergedCell A merged cell object.\n   */\n\n\n  _createClass(SelectionCalculations, [{\n    key: \"snapDelta\",\n    value: function snapDelta(delta, selectionRange, mergedCell) {\n      var cellCoords = selectionRange.to;\n      var newRow = cellCoords.row + delta.row;\n      var newColumn = cellCoords.col + delta.col;\n\n      if (delta.row) {\n        this.jumpOverMergedCell(delta, mergedCell, newRow);\n      } else if (delta.col) {\n        this.jumpOverMergedCell(delta, mergedCell, newColumn);\n      }\n    }\n    /**\n     * \"Jump\" over the merged cell (compensate for the indexes within the merged cell to get past it)\n     *\n     * @private\n     * @param {Object} delta The delta object.\n     * @param {MergedCellCoords} mergedCell The merge cell object.\n     * @param {Number} newIndex New row/column index, created with the delta.\n     */\n\n  }, {\n    key: \"jumpOverMergedCell\",\n    value: function jumpOverMergedCell(delta, mergedCell, newIndex) {\n      var flatDelta = delta.row || delta.col;\n      var includesIndex = null;\n      var firstIndex = null;\n      var lastIndex = null;\n\n      if (delta.row) {\n        includesIndex = mergedCell.includesVertically(newIndex);\n        firstIndex = mergedCell.row;\n        lastIndex = mergedCell.getLastRow();\n      } else if (delta.col) {\n        includesIndex = mergedCell.includesHorizontally(newIndex);\n        firstIndex = mergedCell.col;\n        lastIndex = mergedCell.getLastColumn();\n      }\n\n      if (flatDelta === 0) {\n        return;\n      } else if (flatDelta > 0) {\n        if (includesIndex && newIndex !== firstIndex) {\n          flatDelta += lastIndex - newIndex + 1;\n        }\n      } else if (includesIndex && newIndex !== lastIndex) {\n        flatDelta -= newIndex - firstIndex + 1;\n      }\n\n      if (delta.row) {\n        delta.row = flatDelta;\n      } else if (delta.col) {\n        delta.col = flatDelta;\n      }\n    }\n    /**\n     * Get a selection range with `to` property incremented by the provided delta.\n     *\n     * @param {CellRange} oldSelectionRange The base selection range.\n     * @param {Object} delta The delta object with `row` and `col` properties.\n     * @returns {CellRange} A new `CellRange` object.\n     */\n\n  }, {\n    key: \"getUpdatedSelectionRange\",\n    value: function getUpdatedSelectionRange(oldSelectionRange, delta) {\n      return new CellRange(oldSelectionRange.highlight, oldSelectionRange.from, new CellCoords(oldSelectionRange.to.row + delta.row, oldSelectionRange.to.col + delta.col));\n    }\n    /**\n     * Generate an additional class name for the entirely-selected merged cells.\n     *\n     * @param {Number} currentRow Row index of the currently processed cell.\n     * @param {Number} currentColumn Column index of the currently cell.\n     * @param {Array} cornersOfSelection Array of the current selection in a form of `[startRow, startColumn, endRow, endColumn]`.\n     * @param {Number|undefined} layerLevel Number indicating which layer of selection is currently processed.\n     * @returns {String|undefined} A `String`, which will act as an additional `className` to be added to the currently processed cell.\n     */\n\n  }, {\n    key: \"getSelectedMergedCellClassName\",\n    value: function getSelectedMergedCellClassName(currentRow, currentColumn, cornersOfSelection, layerLevel) {\n      var _cornersOfSelection = _slicedToArray(cornersOfSelection, 4),\n          startRow = _cornersOfSelection[0],\n          startColumn = _cornersOfSelection[1],\n          endRow = _cornersOfSelection[2],\n          endColumn = _cornersOfSelection[3];\n\n      if (layerLevel === void 0) {\n        return;\n      }\n\n      if (currentRow >= startRow && currentRow <= endRow && currentColumn >= startColumn && currentColumn <= endColumn) {\n        var isMergedCellParent = this.plugin.mergedCellsCollection.isMergedParent(currentRow, currentColumn);\n\n        if (!isMergedCellParent) {\n          return;\n        }\n\n        var mergedCell = this.plugin.mergedCellsCollection.get(currentRow, currentColumn);\n\n        if (!mergedCell) {\n          return;\n        }\n\n        if (mergedCell.row + mergedCell.rowspan - 1 <= endRow && mergedCell.col + mergedCell.colspan - 1 <= endColumn) {\n          return \"\".concat(this.fullySelectedMergedCellClassName, \"-\").concat(layerLevel);\n        } else if (this.plugin.selectionCalculations.isMergeCellFullySelected(mergedCell, this.plugin.hot.getSelectedRange())) {\n          return \"\".concat(this.fullySelectedMergedCellClassName, \"-multiple\");\n        }\n      }\n    }\n    /**\n     * Check if the provided merged cell is fully selected (by one or many layers of selection)\n     *\n     * @param {MergedCellCoords} mergedCell The merged cell to be processed.\n     * @param {CellRange[]} selectionRangesArray Array of selection ranges.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isMergeCellFullySelected\",\n    value: function isMergeCellFullySelected(mergedCell, selectionRangesArray) {\n      var mergedCellIndividualCoords = [];\n\n      if (!selectionRangesArray || !mergedCell) {\n        return false;\n      }\n\n      for (var r = 0; r < mergedCell.rowspan; r += 1) {\n        for (var c = 0; c < mergedCell.colspan; c += 1) {\n          mergedCellIndividualCoords.push(new CellCoords(mergedCell.row + r, mergedCell.col + c));\n        }\n      }\n\n      for (var i = 0; i < mergedCellIndividualCoords.length; i += 1) {\n        var insideSelections = [];\n\n        for (var s = 0; s < selectionRangesArray.length; s += 1) {\n          insideSelections[s] = selectionRangesArray[s].includes(mergedCellIndividualCoords[i]);\n        }\n\n        if (!insideSelections.includes(true)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n    /**\n     * Generate an array of the entirely-selected merged cells' class names.\n     *\n     * @returns {String[]} An `Array` of `String`s. Each of these strings will act like class names to be removed from all the cells in the table.\n     */\n\n  }, {\n    key: \"getSelectedMergedCellClassNameToRemove\",\n    value: function getSelectedMergedCellClassNameToRemove() {\n      var classNames = [];\n\n      for (var i = 0; i <= 7; i += 1) {\n        classNames.push(\"\".concat(this.fullySelectedMergedCellClassName, \"-\").concat(i));\n      }\n\n      classNames.push(\"\".concat(this.fullySelectedMergedCellClassName, \"-multiple\"));\n      return classNames;\n    }\n  }]);\n\n  return SelectionCalculations;\n}();\n\nexport default SelectionCalculations;"],"mappings":"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"},"metadata":{},"sourceType":"module"}