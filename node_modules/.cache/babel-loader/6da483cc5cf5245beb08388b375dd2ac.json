{"ast":null,"code":"import \"core-js/modules/es.symbol\";\nimport \"core-js/modules/es.symbol.description\";\nimport \"core-js/modules/es.symbol.iterator\";\nimport \"core-js/modules/es.array.from\";\nimport \"core-js/modules/es.array.index-of\";\nimport \"core-js/modules/es.array.iterator\";\nimport \"core-js/modules/es.array.slice\";\nimport \"core-js/modules/es.array.splice\";\nimport \"core-js/modules/es.object.freeze\";\nimport \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.regexp.to-string\";\nimport \"core-js/modules/es.string.iterator\";\nimport \"core-js/modules/web.dom-collections.iterator\";\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"The merged cell declared at [\", \", \", \"], overlaps with the other declared merged \\n    cell. The overlapping merged cell was not added to the table, please fix your setup.\"]);\n  _templateObject = function _templateObject() {\n    return data;\n  };\n  return data;\n}\nfunction _taggedTemplateLiteral(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n    return arr2;\n  }\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nimport MergedCellCoords from './cellCoords';\nimport { CellCoords, CellRange } from '../../3rdparty/walkontable/src/index';\nimport { rangeEach, rangeEachReverse } from '../../helpers/number';\nimport { warn } from '../../helpers/console';\nimport { arrayEach } from '../../helpers/array';\nimport { applySpanProperties } from './utils';\nimport { toSingleLine } from './../../helpers/templateLiteralTag';\n/**\n * Defines a container object for the merged cells.\n *\n * @class MergedCellsCollection\n * @plugin MergeCells\n */\n\nvar MergedCellsCollection = /*#__PURE__*/\nfunction () {\n  function MergedCellsCollection(plugin) {\n    _classCallCheck(this, MergedCellsCollection);\n\n    /**\n     * Reference to the Merge Cells plugin.\n     *\n     * @type {MergeCells}\n     */\n    this.plugin = plugin;\n    /**\n     * Array of merged cells.\n     *\n     * @type {Array}\n     */\n\n    this.mergedCells = [];\n    /**\n     * The Handsontable instance.\n     *\n     * @type {Handsontable}\n     */\n\n    this.hot = plugin.hot;\n  }\n  /**\n   * Get a warning message for when the declared merged cell data overlaps already existing merged cells.\n   *\n   * @param {Object} newMergedCell Object containg information about the merged cells that was about to be added.\n   * @return {String}\n   */\n\n  _createClass(MergedCellsCollection, [{\n    key: \"get\",\n    /**\n     * Get a merged cell from the container, based on the provided arguments. You can provide either the \"starting coordinates\"\n     * of a merged cell, or any coordinates from the body of the merged cell.\n     *\n     * @param {Number} row Row index.\n     * @param {Number} column Column index.\n     * @returns {MergedCellCoords|Boolean} Returns a wanted merged cell on success and `false` on failure.\n     */\n    value: function get(row, column) {\n      var mergedCells = this.mergedCells;\n      var result = false;\n      arrayEach(mergedCells, function (mergedCell) {\n        if (mergedCell.row <= row && mergedCell.row + mergedCell.rowspan - 1 >= row && mergedCell.col <= column && mergedCell.col + mergedCell.colspan - 1 >= column) {\n          result = mergedCell;\n          return false;\n        }\n        return true;\n      });\n      return result;\n    }\n    /**\n     * Get a merged cell containing the provided range.\n     *\n     * @param {CellRange|Object} range The range to search merged cells for.\n     * @return {MergedCellCoords|Boolean}\n     */\n  }, {\n    key: \"getByRange\",\n    value: function getByRange(range) {\n      var mergedCells = this.mergedCells;\n      var result = false;\n      arrayEach(mergedCells, function (mergedCell) {\n        if (mergedCell.row <= range.from.row && mergedCell.row + mergedCell.rowspan - 1 >= range.to.row && mergedCell.col <= range.from.col && mergedCell.col + mergedCell.colspan - 1 >= range.to.col) {\n          result = mergedCell;\n          return result;\n        }\n        return true;\n      });\n      return result;\n    }\n    /**\n     * Get a merged cell contained in the provided range.\n     *\n     * @param {CellRange|Object} range The range to search merged cells in.\n     * @param [countPartials=false] If set to `true`, all the merged cells overlapping the range will be taken into calculation.\n     * @return {Array|Boolean} Array of found merged cells of `false` if none were found.\n     */\n  }, {\n    key: \"getWithinRange\",\n    value: function getWithinRange(range) {\n      var countPartials = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var mergedCells = this.mergedCells;\n      var foundMergedCells = [];\n      var testedRange = range;\n      if (!testedRange.includesRange) {\n        var from = new CellCoords(testedRange.from.row, testedRange.from.col);\n        var to = new CellCoords(testedRange.to.row, testedRange.to.col);\n        testedRange = new CellRange(from, from, to);\n      }\n      arrayEach(mergedCells, function (mergedCell) {\n        var mergedCellTopLeft = new CellCoords(mergedCell.row, mergedCell.col);\n        var mergedCellBottomRight = new CellCoords(mergedCell.row + mergedCell.rowspan - 1, mergedCell.col + mergedCell.colspan - 1);\n        var mergedCellRange = new CellRange(mergedCellTopLeft, mergedCellTopLeft, mergedCellBottomRight);\n        if (countPartials) {\n          if (testedRange.overlaps(mergedCellRange)) {\n            foundMergedCells.push(mergedCell);\n          }\n        } else if (testedRange.includesRange(mergedCellRange)) {\n          foundMergedCells.push(mergedCell);\n        }\n      });\n      return foundMergedCells.length ? foundMergedCells : false;\n    }\n    /**\n     * Add a merged cell to the container.\n     *\n     * @param {Object} mergedCellInfo The merged cell information object. Has to contain `row`, `col`, `colspan` and `rowspan` properties.\n     * @return {MergedCellCoords|Boolean} Returns the new merged cell on success and `false` on failure.\n     */\n  }, {\n    key: \"add\",\n    value: function add(mergedCellInfo) {\n      var mergedCells = this.mergedCells;\n      var row = mergedCellInfo.row;\n      var column = mergedCellInfo.col;\n      var rowspan = mergedCellInfo.rowspan;\n      var colspan = mergedCellInfo.colspan;\n      var newMergedCell = new MergedCellCoords(row, column, rowspan, colspan);\n      var alreadyExists = this.get(row, column);\n      var isOverlapping = this.isOverlapping(newMergedCell);\n      if (!alreadyExists && !isOverlapping) {\n        if (this.hot) {\n          newMergedCell.normalize(this.hot);\n        }\n        mergedCells.push(newMergedCell);\n        return newMergedCell;\n      }\n      warn(MergedCellsCollection.IS_OVERLAPPING_WARNING(newMergedCell));\n      return false;\n    }\n    /**\n     * Remove a merged cell from the container. You can provide either the \"starting coordinates\"\n     * of a merged cell, or any coordinates from the body of the merged cell.\n     *\n     * @param {Number} row Row index.\n     * @param {Number} column Column index.\n     * @return {MergedCellCoords|Boolean} Returns the removed merged cell on success and `false` on failure.\n     */\n  }, {\n    key: \"remove\",\n    value: function remove(row, column) {\n      var mergedCells = this.mergedCells;\n      var wantedCollection = this.get(row, column);\n      var wantedCollectionIndex = wantedCollection ? this.mergedCells.indexOf(wantedCollection) : null;\n      if (wantedCollection && wantedCollectionIndex !== false) {\n        mergedCells.splice(wantedCollectionIndex, 1);\n        return wantedCollection;\n      }\n      return false;\n    }\n    /**\n     * Clear all the merged cells.\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var _this = this;\n      var mergedCells = this.mergedCells;\n      var mergedCellParentsToClear = [];\n      var hiddenCollectionElements = [];\n      arrayEach(mergedCells, function (mergedCell) {\n        var TD = _this.hot.getCell(mergedCell.row, mergedCell.col);\n        if (TD) {\n          mergedCellParentsToClear.push([TD, _this.get(mergedCell.row, mergedCell.col), mergedCell.row, mergedCell.col]);\n        }\n      });\n      this.mergedCells.length = 0;\n      arrayEach(mergedCellParentsToClear, function (mergedCell, i) {\n        rangeEach(0, mergedCell.rowspan - 1, function (j) {\n          rangeEach(0, mergedCell.colspan - 1, function (k) {\n            if (k !== 0 || j !== 0) {\n              var TD = _this.hot.getCell(mergedCell.row + j, mergedCell.col + k);\n              if (TD) {\n                hiddenCollectionElements.push([TD, null, null, null]);\n              }\n            }\n          });\n        });\n        mergedCellParentsToClear[i][1] = null;\n      });\n      arrayEach(mergedCellParentsToClear, function (mergedCellParents) {\n        applySpanProperties.apply(void 0, _toConsumableArray(mergedCellParents));\n      });\n      arrayEach(hiddenCollectionElements, function (hiddenCollectionElement) {\n        applySpanProperties.apply(void 0, _toConsumableArray(hiddenCollectionElement));\n      });\n    }\n    /**\n     * Check if the provided merged cell overlaps with the others in the container.\n     *\n     * @param {MergedCellCoords} mergedCell The merged cell to check against all others in the container.\n     * @return {Boolean} `true` if the provided merged cell overlaps with the others, `false` otherwise.\n     */\n  }, {\n    key: \"isOverlapping\",\n    value: function isOverlapping(mergedCell) {\n      var mergedCellRange = new CellRange(null, new CellCoords(mergedCell.row, mergedCell.col), new CellCoords(mergedCell.row + mergedCell.rowspan - 1, mergedCell.col + mergedCell.colspan - 1));\n      var result = false;\n      arrayEach(this.mergedCells, function (col) {\n        var currentRange = new CellRange(null, new CellCoords(col.row, col.col), new CellCoords(col.row + col.rowspan - 1, col.col + col.colspan - 1));\n        if (currentRange.overlaps(mergedCellRange)) {\n          result = true;\n          return false;\n        }\n        return true;\n      });\n      return result;\n    }\n    /**\n     * Check whether the provided row/col coordinates direct to a merged parent.\n     *\n     * @param {Number} row Row index.\n     * @param {Number} column Column index.\n     * @return {Boolean}\n     */\n  }, {\n    key: \"isMergedParent\",\n    value: function isMergedParent(row, column) {\n      var mergedCells = this.mergedCells;\n      var result = false;\n      arrayEach(mergedCells, function (mergedCell) {\n        if (mergedCell.row === row && mergedCell.col === column) {\n          result = true;\n          return false;\n        }\n        return true;\n      });\n      return result;\n    }\n    /**\n     * Shift the merged cell in the direction and by an offset defined in the arguments.\n     *\n     * @param {String} direction `right`, `left`, `up` or `down`.\n     * @param {Number} index Index where the change, which caused the shifting took place.\n     * @param {Number} count Number of rows/columns added/removed in the preceding action.\n     */\n  }, {\n    key: \"shiftCollections\",\n    value: function shiftCollections(direction, index, count) {\n      var _this2 = this;\n      var shiftVector = [0, 0];\n      switch (direction) {\n        case 'right':\n          shiftVector[0] += count;\n          break;\n        case 'left':\n          shiftVector[0] -= count;\n          break;\n        case 'down':\n          shiftVector[1] += count;\n          break;\n        case 'up':\n          shiftVector[1] -= count;\n          break;\n        default:\n      }\n      arrayEach(this.mergedCells, function (currentMerge) {\n        currentMerge.shift(shiftVector, index);\n      });\n      rangeEachReverse(this.mergedCells.length - 1, 0, function (i) {\n        var currentMerge = _this2.mergedCells[i];\n        if (currentMerge && currentMerge.removed) {\n          _this2.mergedCells.splice(_this2.mergedCells.indexOf(currentMerge), 1);\n        }\n      });\n    }\n  }], [{\n    key: \"IS_OVERLAPPING_WARNING\",\n    value: function IS_OVERLAPPING_WARNING(newMergedCell) {\n      return toSingleLine(_templateObject(), newMergedCell.row, newMergedCell.col);\n    }\n  }]);\n  return MergedCellsCollection;\n}();\nexport default MergedCellsCollection;","map":{"version":3,"names":["_templateObject","data","_taggedTemplateLiteral","strings","raw","slice","Object","freeze","defineProperties","value","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","prototype","toString","call","Array","from","isArray","i","arr2","length","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","MergedCellCoords","CellCoords","CellRange","rangeEach","rangeEachReverse","warn","arrayEach","applySpanProperties","toSingleLine","MergedCellsCollection","plugin","mergedCells","hot","get","row","column","result","mergedCell","rowspan","col","colspan","getByRange","range","to","getWithinRange","countPartials","arguments","undefined","foundMergedCells","testedRange","includesRange","mergedCellTopLeft","mergedCellBottomRight","mergedCellRange","overlaps","push","add","mergedCellInfo","newMergedCell","alreadyExists","isOverlapping","normalize","IS_OVERLAPPING_WARNING","remove","wantedCollection","wantedCollectionIndex","indexOf","splice","clear","_this","mergedCellParentsToClear","hiddenCollectionElements","TD","getCell","j","k","mergedCellParents","apply","hiddenCollectionElement","currentRange","isMergedParent","shiftCollections","direction","index","count","_this2","shiftVector","currentMerge","shift","removed"],"sources":["C:/Users/mrezy/VSCode/internships-master/node_modules/handsontable/es/plugins/mergeCells/cellsCollection.js"],"sourcesContent":["import \"core-js/modules/es.symbol\";\nimport \"core-js/modules/es.symbol.description\";\nimport \"core-js/modules/es.symbol.iterator\";\nimport \"core-js/modules/es.array.from\";\nimport \"core-js/modules/es.array.index-of\";\nimport \"core-js/modules/es.array.iterator\";\nimport \"core-js/modules/es.array.slice\";\nimport \"core-js/modules/es.array.splice\";\nimport \"core-js/modules/es.object.freeze\";\nimport \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.regexp.to-string\";\nimport \"core-js/modules/es.string.iterator\";\nimport \"core-js/modules/web.dom-collections.iterator\";\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"The merged cell declared at [\", \", \", \"], overlaps with the other declared merged \\n    cell. The overlapping merged cell was not added to the table, please fix your setup.\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport MergedCellCoords from './cellCoords';\nimport { CellCoords, CellRange } from '../../3rdparty/walkontable/src/index';\nimport { rangeEach, rangeEachReverse } from '../../helpers/number';\nimport { warn } from '../../helpers/console';\nimport { arrayEach } from '../../helpers/array';\nimport { applySpanProperties } from './utils';\nimport { toSingleLine } from './../../helpers/templateLiteralTag';\n/**\n * Defines a container object for the merged cells.\n *\n * @class MergedCellsCollection\n * @plugin MergeCells\n */\n\nvar MergedCellsCollection =\n/*#__PURE__*/\nfunction () {\n  function MergedCellsCollection(plugin) {\n    _classCallCheck(this, MergedCellsCollection);\n\n    /**\n     * Reference to the Merge Cells plugin.\n     *\n     * @type {MergeCells}\n     */\n    this.plugin = plugin;\n    /**\n     * Array of merged cells.\n     *\n     * @type {Array}\n     */\n\n    this.mergedCells = [];\n    /**\n     * The Handsontable instance.\n     *\n     * @type {Handsontable}\n     */\n\n    this.hot = plugin.hot;\n  }\n  /**\n   * Get a warning message for when the declared merged cell data overlaps already existing merged cells.\n   *\n   * @param {Object} newMergedCell Object containg information about the merged cells that was about to be added.\n   * @return {String}\n   */\n\n\n  _createClass(MergedCellsCollection, [{\n    key: \"get\",\n\n    /**\n     * Get a merged cell from the container, based on the provided arguments. You can provide either the \"starting coordinates\"\n     * of a merged cell, or any coordinates from the body of the merged cell.\n     *\n     * @param {Number} row Row index.\n     * @param {Number} column Column index.\n     * @returns {MergedCellCoords|Boolean} Returns a wanted merged cell on success and `false` on failure.\n     */\n    value: function get(row, column) {\n      var mergedCells = this.mergedCells;\n      var result = false;\n      arrayEach(mergedCells, function (mergedCell) {\n        if (mergedCell.row <= row && mergedCell.row + mergedCell.rowspan - 1 >= row && mergedCell.col <= column && mergedCell.col + mergedCell.colspan - 1 >= column) {\n          result = mergedCell;\n          return false;\n        }\n\n        return true;\n      });\n      return result;\n    }\n    /**\n     * Get a merged cell containing the provided range.\n     *\n     * @param {CellRange|Object} range The range to search merged cells for.\n     * @return {MergedCellCoords|Boolean}\n     */\n\n  }, {\n    key: \"getByRange\",\n    value: function getByRange(range) {\n      var mergedCells = this.mergedCells;\n      var result = false;\n      arrayEach(mergedCells, function (mergedCell) {\n        if (mergedCell.row <= range.from.row && mergedCell.row + mergedCell.rowspan - 1 >= range.to.row && mergedCell.col <= range.from.col && mergedCell.col + mergedCell.colspan - 1 >= range.to.col) {\n          result = mergedCell;\n          return result;\n        }\n\n        return true;\n      });\n      return result;\n    }\n    /**\n     * Get a merged cell contained in the provided range.\n     *\n     * @param {CellRange|Object} range The range to search merged cells in.\n     * @param [countPartials=false] If set to `true`, all the merged cells overlapping the range will be taken into calculation.\n     * @return {Array|Boolean} Array of found merged cells of `false` if none were found.\n     */\n\n  }, {\n    key: \"getWithinRange\",\n    value: function getWithinRange(range) {\n      var countPartials = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var mergedCells = this.mergedCells;\n      var foundMergedCells = [];\n      var testedRange = range;\n\n      if (!testedRange.includesRange) {\n        var from = new CellCoords(testedRange.from.row, testedRange.from.col);\n        var to = new CellCoords(testedRange.to.row, testedRange.to.col);\n        testedRange = new CellRange(from, from, to);\n      }\n\n      arrayEach(mergedCells, function (mergedCell) {\n        var mergedCellTopLeft = new CellCoords(mergedCell.row, mergedCell.col);\n        var mergedCellBottomRight = new CellCoords(mergedCell.row + mergedCell.rowspan - 1, mergedCell.col + mergedCell.colspan - 1);\n        var mergedCellRange = new CellRange(mergedCellTopLeft, mergedCellTopLeft, mergedCellBottomRight);\n\n        if (countPartials) {\n          if (testedRange.overlaps(mergedCellRange)) {\n            foundMergedCells.push(mergedCell);\n          }\n        } else if (testedRange.includesRange(mergedCellRange)) {\n          foundMergedCells.push(mergedCell);\n        }\n      });\n      return foundMergedCells.length ? foundMergedCells : false;\n    }\n    /**\n     * Add a merged cell to the container.\n     *\n     * @param {Object} mergedCellInfo The merged cell information object. Has to contain `row`, `col`, `colspan` and `rowspan` properties.\n     * @return {MergedCellCoords|Boolean} Returns the new merged cell on success and `false` on failure.\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(mergedCellInfo) {\n      var mergedCells = this.mergedCells;\n      var row = mergedCellInfo.row;\n      var column = mergedCellInfo.col;\n      var rowspan = mergedCellInfo.rowspan;\n      var colspan = mergedCellInfo.colspan;\n      var newMergedCell = new MergedCellCoords(row, column, rowspan, colspan);\n      var alreadyExists = this.get(row, column);\n      var isOverlapping = this.isOverlapping(newMergedCell);\n\n      if (!alreadyExists && !isOverlapping) {\n        if (this.hot) {\n          newMergedCell.normalize(this.hot);\n        }\n\n        mergedCells.push(newMergedCell);\n        return newMergedCell;\n      }\n\n      warn(MergedCellsCollection.IS_OVERLAPPING_WARNING(newMergedCell));\n      return false;\n    }\n    /**\n     * Remove a merged cell from the container. You can provide either the \"starting coordinates\"\n     * of a merged cell, or any coordinates from the body of the merged cell.\n     *\n     * @param {Number} row Row index.\n     * @param {Number} column Column index.\n     * @return {MergedCellCoords|Boolean} Returns the removed merged cell on success and `false` on failure.\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(row, column) {\n      var mergedCells = this.mergedCells;\n      var wantedCollection = this.get(row, column);\n      var wantedCollectionIndex = wantedCollection ? this.mergedCells.indexOf(wantedCollection) : null;\n\n      if (wantedCollection && wantedCollectionIndex !== false) {\n        mergedCells.splice(wantedCollectionIndex, 1);\n        return wantedCollection;\n      }\n\n      return false;\n    }\n    /**\n     * Clear all the merged cells.\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var _this = this;\n\n      var mergedCells = this.mergedCells;\n      var mergedCellParentsToClear = [];\n      var hiddenCollectionElements = [];\n      arrayEach(mergedCells, function (mergedCell) {\n        var TD = _this.hot.getCell(mergedCell.row, mergedCell.col);\n\n        if (TD) {\n          mergedCellParentsToClear.push([TD, _this.get(mergedCell.row, mergedCell.col), mergedCell.row, mergedCell.col]);\n        }\n      });\n      this.mergedCells.length = 0;\n      arrayEach(mergedCellParentsToClear, function (mergedCell, i) {\n        rangeEach(0, mergedCell.rowspan - 1, function (j) {\n          rangeEach(0, mergedCell.colspan - 1, function (k) {\n            if (k !== 0 || j !== 0) {\n              var TD = _this.hot.getCell(mergedCell.row + j, mergedCell.col + k);\n\n              if (TD) {\n                hiddenCollectionElements.push([TD, null, null, null]);\n              }\n            }\n          });\n        });\n        mergedCellParentsToClear[i][1] = null;\n      });\n      arrayEach(mergedCellParentsToClear, function (mergedCellParents) {\n        applySpanProperties.apply(void 0, _toConsumableArray(mergedCellParents));\n      });\n      arrayEach(hiddenCollectionElements, function (hiddenCollectionElement) {\n        applySpanProperties.apply(void 0, _toConsumableArray(hiddenCollectionElement));\n      });\n    }\n    /**\n     * Check if the provided merged cell overlaps with the others in the container.\n     *\n     * @param {MergedCellCoords} mergedCell The merged cell to check against all others in the container.\n     * @return {Boolean} `true` if the provided merged cell overlaps with the others, `false` otherwise.\n     */\n\n  }, {\n    key: \"isOverlapping\",\n    value: function isOverlapping(mergedCell) {\n      var mergedCellRange = new CellRange(null, new CellCoords(mergedCell.row, mergedCell.col), new CellCoords(mergedCell.row + mergedCell.rowspan - 1, mergedCell.col + mergedCell.colspan - 1));\n      var result = false;\n      arrayEach(this.mergedCells, function (col) {\n        var currentRange = new CellRange(null, new CellCoords(col.row, col.col), new CellCoords(col.row + col.rowspan - 1, col.col + col.colspan - 1));\n\n        if (currentRange.overlaps(mergedCellRange)) {\n          result = true;\n          return false;\n        }\n\n        return true;\n      });\n      return result;\n    }\n    /**\n     * Check whether the provided row/col coordinates direct to a merged parent.\n     *\n     * @param {Number} row Row index.\n     * @param {Number} column Column index.\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"isMergedParent\",\n    value: function isMergedParent(row, column) {\n      var mergedCells = this.mergedCells;\n      var result = false;\n      arrayEach(mergedCells, function (mergedCell) {\n        if (mergedCell.row === row && mergedCell.col === column) {\n          result = true;\n          return false;\n        }\n\n        return true;\n      });\n      return result;\n    }\n    /**\n     * Shift the merged cell in the direction and by an offset defined in the arguments.\n     *\n     * @param {String} direction `right`, `left`, `up` or `down`.\n     * @param {Number} index Index where the change, which caused the shifting took place.\n     * @param {Number} count Number of rows/columns added/removed in the preceding action.\n     */\n\n  }, {\n    key: \"shiftCollections\",\n    value: function shiftCollections(direction, index, count) {\n      var _this2 = this;\n\n      var shiftVector = [0, 0];\n\n      switch (direction) {\n        case 'right':\n          shiftVector[0] += count;\n          break;\n\n        case 'left':\n          shiftVector[0] -= count;\n          break;\n\n        case 'down':\n          shiftVector[1] += count;\n          break;\n\n        case 'up':\n          shiftVector[1] -= count;\n          break;\n\n        default:\n      }\n\n      arrayEach(this.mergedCells, function (currentMerge) {\n        currentMerge.shift(shiftVector, index);\n      });\n      rangeEachReverse(this.mergedCells.length - 1, 0, function (i) {\n        var currentMerge = _this2.mergedCells[i];\n\n        if (currentMerge && currentMerge.removed) {\n          _this2.mergedCells.splice(_this2.mergedCells.indexOf(currentMerge), 1);\n        }\n      });\n    }\n  }], [{\n    key: \"IS_OVERLAPPING_WARNING\",\n    value: function IS_OVERLAPPING_WARNING(newMergedCell) {\n      return toSingleLine(_templateObject(), newMergedCell.row, newMergedCell.col);\n    }\n  }]);\n\n  return MergedCellsCollection;\n}();\n\nexport default MergedCellsCollection;"],"mappings":"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"},"metadata":{},"sourceType":"module"}