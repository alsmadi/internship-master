{"ast":null,"code":"import { arrayEach } from '../../../helpers/array';\nimport { isFormulaExpression } from '../utils';\nimport CellValue from '../cell/value';\nimport ExpressionModifier from '../expressionModifier';\n/**\n * When \"column_sorting\" is triggered the following operations must be performed:\n *\n * - All formulas which contain cell coordinates must be updated and saved into source data - Column must be changed\n *   (decreased or increased) depends on new target position - previous position.\n * - Mark all formulas which need update with \"STATE_OUT_OFF_DATE\" flag, so they can be recalculated after the operation.\n */\n\nexport var OPERATION_NAME = 'column_sorting';\nvar visualRows;\n/**\n * Collect all previous visual rows from CellValues.\n */\n\nexport function prepare() {\n  var matrix = this.matrix,\n    dataProvider = this.dataProvider;\n  visualRows = new WeakMap();\n  arrayEach(matrix.data, function (cell) {\n    visualRows.set(cell, dataProvider.t.toVisualRow(cell.row));\n  });\n}\n/**\n * Translate all CellValues depends on previous position.\n */\n\nexport function operate() {\n  var matrix = this.matrix,\n    dataProvider = this.dataProvider;\n  matrix.cellReferences.length = 0;\n  arrayEach(matrix.data, function (cell) {\n    cell.setState(CellValue.STATE_OUT_OFF_DATE);\n    cell.clearPrecedents();\n    var row = cell.row,\n      column = cell.column;\n    var value = dataProvider.getSourceDataAtCell(row, column);\n    if (isFormulaExpression(value)) {\n      var prevRow = visualRows.get(cell);\n      var expModifier = new ExpressionModifier(value);\n      expModifier.translate({\n        row: dataProvider.t.toVisualRow(row) - prevRow\n      });\n      dataProvider.updateSourceData(row, column, expModifier.toString());\n    }\n  });\n  visualRows = null;\n}","map":{"version":3,"names":["arrayEach","isFormulaExpression","CellValue","ExpressionModifier","OPERATION_NAME","visualRows","prepare","matrix","dataProvider","WeakMap","data","cell","set","t","toVisualRow","row","operate","cellReferences","length","setState","STATE_OUT_OFF_DATE","clearPrecedents","column","value","getSourceDataAtCell","prevRow","get","expModifier","translate","updateSourceData","toString"],"sources":["C:/Users/mrezy/VSCode/internships-master/node_modules/handsontable/es/plugins/formulas/alterOperation/columnSorting.js"],"sourcesContent":["import \"core-js/modules/es.array.iterator\";\nimport \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.regexp.to-string\";\nimport \"core-js/modules/es.string.iterator\";\nimport \"core-js/modules/es.weak-map\";\nimport \"core-js/modules/web.dom-collections.iterator\";\nimport { arrayEach } from '../../../helpers/array';\nimport { isFormulaExpression } from '../utils';\nimport CellValue from '../cell/value';\nimport ExpressionModifier from '../expressionModifier';\n/**\n * When \"column_sorting\" is triggered the following operations must be performed:\n *\n * - All formulas which contain cell coordinates must be updated and saved into source data - Column must be changed\n *   (decreased or increased) depends on new target position - previous position.\n * - Mark all formulas which need update with \"STATE_OUT_OFF_DATE\" flag, so they can be recalculated after the operation.\n */\n\nexport var OPERATION_NAME = 'column_sorting';\nvar visualRows;\n/**\n * Collect all previous visual rows from CellValues.\n */\n\nexport function prepare() {\n  var matrix = this.matrix,\n      dataProvider = this.dataProvider;\n  visualRows = new WeakMap();\n  arrayEach(matrix.data, function (cell) {\n    visualRows.set(cell, dataProvider.t.toVisualRow(cell.row));\n  });\n}\n/**\n * Translate all CellValues depends on previous position.\n */\n\nexport function operate() {\n  var matrix = this.matrix,\n      dataProvider = this.dataProvider;\n  matrix.cellReferences.length = 0;\n  arrayEach(matrix.data, function (cell) {\n    cell.setState(CellValue.STATE_OUT_OFF_DATE);\n    cell.clearPrecedents();\n    var row = cell.row,\n        column = cell.column;\n    var value = dataProvider.getSourceDataAtCell(row, column);\n\n    if (isFormulaExpression(value)) {\n      var prevRow = visualRows.get(cell);\n      var expModifier = new ExpressionModifier(value);\n      expModifier.translate({\n        row: dataProvider.t.toVisualRow(row) - prevRow\n      });\n      dataProvider.updateSourceData(row, column, expModifier.toString());\n    }\n  });\n  visualRows = null;\n}"],"mappings":"AAMA,SAASA,SAAS,QAAQ,wBAAwB;AAClD,SAASC,mBAAmB,QAAQ,UAAU;AAC9C,OAAOC,SAAS,MAAM,eAAe;AACrC,OAAOC,kBAAkB,MAAM,uBAAuB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,IAAIC,cAAc,GAAG,gBAAgB;AAC5C,IAAIC,UAAU;AACd;AACA;AACA;;AAEA,OAAO,SAASC,OAAO,GAAG;EACxB,IAAIC,MAAM,GAAG,IAAI,CAACA,MAAM;IACpBC,YAAY,GAAG,IAAI,CAACA,YAAY;EACpCH,UAAU,GAAG,IAAII,OAAO,EAAE;EAC1BT,SAAS,CAACO,MAAM,CAACG,IAAI,EAAE,UAAUC,IAAI,EAAE;IACrCN,UAAU,CAACO,GAAG,CAACD,IAAI,EAAEH,YAAY,CAACK,CAAC,CAACC,WAAW,CAACH,IAAI,CAACI,GAAG,CAAC,CAAC;EAC5D,CAAC,CAAC;AACJ;AACA;AACA;AACA;;AAEA,OAAO,SAASC,OAAO,GAAG;EACxB,IAAIT,MAAM,GAAG,IAAI,CAACA,MAAM;IACpBC,YAAY,GAAG,IAAI,CAACA,YAAY;EACpCD,MAAM,CAACU,cAAc,CAACC,MAAM,GAAG,CAAC;EAChClB,SAAS,CAACO,MAAM,CAACG,IAAI,EAAE,UAAUC,IAAI,EAAE;IACrCA,IAAI,CAACQ,QAAQ,CAACjB,SAAS,CAACkB,kBAAkB,CAAC;IAC3CT,IAAI,CAACU,eAAe,EAAE;IACtB,IAAIN,GAAG,GAAGJ,IAAI,CAACI,GAAG;MACdO,MAAM,GAAGX,IAAI,CAACW,MAAM;IACxB,IAAIC,KAAK,GAAGf,YAAY,CAACgB,mBAAmB,CAACT,GAAG,EAAEO,MAAM,CAAC;IAEzD,IAAIrB,mBAAmB,CAACsB,KAAK,CAAC,EAAE;MAC9B,IAAIE,OAAO,GAAGpB,UAAU,CAACqB,GAAG,CAACf,IAAI,CAAC;MAClC,IAAIgB,WAAW,GAAG,IAAIxB,kBAAkB,CAACoB,KAAK,CAAC;MAC/CI,WAAW,CAACC,SAAS,CAAC;QACpBb,GAAG,EAAEP,YAAY,CAACK,CAAC,CAACC,WAAW,CAACC,GAAG,CAAC,GAAGU;MACzC,CAAC,CAAC;MACFjB,YAAY,CAACqB,gBAAgB,CAACd,GAAG,EAAEO,MAAM,EAAEK,WAAW,CAACG,QAAQ,EAAE,CAAC;IACpE;EACF,CAAC,CAAC;EACFzB,UAAU,GAAG,IAAI;AACnB"},"metadata":{},"sourceType":"module"}