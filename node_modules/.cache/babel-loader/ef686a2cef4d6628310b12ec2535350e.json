{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nimport CellCoords from './../cell/coords';\n/**\n * CellRange holds cell coordinates as {@link CellCoords} instances. This object represent unit of the selection layer which\n * can contains multiple contiquous cells or single cell.\n *\n * @util\n */\n\nvar CellRange = /*#__PURE__*/\nfunction () {\n  function CellRange(highlight) {\n    var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : highlight;\n    var to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : highlight;\n    _classCallCheck(this, CellRange);\n\n    /**\n     * Used to draw bold border around a cell where selection was started and to edit the cell when you press Enter.\n     *\n     * @type {CellCoords}\n     */\n    this.highlight = highlight;\n    /**\n     * Usually the same as highlight, but in Excel there is distinction - one can change highlight within a selection.\n     *\n     * @type {CellCoords}\n     */\n\n    this.from = from;\n    /**\n     * End selection.\n     *\n     * @type {CellCoords}\n     */\n\n    this.to = to;\n  }\n  /**\n   * Set the new coordinates for highlighting selection.\n   *\n   * @param {CellCoords} coords Coordinates to use.\n   */\n\n  _createClass(CellRange, [{\n    key: \"setHighlight\",\n    value: function setHighlight(coords) {\n      this.highlight = coords;\n      return this;\n    }\n    /**\n     * Set the new coordinates where selection starts from.\n     *\n     * @param {CellCoords} coords Coordinates to use.\n     */\n  }, {\n    key: \"setFrom\",\n    value: function setFrom(coords) {\n      this.from = coords;\n      return this;\n    }\n    /**\n     * Set new coordinates where selection ends from.\n     *\n     * @param {CellCoords} coords Coordinates to use.\n     */\n  }, {\n    key: \"setTo\",\n    value: function setTo(coords) {\n      this.to = coords;\n      return this;\n    }\n    /**\n     * Checks if given coordinates are valid in context of a given Walkontable instance.\n     *\n     * @param {Walkontable} wot The Walkontable instance.\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"isValid\",\n    value: function isValid(wot) {\n      return this.from.isValid(wot) && this.to.isValid(wot);\n    }\n    /**\n     * Checks if this cell range is restricted to one cell\n     *\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"isSingle\",\n    value: function isSingle() {\n      return this.from.row === this.to.row && this.from.col === this.to.col;\n    }\n    /**\n     * Returns selected range height (in number of rows).\n     *\n     * @returns {Number}\n     */\n  }, {\n    key: \"getHeight\",\n    value: function getHeight() {\n      return Math.max(this.from.row, this.to.row) - Math.min(this.from.row, this.to.row) + 1;\n    }\n    /**\n     * Returns selected range width (in number of columns).\n     *\n     * @returns {Number}\n     */\n  }, {\n    key: \"getWidth\",\n    value: function getWidth() {\n      return Math.max(this.from.col, this.to.col) - Math.min(this.from.col, this.to.col) + 1;\n    }\n    /**\n     * Checks if given cell coordinates are within `from` and `to` cell coordinates of this range.\n     *\n     * @param {CellCoords} cellCoords The cell coordinates to check.\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"includes\",\n    value: function includes(cellCoords) {\n      var row = cellCoords.row,\n        col = cellCoords.col;\n      var topLeft = this.getTopLeftCorner();\n      var bottomRight = this.getBottomRightCorner();\n      return topLeft.row <= row && bottomRight.row >= row && topLeft.col <= col && bottomRight.col >= col;\n    }\n    /**\n     * Checks if given range is within of this range.\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"includesRange\",\n    value: function includesRange(cellRange) {\n      return this.includes(cellRange.getTopLeftCorner()) && this.includes(cellRange.getBottomRightCorner());\n    }\n    /**\n     * Checks if given range is equal to this range.\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(cellRange) {\n      return Math.min(this.from.row, this.to.row) === Math.min(cellRange.from.row, cellRange.to.row) && Math.max(this.from.row, this.to.row) === Math.max(cellRange.from.row, cellRange.to.row) && Math.min(this.from.col, this.to.col) === Math.min(cellRange.from.col, cellRange.to.col) && Math.max(this.from.col, this.to.col) === Math.max(cellRange.from.col, cellRange.to.col);\n    }\n    /**\n     * Checks if tested range overlaps with the range. Range A is considered to to be overlapping with range B\n     * if intersection of A and B or B and A is not empty.\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"overlaps\",\n    value: function overlaps(cellRange) {\n      return cellRange.isSouthEastOf(this.getTopLeftCorner()) && cellRange.isNorthWestOf(this.getBottomRightCorner());\n    }\n    /**\n     * Checks if tested coordinates are positioned in south-east from this cell range.\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"isSouthEastOf\",\n    value: function isSouthEastOf(cellRange) {\n      return this.getTopLeftCorner().isSouthEastOf(cellRange) || this.getBottomRightCorner().isSouthEastOf(cellRange);\n    }\n    /**\n     * Checks if tested coordinates are positioned in north-west from this cell range.\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"isNorthWestOf\",\n    value: function isNorthWestOf(cellRange) {\n      return this.getTopLeftCorner().isNorthWestOf(cellRange) || this.getBottomRightCorner().isNorthWestOf(cellRange);\n    }\n    /**\n     * Returns `true` if the provided range is overlapping the current range horizontally (e.g. the current range's last\n     * column is 5 and the provided range's first column is 3).\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"isOverlappingHorizontally\",\n    value: function isOverlappingHorizontally(cellRange) {\n      return this.getTopRightCorner().col >= cellRange.getTopLeftCorner().col && this.getTopRightCorner().col <= cellRange.getTopRightCorner().col || this.getTopLeftCorner().col <= cellRange.getTopRightCorner().col && this.getTopLeftCorner().col >= cellRange.getTopLeftCorner().col;\n    }\n    /**\n     * Returns `true` if the provided range is overlapping the current range vertically (e.g. the current range's last\n     *  row is 5 and the provided range's first row is 3).\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"isOverlappingVertically\",\n    value: function isOverlappingVertically(cellRange) {\n      return this.getBottomRightCorner().row >= cellRange.getTopRightCorner().row && this.getBottomRightCorner().row <= cellRange.getBottomRightCorner().row || this.getTopRightCorner().row <= cellRange.getBottomRightCorner().row && this.getTopRightCorner().row >= cellRange.getTopRightCorner().row;\n    }\n    /**\n     * Adds a cell to a range (only if exceeds corners of the range). Returns information if range was expanded.\n     *\n     * @param {CellCoords} cellCoords\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"expand\",\n    value: function expand(cellCoords) {\n      var topLeft = this.getTopLeftCorner();\n      var bottomRight = this.getBottomRightCorner();\n      if (cellCoords.row < topLeft.row || cellCoords.col < topLeft.col || cellCoords.row > bottomRight.row || cellCoords.col > bottomRight.col) {\n        this.from = new CellCoords(Math.min(topLeft.row, cellCoords.row), Math.min(topLeft.col, cellCoords.col));\n        this.to = new CellCoords(Math.max(bottomRight.row, cellCoords.row), Math.max(bottomRight.col, cellCoords.col));\n        return true;\n      }\n      return false;\n    }\n    /**\n     * Expand the current object by the range passed in the first argument.\n     *\n     * @param {CellRange} expandingRange Object extending the range.\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"expandByRange\",\n    value: function expandByRange(expandingRange) {\n      if (this.includesRange(expandingRange) || !this.overlaps(expandingRange)) {\n        return false;\n      }\n      var topLeft = this.getTopLeftCorner();\n      var bottomRight = this.getBottomRightCorner();\n      var initialDirection = this.getDirection();\n      var expandingTopLeft = expandingRange.getTopLeftCorner();\n      var expandingBottomRight = expandingRange.getBottomRightCorner();\n      var resultTopRow = Math.min(topLeft.row, expandingTopLeft.row);\n      var resultTopCol = Math.min(topLeft.col, expandingTopLeft.col);\n      var resultBottomRow = Math.max(bottomRight.row, expandingBottomRight.row);\n      var resultBottomCol = Math.max(bottomRight.col, expandingBottomRight.col);\n      var finalFrom = new CellCoords(resultTopRow, resultTopCol);\n      var finalTo = new CellCoords(resultBottomRow, resultBottomCol);\n      this.from = finalFrom;\n      this.to = finalTo;\n      this.setDirection(initialDirection);\n      if (this.highlight.row === this.getBottomRightCorner().row && this.getVerticalDirection() === 'N-S') {\n        this.flipDirectionVertically();\n      }\n      if (this.highlight.col === this.getTopRightCorner().col && this.getHorizontalDirection() === 'W-E') {\n        this.flipDirectionHorizontally();\n      }\n      return true;\n    }\n    /**\n     * Gets the direction of the selection.\n     *\n     * @returns {String} Returns one of the values: `'NW-SE'`, `'NE-SW'`, `'SE-NW'`, `'SW-NE'`.\n     */\n  }, {\n    key: \"getDirection\",\n    value: function getDirection() {\n      if (this.from.isNorthWestOf(this.to)) {\n        // NorthWest - SouthEast\n        return 'NW-SE';\n      } else if (this.from.isNorthEastOf(this.to)) {\n        // NorthEast - SouthWest\n        return 'NE-SW';\n      } else if (this.from.isSouthEastOf(this.to)) {\n        // SouthEast - NorthWest\n        return 'SE-NW';\n      } else if (this.from.isSouthWestOf(this.to)) {\n        // SouthWest - NorthEast\n        return 'SW-NE';\n      }\n    }\n    /**\n     * Sets the direction of the selection.\n     *\n     * @param {String} direction One of the values: `'NW-SE'`, `'NE-SW'`, `'SE-NW'`, `'SW-NE'`.\n     */\n  }, {\n    key: \"setDirection\",\n    value: function setDirection(direction) {\n      switch (direction) {\n        case 'NW-SE':\n          var _ref = [this.getTopLeftCorner(), this.getBottomRightCorner()];\n          this.from = _ref[0];\n          this.to = _ref[1];\n          break;\n        case 'NE-SW':\n          var _ref2 = [this.getTopRightCorner(), this.getBottomLeftCorner()];\n          this.from = _ref2[0];\n          this.to = _ref2[1];\n          break;\n        case 'SE-NW':\n          var _ref3 = [this.getBottomRightCorner(), this.getTopLeftCorner()];\n          this.from = _ref3[0];\n          this.to = _ref3[1];\n          break;\n        case 'SW-NE':\n          var _ref4 = [this.getBottomLeftCorner(), this.getTopRightCorner()];\n          this.from = _ref4[0];\n          this.to = _ref4[1];\n          break;\n        default:\n          break;\n      }\n    }\n    /**\n     * Gets the vertical direction of the range.\n     *\n     * @returns {String} Returns one of the values: `N-S` (north->south), `S-N` (south->north).\n     */\n  }, {\n    key: \"getVerticalDirection\",\n    value: function getVerticalDirection() {\n      return ['NE-SW', 'NW-SE'].indexOf(this.getDirection()) > -1 ? 'N-S' : 'S-N';\n    }\n    /**\n     * Gets the horizontal direction of the range.\n     *\n     * @returns {String} Returns one of the values: `W-E` (west->east), `E-W` (east->west).\n     */\n  }, {\n    key: \"getHorizontalDirection\",\n    value: function getHorizontalDirection() {\n      return ['NW-SE', 'SW-NE'].indexOf(this.getDirection()) > -1 ? 'W-E' : 'E-W';\n    }\n    /**\n     * Flip the direction vertically. (e.g. `NW-SE` changes to `SW-NE`).\n     */\n  }, {\n    key: \"flipDirectionVertically\",\n    value: function flipDirectionVertically() {\n      var direction = this.getDirection();\n      switch (direction) {\n        case 'NW-SE':\n          this.setDirection('SW-NE');\n          break;\n        case 'NE-SW':\n          this.setDirection('SE-NW');\n          break;\n        case 'SE-NW':\n          this.setDirection('NE-SW');\n          break;\n        case 'SW-NE':\n          this.setDirection('NW-SE');\n          break;\n        default:\n          break;\n      }\n    }\n    /**\n     * Flip the direction horizontally. (e.g. `NW-SE` changes to `NE-SW`).\n     */\n  }, {\n    key: \"flipDirectionHorizontally\",\n    value: function flipDirectionHorizontally() {\n      var direction = this.getDirection();\n      switch (direction) {\n        case 'NW-SE':\n          this.setDirection('NE-SW');\n          break;\n        case 'NE-SW':\n          this.setDirection('NW-SE');\n          break;\n        case 'SE-NW':\n          this.setDirection('SW-NE');\n          break;\n        case 'SW-NE':\n          this.setDirection('SE-NW');\n          break;\n        default:\n          break;\n      }\n    }\n    /**\n     * Gets the top left corner of this range.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getTopLeftCorner\",\n    value: function getTopLeftCorner() {\n      return new CellCoords(Math.min(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));\n    }\n    /**\n     * Gets the bottom right corner of this range.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getBottomRightCorner\",\n    value: function getBottomRightCorner() {\n      return new CellCoords(Math.max(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));\n    }\n    /**\n     * Gets the top right corner of this range.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getTopRightCorner\",\n    value: function getTopRightCorner() {\n      return new CellCoords(Math.min(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));\n    }\n    /**\n     * Gets the bottom left corner of this range.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getBottomLeftCorner\",\n    value: function getBottomLeftCorner() {\n      return new CellCoords(Math.max(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));\n    }\n    /**\n     * Checks if coordinates match to one of the 4th corners of this range.\n     *\n     * @param {CellCoords} coords Cell coordinates to check.\n     * @param {CellRange} [expandedRange]\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"isCorner\",\n    value: function isCorner(coords, expandedRange) {\n      if (expandedRange && expandedRange.includes(coords) && (this.getTopLeftCorner().isEqual(new CellCoords(expandedRange.from.row, expandedRange.from.col)) || this.getTopRightCorner().isEqual(new CellCoords(expandedRange.from.row, expandedRange.to.col)) || this.getBottomLeftCorner().isEqual(new CellCoords(expandedRange.to.row, expandedRange.from.col)) || this.getBottomRightCorner().isEqual(new CellCoords(expandedRange.to.row, expandedRange.to.col)))) {\n        return true;\n      }\n      return coords.isEqual(this.getTopLeftCorner()) || coords.isEqual(this.getTopRightCorner()) || coords.isEqual(this.getBottomLeftCorner()) || coords.isEqual(this.getBottomRightCorner());\n    }\n    /**\n     * Gets coordinates of the corner which is opposite to the matched. When the passed coordinates matched to the\n     * bottom-right corner of this range then the coordinates for top-left will be returned.\n     *\n     * @param {CellCoords} coords Cell coordinates to check.\n     * @param {CellRange} [expandedRange]\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getOppositeCorner\",\n    value: function getOppositeCorner(coords, expandedRange) {\n      if (!(coords instanceof CellCoords)) {\n        return false;\n      }\n      if (expandedRange) {\n        if (expandedRange.includes(coords)) {\n          if (this.getTopLeftCorner().isEqual(new CellCoords(expandedRange.from.row, expandedRange.from.col))) {\n            return this.getBottomRightCorner();\n          }\n          if (this.getTopRightCorner().isEqual(new CellCoords(expandedRange.from.row, expandedRange.to.col))) {\n            return this.getBottomLeftCorner();\n          }\n          if (this.getBottomLeftCorner().isEqual(new CellCoords(expandedRange.to.row, expandedRange.from.col))) {\n            return this.getTopRightCorner();\n          }\n          if (this.getBottomRightCorner().isEqual(new CellCoords(expandedRange.to.row, expandedRange.to.col))) {\n            return this.getTopLeftCorner();\n          }\n        }\n      }\n      if (coords.isEqual(this.getBottomRightCorner())) {\n        return this.getTopLeftCorner();\n      } else if (coords.isEqual(this.getTopLeftCorner())) {\n        return this.getBottomRightCorner();\n      } else if (coords.isEqual(this.getTopRightCorner())) {\n        return this.getBottomLeftCorner();\n      } else if (coords.isEqual(this.getBottomLeftCorner())) {\n        return this.getTopRightCorner();\n      }\n    }\n    /**\n     * @param {CellRange} range\n     * @returns {Array}\n     */\n  }, {\n    key: \"getBordersSharedWith\",\n    value: function getBordersSharedWith(range) {\n      if (!this.includesRange(range)) {\n        return [];\n      }\n      var thisBorders = {\n        top: Math.min(this.from.row, this.to.row),\n        bottom: Math.max(this.from.row, this.to.row),\n        left: Math.min(this.from.col, this.to.col),\n        right: Math.max(this.from.col, this.to.col)\n      };\n      var rangeBorders = {\n        top: Math.min(range.from.row, range.to.row),\n        bottom: Math.max(range.from.row, range.to.row),\n        left: Math.min(range.from.col, range.to.col),\n        right: Math.max(range.from.col, range.to.col)\n      };\n      var result = [];\n      if (thisBorders.top === rangeBorders.top) {\n        result.push('top');\n      }\n      if (thisBorders.right === rangeBorders.right) {\n        result.push('right');\n      }\n      if (thisBorders.bottom === rangeBorders.bottom) {\n        result.push('bottom');\n      }\n      if (thisBorders.left === rangeBorders.left) {\n        result.push('left');\n      }\n      return result;\n    }\n    /**\n     * Get inner selected cell coords defined by this range\n     *\n     * @returns {Array}\n     */\n  }, {\n    key: \"getInner\",\n    value: function getInner() {\n      var topLeft = this.getTopLeftCorner();\n      var bottomRight = this.getBottomRightCorner();\n      var out = [];\n      for (var r = topLeft.row; r <= bottomRight.row; r++) {\n        for (var c = topLeft.col; c <= bottomRight.col; c++) {\n          if (!(this.from.row === r && this.from.col === c) && !(this.to.row === r && this.to.col === c)) {\n            out.push(new CellCoords(r, c));\n          }\n        }\n      }\n      return out;\n    }\n    /**\n     * Get all selected cell coords defined by this range\n     *\n     * @returns {Array}\n     */\n  }, {\n    key: \"getAll\",\n    value: function getAll() {\n      var topLeft = this.getTopLeftCorner();\n      var bottomRight = this.getBottomRightCorner();\n      var out = [];\n      for (var r = topLeft.row; r <= bottomRight.row; r++) {\n        for (var c = topLeft.col; c <= bottomRight.col; c++) {\n          if (topLeft.row === r && topLeft.col === c) {\n            out.push(topLeft);\n          } else if (bottomRight.row === r && bottomRight.col === c) {\n            out.push(bottomRight);\n          } else {\n            out.push(new CellCoords(r, c));\n          }\n        }\n      }\n      return out;\n    }\n    /**\n     * Runs a callback function against all cells in the range. You can break the iteration by returning\n     * `false` in the callback function\n     *\n     * @param callback {Function}\n     */\n  }, {\n    key: \"forAll\",\n    value: function forAll(callback) {\n      var topLeft = this.getTopLeftCorner();\n      var bottomRight = this.getBottomRightCorner();\n      for (var r = topLeft.row; r <= bottomRight.row; r++) {\n        for (var c = topLeft.col; c <= bottomRight.col; c++) {\n          var breakIteration = callback(r, c);\n          if (breakIteration === false) {\n            return;\n          }\n        }\n      }\n    }\n    /**\n     * Convert CellRange to literal object.\n     *\n     * @return {Object} Returns a literal object with `from` and `to` properties which each of that object\n     *                  contains `row` and `col` keys.\n     */\n  }, {\n    key: \"toObject\",\n    value: function toObject() {\n      return {\n        from: this.from.toObject(),\n        to: this.to.toObject()\n      };\n    }\n  }]);\n  return CellRange;\n}();\nexport default CellRange;","map":{"version":3,"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","CellCoords","CellRange","highlight","from","arguments","undefined","to","value","setHighlight","coords","setFrom","setTo","isValid","wot","isSingle","row","col","getHeight","Math","max","min","getWidth","includes","cellCoords","topLeft","getTopLeftCorner","bottomRight","getBottomRightCorner","includesRange","cellRange","isEqual","overlaps","isSouthEastOf","isNorthWestOf","isOverlappingHorizontally","getTopRightCorner","isOverlappingVertically","expand","expandByRange","expandingRange","initialDirection","getDirection","expandingTopLeft","expandingBottomRight","resultTopRow","resultTopCol","resultBottomRow","resultBottomCol","finalFrom","finalTo","setDirection","getVerticalDirection","flipDirectionVertically","getHorizontalDirection","flipDirectionHorizontally","isNorthEastOf","isSouthWestOf","direction","_ref","_ref2","getBottomLeftCorner","_ref3","_ref4","indexOf","isCorner","expandedRange","getOppositeCorner","getBordersSharedWith","range","thisBorders","top","bottom","left","right","rangeBorders","result","push","getInner","out","r","c","getAll","forAll","callback","breakIteration","toObject"],"sources":["C:/Users/mrezy/VSCode/internships-master/node_modules/handsontable/es/3rdparty/walkontable/src/cell/range.js"],"sourcesContent":["import \"core-js/modules/es.array.includes\";\nimport \"core-js/modules/es.array.index-of\";\nimport \"core-js/modules/es.string.includes\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport CellCoords from './../cell/coords';\n/**\n * CellRange holds cell coordinates as {@link CellCoords} instances. This object represent unit of the selection layer which\n * can contains multiple contiquous cells or single cell.\n *\n * @util\n */\n\nvar CellRange =\n/*#__PURE__*/\nfunction () {\n  function CellRange(highlight) {\n    var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : highlight;\n    var to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : highlight;\n\n    _classCallCheck(this, CellRange);\n\n    /**\n     * Used to draw bold border around a cell where selection was started and to edit the cell when you press Enter.\n     *\n     * @type {CellCoords}\n     */\n    this.highlight = highlight;\n    /**\n     * Usually the same as highlight, but in Excel there is distinction - one can change highlight within a selection.\n     *\n     * @type {CellCoords}\n     */\n\n    this.from = from;\n    /**\n     * End selection.\n     *\n     * @type {CellCoords}\n     */\n\n    this.to = to;\n  }\n  /**\n   * Set the new coordinates for highlighting selection.\n   *\n   * @param {CellCoords} coords Coordinates to use.\n   */\n\n\n  _createClass(CellRange, [{\n    key: \"setHighlight\",\n    value: function setHighlight(coords) {\n      this.highlight = coords;\n      return this;\n    }\n    /**\n     * Set the new coordinates where selection starts from.\n     *\n     * @param {CellCoords} coords Coordinates to use.\n     */\n\n  }, {\n    key: \"setFrom\",\n    value: function setFrom(coords) {\n      this.from = coords;\n      return this;\n    }\n    /**\n     * Set new coordinates where selection ends from.\n     *\n     * @param {CellCoords} coords Coordinates to use.\n     */\n\n  }, {\n    key: \"setTo\",\n    value: function setTo(coords) {\n      this.to = coords;\n      return this;\n    }\n    /**\n     * Checks if given coordinates are valid in context of a given Walkontable instance.\n     *\n     * @param {Walkontable} wot The Walkontable instance.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isValid\",\n    value: function isValid(wot) {\n      return this.from.isValid(wot) && this.to.isValid(wot);\n    }\n    /**\n     * Checks if this cell range is restricted to one cell\n     *\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isSingle\",\n    value: function isSingle() {\n      return this.from.row === this.to.row && this.from.col === this.to.col;\n    }\n    /**\n     * Returns selected range height (in number of rows).\n     *\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"getHeight\",\n    value: function getHeight() {\n      return Math.max(this.from.row, this.to.row) - Math.min(this.from.row, this.to.row) + 1;\n    }\n    /**\n     * Returns selected range width (in number of columns).\n     *\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"getWidth\",\n    value: function getWidth() {\n      return Math.max(this.from.col, this.to.col) - Math.min(this.from.col, this.to.col) + 1;\n    }\n    /**\n     * Checks if given cell coordinates are within `from` and `to` cell coordinates of this range.\n     *\n     * @param {CellCoords} cellCoords The cell coordinates to check.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"includes\",\n    value: function includes(cellCoords) {\n      var row = cellCoords.row,\n          col = cellCoords.col;\n      var topLeft = this.getTopLeftCorner();\n      var bottomRight = this.getBottomRightCorner();\n      return topLeft.row <= row && bottomRight.row >= row && topLeft.col <= col && bottomRight.col >= col;\n    }\n    /**\n     * Checks if given range is within of this range.\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"includesRange\",\n    value: function includesRange(cellRange) {\n      return this.includes(cellRange.getTopLeftCorner()) && this.includes(cellRange.getBottomRightCorner());\n    }\n    /**\n     * Checks if given range is equal to this range.\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(cellRange) {\n      return Math.min(this.from.row, this.to.row) === Math.min(cellRange.from.row, cellRange.to.row) && Math.max(this.from.row, this.to.row) === Math.max(cellRange.from.row, cellRange.to.row) && Math.min(this.from.col, this.to.col) === Math.min(cellRange.from.col, cellRange.to.col) && Math.max(this.from.col, this.to.col) === Math.max(cellRange.from.col, cellRange.to.col);\n    }\n    /**\n     * Checks if tested range overlaps with the range. Range A is considered to to be overlapping with range B\n     * if intersection of A and B or B and A is not empty.\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"overlaps\",\n    value: function overlaps(cellRange) {\n      return cellRange.isSouthEastOf(this.getTopLeftCorner()) && cellRange.isNorthWestOf(this.getBottomRightCorner());\n    }\n    /**\n     * Checks if tested coordinates are positioned in south-east from this cell range.\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isSouthEastOf\",\n    value: function isSouthEastOf(cellRange) {\n      return this.getTopLeftCorner().isSouthEastOf(cellRange) || this.getBottomRightCorner().isSouthEastOf(cellRange);\n    }\n    /**\n     * Checks if tested coordinates are positioned in north-west from this cell range.\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isNorthWestOf\",\n    value: function isNorthWestOf(cellRange) {\n      return this.getTopLeftCorner().isNorthWestOf(cellRange) || this.getBottomRightCorner().isNorthWestOf(cellRange);\n    }\n    /**\n     * Returns `true` if the provided range is overlapping the current range horizontally (e.g. the current range's last\n     * column is 5 and the provided range's first column is 3).\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isOverlappingHorizontally\",\n    value: function isOverlappingHorizontally(cellRange) {\n      return this.getTopRightCorner().col >= cellRange.getTopLeftCorner().col && this.getTopRightCorner().col <= cellRange.getTopRightCorner().col || this.getTopLeftCorner().col <= cellRange.getTopRightCorner().col && this.getTopLeftCorner().col >= cellRange.getTopLeftCorner().col;\n    }\n    /**\n     * Returns `true` if the provided range is overlapping the current range vertically (e.g. the current range's last\n     *  row is 5 and the provided range's first row is 3).\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isOverlappingVertically\",\n    value: function isOverlappingVertically(cellRange) {\n      return this.getBottomRightCorner().row >= cellRange.getTopRightCorner().row && this.getBottomRightCorner().row <= cellRange.getBottomRightCorner().row || this.getTopRightCorner().row <= cellRange.getBottomRightCorner().row && this.getTopRightCorner().row >= cellRange.getTopRightCorner().row;\n    }\n    /**\n     * Adds a cell to a range (only if exceeds corners of the range). Returns information if range was expanded.\n     *\n     * @param {CellCoords} cellCoords\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"expand\",\n    value: function expand(cellCoords) {\n      var topLeft = this.getTopLeftCorner();\n      var bottomRight = this.getBottomRightCorner();\n\n      if (cellCoords.row < topLeft.row || cellCoords.col < topLeft.col || cellCoords.row > bottomRight.row || cellCoords.col > bottomRight.col) {\n        this.from = new CellCoords(Math.min(topLeft.row, cellCoords.row), Math.min(topLeft.col, cellCoords.col));\n        this.to = new CellCoords(Math.max(bottomRight.row, cellCoords.row), Math.max(bottomRight.col, cellCoords.col));\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Expand the current object by the range passed in the first argument.\n     *\n     * @param {CellRange} expandingRange Object extending the range.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"expandByRange\",\n    value: function expandByRange(expandingRange) {\n      if (this.includesRange(expandingRange) || !this.overlaps(expandingRange)) {\n        return false;\n      }\n\n      var topLeft = this.getTopLeftCorner();\n      var bottomRight = this.getBottomRightCorner();\n      var initialDirection = this.getDirection();\n      var expandingTopLeft = expandingRange.getTopLeftCorner();\n      var expandingBottomRight = expandingRange.getBottomRightCorner();\n      var resultTopRow = Math.min(topLeft.row, expandingTopLeft.row);\n      var resultTopCol = Math.min(topLeft.col, expandingTopLeft.col);\n      var resultBottomRow = Math.max(bottomRight.row, expandingBottomRight.row);\n      var resultBottomCol = Math.max(bottomRight.col, expandingBottomRight.col);\n      var finalFrom = new CellCoords(resultTopRow, resultTopCol);\n      var finalTo = new CellCoords(resultBottomRow, resultBottomCol);\n      this.from = finalFrom;\n      this.to = finalTo;\n      this.setDirection(initialDirection);\n\n      if (this.highlight.row === this.getBottomRightCorner().row && this.getVerticalDirection() === 'N-S') {\n        this.flipDirectionVertically();\n      }\n\n      if (this.highlight.col === this.getTopRightCorner().col && this.getHorizontalDirection() === 'W-E') {\n        this.flipDirectionHorizontally();\n      }\n\n      return true;\n    }\n    /**\n     * Gets the direction of the selection.\n     *\n     * @returns {String} Returns one of the values: `'NW-SE'`, `'NE-SW'`, `'SE-NW'`, `'SW-NE'`.\n     */\n\n  }, {\n    key: \"getDirection\",\n    value: function getDirection() {\n      if (this.from.isNorthWestOf(this.to)) {\n        // NorthWest - SouthEast\n        return 'NW-SE';\n      } else if (this.from.isNorthEastOf(this.to)) {\n        // NorthEast - SouthWest\n        return 'NE-SW';\n      } else if (this.from.isSouthEastOf(this.to)) {\n        // SouthEast - NorthWest\n        return 'SE-NW';\n      } else if (this.from.isSouthWestOf(this.to)) {\n        // SouthWest - NorthEast\n        return 'SW-NE';\n      }\n    }\n    /**\n     * Sets the direction of the selection.\n     *\n     * @param {String} direction One of the values: `'NW-SE'`, `'NE-SW'`, `'SE-NW'`, `'SW-NE'`.\n     */\n\n  }, {\n    key: \"setDirection\",\n    value: function setDirection(direction) {\n      switch (direction) {\n        case 'NW-SE':\n          var _ref = [this.getTopLeftCorner(), this.getBottomRightCorner()];\n          this.from = _ref[0];\n          this.to = _ref[1];\n          break;\n\n        case 'NE-SW':\n          var _ref2 = [this.getTopRightCorner(), this.getBottomLeftCorner()];\n          this.from = _ref2[0];\n          this.to = _ref2[1];\n          break;\n\n        case 'SE-NW':\n          var _ref3 = [this.getBottomRightCorner(), this.getTopLeftCorner()];\n          this.from = _ref3[0];\n          this.to = _ref3[1];\n          break;\n\n        case 'SW-NE':\n          var _ref4 = [this.getBottomLeftCorner(), this.getTopRightCorner()];\n          this.from = _ref4[0];\n          this.to = _ref4[1];\n          break;\n\n        default:\n          break;\n      }\n    }\n    /**\n     * Gets the vertical direction of the range.\n     *\n     * @returns {String} Returns one of the values: `N-S` (north->south), `S-N` (south->north).\n     */\n\n  }, {\n    key: \"getVerticalDirection\",\n    value: function getVerticalDirection() {\n      return ['NE-SW', 'NW-SE'].indexOf(this.getDirection()) > -1 ? 'N-S' : 'S-N';\n    }\n    /**\n     * Gets the horizontal direction of the range.\n     *\n     * @returns {String} Returns one of the values: `W-E` (west->east), `E-W` (east->west).\n     */\n\n  }, {\n    key: \"getHorizontalDirection\",\n    value: function getHorizontalDirection() {\n      return ['NW-SE', 'SW-NE'].indexOf(this.getDirection()) > -1 ? 'W-E' : 'E-W';\n    }\n    /**\n     * Flip the direction vertically. (e.g. `NW-SE` changes to `SW-NE`).\n     */\n\n  }, {\n    key: \"flipDirectionVertically\",\n    value: function flipDirectionVertically() {\n      var direction = this.getDirection();\n\n      switch (direction) {\n        case 'NW-SE':\n          this.setDirection('SW-NE');\n          break;\n\n        case 'NE-SW':\n          this.setDirection('SE-NW');\n          break;\n\n        case 'SE-NW':\n          this.setDirection('NE-SW');\n          break;\n\n        case 'SW-NE':\n          this.setDirection('NW-SE');\n          break;\n\n        default:\n          break;\n      }\n    }\n    /**\n     * Flip the direction horizontally. (e.g. `NW-SE` changes to `NE-SW`).\n     */\n\n  }, {\n    key: \"flipDirectionHorizontally\",\n    value: function flipDirectionHorizontally() {\n      var direction = this.getDirection();\n\n      switch (direction) {\n        case 'NW-SE':\n          this.setDirection('NE-SW');\n          break;\n\n        case 'NE-SW':\n          this.setDirection('NW-SE');\n          break;\n\n        case 'SE-NW':\n          this.setDirection('SW-NE');\n          break;\n\n        case 'SW-NE':\n          this.setDirection('SE-NW');\n          break;\n\n        default:\n          break;\n      }\n    }\n    /**\n     * Gets the top left corner of this range.\n     *\n     * @returns {CellCoords}\n     */\n\n  }, {\n    key: \"getTopLeftCorner\",\n    value: function getTopLeftCorner() {\n      return new CellCoords(Math.min(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));\n    }\n    /**\n     * Gets the bottom right corner of this range.\n     *\n     * @returns {CellCoords}\n     */\n\n  }, {\n    key: \"getBottomRightCorner\",\n    value: function getBottomRightCorner() {\n      return new CellCoords(Math.max(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));\n    }\n    /**\n     * Gets the top right corner of this range.\n     *\n     * @returns {CellCoords}\n     */\n\n  }, {\n    key: \"getTopRightCorner\",\n    value: function getTopRightCorner() {\n      return new CellCoords(Math.min(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));\n    }\n    /**\n     * Gets the bottom left corner of this range.\n     *\n     * @returns {CellCoords}\n     */\n\n  }, {\n    key: \"getBottomLeftCorner\",\n    value: function getBottomLeftCorner() {\n      return new CellCoords(Math.max(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));\n    }\n    /**\n     * Checks if coordinates match to one of the 4th corners of this range.\n     *\n     * @param {CellCoords} coords Cell coordinates to check.\n     * @param {CellRange} [expandedRange]\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isCorner\",\n    value: function isCorner(coords, expandedRange) {\n      if (expandedRange && expandedRange.includes(coords) && (this.getTopLeftCorner().isEqual(new CellCoords(expandedRange.from.row, expandedRange.from.col)) || this.getTopRightCorner().isEqual(new CellCoords(expandedRange.from.row, expandedRange.to.col)) || this.getBottomLeftCorner().isEqual(new CellCoords(expandedRange.to.row, expandedRange.from.col)) || this.getBottomRightCorner().isEqual(new CellCoords(expandedRange.to.row, expandedRange.to.col)))) {\n        return true;\n      }\n\n      return coords.isEqual(this.getTopLeftCorner()) || coords.isEqual(this.getTopRightCorner()) || coords.isEqual(this.getBottomLeftCorner()) || coords.isEqual(this.getBottomRightCorner());\n    }\n    /**\n     * Gets coordinates of the corner which is opposite to the matched. When the passed coordinates matched to the\n     * bottom-right corner of this range then the coordinates for top-left will be returned.\n     *\n     * @param {CellCoords} coords Cell coordinates to check.\n     * @param {CellRange} [expandedRange]\n     * @returns {CellCoords}\n     */\n\n  }, {\n    key: \"getOppositeCorner\",\n    value: function getOppositeCorner(coords, expandedRange) {\n      if (!(coords instanceof CellCoords)) {\n        return false;\n      }\n\n      if (expandedRange) {\n        if (expandedRange.includes(coords)) {\n          if (this.getTopLeftCorner().isEqual(new CellCoords(expandedRange.from.row, expandedRange.from.col))) {\n            return this.getBottomRightCorner();\n          }\n\n          if (this.getTopRightCorner().isEqual(new CellCoords(expandedRange.from.row, expandedRange.to.col))) {\n            return this.getBottomLeftCorner();\n          }\n\n          if (this.getBottomLeftCorner().isEqual(new CellCoords(expandedRange.to.row, expandedRange.from.col))) {\n            return this.getTopRightCorner();\n          }\n\n          if (this.getBottomRightCorner().isEqual(new CellCoords(expandedRange.to.row, expandedRange.to.col))) {\n            return this.getTopLeftCorner();\n          }\n        }\n      }\n\n      if (coords.isEqual(this.getBottomRightCorner())) {\n        return this.getTopLeftCorner();\n      } else if (coords.isEqual(this.getTopLeftCorner())) {\n        return this.getBottomRightCorner();\n      } else if (coords.isEqual(this.getTopRightCorner())) {\n        return this.getBottomLeftCorner();\n      } else if (coords.isEqual(this.getBottomLeftCorner())) {\n        return this.getTopRightCorner();\n      }\n    }\n    /**\n     * @param {CellRange} range\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getBordersSharedWith\",\n    value: function getBordersSharedWith(range) {\n      if (!this.includesRange(range)) {\n        return [];\n      }\n\n      var thisBorders = {\n        top: Math.min(this.from.row, this.to.row),\n        bottom: Math.max(this.from.row, this.to.row),\n        left: Math.min(this.from.col, this.to.col),\n        right: Math.max(this.from.col, this.to.col)\n      };\n      var rangeBorders = {\n        top: Math.min(range.from.row, range.to.row),\n        bottom: Math.max(range.from.row, range.to.row),\n        left: Math.min(range.from.col, range.to.col),\n        right: Math.max(range.from.col, range.to.col)\n      };\n      var result = [];\n\n      if (thisBorders.top === rangeBorders.top) {\n        result.push('top');\n      }\n\n      if (thisBorders.right === rangeBorders.right) {\n        result.push('right');\n      }\n\n      if (thisBorders.bottom === rangeBorders.bottom) {\n        result.push('bottom');\n      }\n\n      if (thisBorders.left === rangeBorders.left) {\n        result.push('left');\n      }\n\n      return result;\n    }\n    /**\n     * Get inner selected cell coords defined by this range\n     *\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getInner\",\n    value: function getInner() {\n      var topLeft = this.getTopLeftCorner();\n      var bottomRight = this.getBottomRightCorner();\n      var out = [];\n\n      for (var r = topLeft.row; r <= bottomRight.row; r++) {\n        for (var c = topLeft.col; c <= bottomRight.col; c++) {\n          if (!(this.from.row === r && this.from.col === c) && !(this.to.row === r && this.to.col === c)) {\n            out.push(new CellCoords(r, c));\n          }\n        }\n      }\n\n      return out;\n    }\n    /**\n     * Get all selected cell coords defined by this range\n     *\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getAll\",\n    value: function getAll() {\n      var topLeft = this.getTopLeftCorner();\n      var bottomRight = this.getBottomRightCorner();\n      var out = [];\n\n      for (var r = topLeft.row; r <= bottomRight.row; r++) {\n        for (var c = topLeft.col; c <= bottomRight.col; c++) {\n          if (topLeft.row === r && topLeft.col === c) {\n            out.push(topLeft);\n          } else if (bottomRight.row === r && bottomRight.col === c) {\n            out.push(bottomRight);\n          } else {\n            out.push(new CellCoords(r, c));\n          }\n        }\n      }\n\n      return out;\n    }\n    /**\n     * Runs a callback function against all cells in the range. You can break the iteration by returning\n     * `false` in the callback function\n     *\n     * @param callback {Function}\n     */\n\n  }, {\n    key: \"forAll\",\n    value: function forAll(callback) {\n      var topLeft = this.getTopLeftCorner();\n      var bottomRight = this.getBottomRightCorner();\n\n      for (var r = topLeft.row; r <= bottomRight.row; r++) {\n        for (var c = topLeft.col; c <= bottomRight.col; c++) {\n          var breakIteration = callback(r, c);\n\n          if (breakIteration === false) {\n            return;\n          }\n        }\n      }\n    }\n    /**\n     * Convert CellRange to literal object.\n     *\n     * @return {Object} Returns a literal object with `from` and `to` properties which each of that object\n     *                  contains `row` and `col` keys.\n     */\n\n  }, {\n    key: \"toObject\",\n    value: function toObject() {\n      return {\n        from: this.from.toObject(),\n        to: this.to.toObject()\n      };\n    }\n  }]);\n\n  return CellRange;\n}();\n\nexport default CellRange;"],"mappings":"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"},"metadata":{},"sourceType":"module"}