{"ast":null,"code":"function _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n    return arr2;\n  }\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nimport { hasClass, index, offset, removeClass, removeTextNodes, overlayContainsElement, closest, outerWidth, innerHeight, isVisible as _isVisible } from './../../../helpers/dom/element';\nimport { isFunction } from './../../../helpers/function';\nimport CellCoords from './cell/coords';\nimport ColumnFilter from './filter/column';\nimport RowFilter from './filter/row';\nimport { Renderer } from './renderer';\nimport Overlay from './overlay/_base';\nimport ColumnUtils from './utils/column';\nimport RowUtils from './utils/row';\n/**\n *\n */\n\nvar Table = /*#__PURE__*/\nfunction () {\n  /**\n   * @param {Walkontable} wotInstance\n   * @param {HTMLTableElement} table\n   */\n  function Table(wotInstance, table) {\n    var _this = this;\n    _classCallCheck(this, Table);\n\n    /**\n     * Indicates if this instance is of type `MasterTable` (i.e. it is NOT an overlay)\n     *\n     * @type {Boolean}\n     */\n    this.isMaster = !wotInstance.cloneOverlay; // \"instanceof\" operator isn't used, because it caused a circular reference in Webpack\n\n    this.wot = wotInstance; // legacy support\n\n    this.instance = this.wot;\n    this.TABLE = table;\n    this.TBODY = null;\n    this.THEAD = null;\n    this.COLGROUP = null;\n    this.tableOffset = 0;\n    this.holderOffset = 0;\n    /**\n     * Indicates if the table has height bigger than 0px.\n     *\n     * @type {Boolean}\n     */\n\n    this.hasTableHeight = true;\n    /**\n     * Indicates if the table has width bigger than 0px.\n     *\n     * @type {Boolean}\n     */\n\n    this.hasTableWidth = true;\n    /**\n     * Indicates if the table is visible. By visible, it means that the holder\n     * element has CSS 'display' property different than 'none'.\n     *\n     * @type {Boolean}\n     */\n\n    this.isTableVisible = false;\n    removeTextNodes(this.TABLE);\n    this.spreader = this.createSpreader(this.TABLE);\n    this.hider = this.createHider(this.spreader);\n    this.holder = this.createHolder(this.hider);\n    this.wtRootElement = this.holder.parentNode;\n    if (this.isMaster) {\n      this.alignOverlaysWithTrimmingContainer();\n    }\n    this.fixTableDomTree();\n    this.rowFilter = null;\n    this.columnFilter = null;\n    this.correctHeaderWidth = false;\n    var origRowHeaderWidth = this.wot.wtSettings.settings.rowHeaderWidth; // Fix for jumping row headers (https://github.com/handsontable/handsontable/issues/3850)\n\n    this.wot.wtSettings.settings.rowHeaderWidth = function () {\n      return _this._modifyRowHeaderWidth(origRowHeaderWidth);\n    };\n    this.rowUtils = new RowUtils(this.wot);\n    this.columnUtils = new ColumnUtils(this.wot);\n    this.tableRenderer = new Renderer({\n      TABLE: this.TABLE,\n      THEAD: this.THEAD,\n      COLGROUP: this.COLGROUP,\n      TBODY: this.TBODY,\n      rowUtils: this.rowUtils,\n      columnUtils: this.columnUtils,\n      cellRenderer: this.wot.wtSettings.settings.cellRenderer\n    });\n  }\n  /**\n   * Returns a boolean that is true if this intance of Table represents a specific overlay, identified by the overlay name.\n   * For MasterTable, it returns false.\n   *\n   * @param {String} overlayTypeName\n   * @returns {Boolean}\n   */\n\n  _createClass(Table, [{\n    key: \"is\",\n    value: function is(overlayTypeName) {\n      return Overlay.isOverlayTypeOf(this.wot.cloneOverlay, overlayTypeName);\n    }\n    /**\n     *\n     */\n  }, {\n    key: \"fixTableDomTree\",\n    value: function fixTableDomTree() {\n      var rootDocument = this.wot.rootDocument;\n      this.TBODY = this.TABLE.querySelector('tbody');\n      if (!this.TBODY) {\n        this.TBODY = rootDocument.createElement('tbody');\n        this.TABLE.appendChild(this.TBODY);\n      }\n      this.THEAD = this.TABLE.querySelector('thead');\n      if (!this.THEAD) {\n        this.THEAD = rootDocument.createElement('thead');\n        this.TABLE.insertBefore(this.THEAD, this.TBODY);\n      }\n      this.COLGROUP = this.TABLE.querySelector('colgroup');\n      if (!this.COLGROUP) {\n        this.COLGROUP = rootDocument.createElement('colgroup');\n        this.TABLE.insertBefore(this.COLGROUP, this.THEAD);\n      }\n      if (this.wot.getSetting('columnHeaders').length && !this.THEAD.childNodes.length) {\n        this.THEAD.appendChild(rootDocument.createElement('TR'));\n      }\n    }\n    /**\n     * @param table\n     * @returns {HTMLElement}\n     */\n  }, {\n    key: \"createSpreader\",\n    value: function createSpreader(table) {\n      var parent = table.parentNode;\n      var spreader;\n      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\n        spreader = this.wot.rootDocument.createElement('div');\n        spreader.className = 'wtSpreader';\n        if (parent) {\n          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n          parent.insertBefore(spreader, table);\n        }\n        spreader.appendChild(table);\n      }\n      spreader.style.position = 'relative';\n      return spreader;\n    }\n    /**\n     * @param spreader\n     * @returns {HTMLElement}\n     */\n  }, {\n    key: \"createHider\",\n    value: function createHider(spreader) {\n      var parent = spreader.parentNode;\n      var hider;\n      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\n        hider = this.wot.rootDocument.createElement('div');\n        hider.className = 'wtHider';\n        if (parent) {\n          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n          parent.insertBefore(hider, spreader);\n        }\n        hider.appendChild(spreader);\n      }\n      return hider;\n    }\n    /**\n     *\n     * @param hider\n     * @returns {HTMLElement}\n     */\n  }, {\n    key: \"createHolder\",\n    value: function createHolder(hider) {\n      var parent = hider.parentNode;\n      var holder;\n      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\n        holder = this.wot.rootDocument.createElement('div');\n        holder.style.position = 'relative';\n        holder.className = 'wtHolder';\n        if (parent) {\n          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n          parent.insertBefore(holder, hider);\n        }\n        if (this.isMaster) {\n          holder.parentNode.className += 'ht_master handsontable';\n        }\n        holder.appendChild(hider);\n      }\n      return holder;\n    }\n    /**\n     * Redraws the table\n     *\n     * @param {Boolean} [fastDraw=false] If TRUE, will try to avoid full redraw and only update the border positions.\n     *                                   If FALSE or UNDEFINED, will perform a full redraw.\n     * @returns {Table}\n     */\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var wot = this.wot;\n      var wtOverlays = wot.wtOverlays,\n        wtViewport = wot.wtViewport;\n      var totalRows = wot.getSetting('totalRows');\n      var totalColumns = wot.getSetting('totalColumns');\n      var rowHeaders = wot.getSetting('rowHeaders');\n      var rowHeadersCount = rowHeaders.length;\n      var columnHeaders = wot.getSetting('columnHeaders');\n      var columnHeadersCount = columnHeaders.length;\n      var syncScroll = false;\n      var runFastDraw = fastDraw;\n      if (this.isMaster) {\n        this.holderOffset = offset(this.holder);\n        runFastDraw = wtViewport.createRenderCalculators(runFastDraw);\n        if (rowHeadersCount && !wot.getSetting('fixedColumnsLeft')) {\n          var leftScrollPos = wtOverlays.leftOverlay.getScrollPosition();\n          var previousState = this.correctHeaderWidth;\n          this.correctHeaderWidth = leftScrollPos > 0;\n          if (previousState !== this.correctHeaderWidth) {\n            runFastDraw = false;\n          }\n        }\n      }\n      if (this.isMaster) {\n        syncScroll = wtOverlays.prepareOverlays();\n      }\n      if (runFastDraw) {\n        if (this.isMaster) {\n          // in case we only scrolled without redraw, update visible rows information in oldRowsCalculator\n          wtViewport.createVisibleCalculators();\n        }\n        if (wtOverlays) {\n          wtOverlays.refresh(true);\n        }\n      } else {\n        if (this.isMaster) {\n          this.tableOffset = offset(this.TABLE);\n        } else {\n          this.tableOffset = this.wot.cloneSource.wtTable.tableOffset;\n        }\n        var startRow = totalRows > 0 ? this.getFirstRenderedRow() : 0;\n        var startColumn = totalColumns > 0 ? this.getFirstRenderedColumn() : 0;\n        this.rowFilter = new RowFilter(startRow, totalRows, columnHeadersCount);\n        this.columnFilter = new ColumnFilter(startColumn, totalColumns, rowHeadersCount);\n        var performRedraw = true; // Only master table rendering can be skipped\n\n        if (this.isMaster) {\n          this.alignOverlaysWithTrimmingContainer();\n          var skipRender = {};\n          this.wot.getSetting('beforeDraw', true, skipRender);\n          performRedraw = skipRender.skipRender !== true;\n        }\n        if (performRedraw) {\n          this.tableRenderer.setHeaderContentRenderers(rowHeaders, columnHeaders);\n          if (this.is(Overlay.CLONE_BOTTOM) || this.is(Overlay.CLONE_BOTTOM_LEFT_CORNER)) {\n            // do NOT render headers on the bottom or bottom-left corner overlay\n            this.tableRenderer.setHeaderContentRenderers(rowHeaders, []);\n          }\n          this.resetOversizedRows();\n          this.tableRenderer.setViewportSize(this.getRenderedRowsCount(), this.getRenderedColumnsCount()).setFilters(this.rowFilter, this.columnFilter).render();\n          var workspaceWidth;\n          if (this.isMaster) {\n            workspaceWidth = this.wot.wtViewport.getWorkspaceWidth();\n            this.wot.wtViewport.containerWidth = null;\n            this.markOversizedColumnHeaders();\n          }\n          this.adjustColumnHeaderHeights();\n          if (this.isMaster || this.is(Overlay.CLONE_BOTTOM)) {\n            this.markOversizedRows();\n          }\n          if (this.isMaster) {\n            this.wot.wtViewport.createVisibleCalculators();\n            this.wot.wtOverlays.refresh(false);\n            this.wot.wtOverlays.applyToDOM();\n            var hiderWidth = outerWidth(this.hider);\n            var tableWidth = outerWidth(this.TABLE);\n            if (hiderWidth !== 0 && tableWidth !== hiderWidth) {\n              // Recalculate the column widths, if width changes made in the overlays removed the scrollbar, thus changing the viewport width.\n              this.columnUtils.calculateWidths();\n              this.tableRenderer.renderer.colGroup.render();\n            }\n            if (workspaceWidth !== this.wot.wtViewport.getWorkspaceWidth()) {\n              // workspace width changed though to shown/hidden vertical scrollbar. Let's reapply stretching\n              this.wot.wtViewport.containerWidth = null;\n              this.columnUtils.calculateWidths();\n              this.tableRenderer.renderer.colGroup.render();\n            }\n            this.wot.getSetting('onDraw', true);\n          } else if (this.is(Overlay.CLONE_BOTTOM)) {\n            this.wot.cloneSource.wtOverlays.adjustElementsSize();\n          }\n        }\n      }\n      this.refreshSelections(runFastDraw);\n      if (this.isMaster) {\n        wtOverlays.topOverlay.resetFixedPosition();\n        if (wtOverlays.bottomOverlay.clone) {\n          wtOverlays.bottomOverlay.resetFixedPosition();\n        }\n        wtOverlays.leftOverlay.resetFixedPosition();\n        if (wtOverlays.topLeftCornerOverlay) {\n          wtOverlays.topLeftCornerOverlay.resetFixedPosition();\n        }\n        if (wtOverlays.bottomLeftCornerOverlay && wtOverlays.bottomLeftCornerOverlay.clone) {\n          wtOverlays.bottomLeftCornerOverlay.resetFixedPosition();\n        }\n      }\n      if (syncScroll) {\n        wtOverlays.syncScrollWithMaster();\n      }\n      wot.drawn = true;\n      return this;\n    }\n  }, {\n    key: \"markIfOversizedColumnHeader\",\n    value: function markIfOversizedColumnHeader(col) {\n      var sourceColIndex = this.wot.wtTable.columnFilter.renderedToSource(col);\n      var level = this.wot.getSetting('columnHeaders').length;\n      var defaultRowHeight = this.wot.wtSettings.settings.defaultRowHeight;\n      var previousColHeaderHeight;\n      var currentHeader;\n      var currentHeaderHeight;\n      var columnHeaderHeightSetting = this.wot.getSetting('columnHeaderHeight') || [];\n      while (level) {\n        level -= 1;\n        previousColHeaderHeight = this.wot.wtTable.getColumnHeaderHeight(level);\n        currentHeader = this.wot.wtTable.getColumnHeader(sourceColIndex, level);\n        if (!currentHeader) {\n          /* eslint-disable no-continue */\n          continue;\n        }\n        currentHeaderHeight = innerHeight(currentHeader);\n        if (!previousColHeaderHeight && defaultRowHeight < currentHeaderHeight || previousColHeaderHeight < currentHeaderHeight) {\n          this.wot.wtViewport.oversizedColumnHeaders[level] = currentHeaderHeight;\n        }\n        if (Array.isArray(columnHeaderHeightSetting)) {\n          if (columnHeaderHeightSetting[level] !== null && columnHeaderHeightSetting[level] !== void 0) {\n            this.wot.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level];\n          }\n        } else if (!isNaN(columnHeaderHeightSetting)) {\n          this.wot.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting;\n        }\n        if (this.wot.wtViewport.oversizedColumnHeaders[level] < (columnHeaderHeightSetting[level] || columnHeaderHeightSetting)) {\n          this.wot.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level] || columnHeaderHeightSetting;\n        }\n      }\n    }\n  }, {\n    key: \"adjustColumnHeaderHeights\",\n    value: function adjustColumnHeaderHeights() {\n      var wot = this.wot;\n      var children = wot.wtTable.THEAD.childNodes;\n      var oversizedColumnHeaders = wot.wtViewport.oversizedColumnHeaders;\n      var columnHeaders = wot.getSetting('columnHeaders');\n      for (var i = 0, len = columnHeaders.length; i < len; i++) {\n        if (oversizedColumnHeaders[i]) {\n          if (!children[i] || children[i].childNodes.length === 0) {\n            return;\n          }\n          children[i].childNodes[0].style.height = \"\".concat(oversizedColumnHeaders[i], \"px\");\n        }\n      }\n    }\n    /**\n     * Resets cache of row heights. The cache should be cached for each render cycle in a case\n     * when new cell values have content which increases/decreases cell height.\n     */\n  }, {\n    key: \"resetOversizedRows\",\n    value: function resetOversizedRows() {\n      var wot = this.wot;\n      if (!this.isMaster && !this.is(Overlay.CLONE_BOTTOM)) {\n        return;\n      }\n      if (!wot.getSetting('externalRowCalculator')) {\n        var rowsToRender = this.getRenderedRowsCount(); // Reset the oversized row cache for rendered rows\n\n        for (var visibleRowIndex = 0; visibleRowIndex < rowsToRender; visibleRowIndex++) {\n          var sourceRow = this.rowFilter.renderedToSource(visibleRowIndex);\n          if (wot.wtViewport.oversizedRows && wot.wtViewport.oversizedRows[sourceRow]) {\n            wot.wtViewport.oversizedRows[sourceRow] = void 0;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"removeClassFromCells\",\n    value: function removeClassFromCells(className) {\n      var nodes = this.TABLE.querySelectorAll(\".\".concat(className));\n      for (var i = 0, len = nodes.length; i < len; i++) {\n        removeClass(nodes[i], className);\n      }\n    }\n    /**\n     * Refresh the table selection by re-rendering Selection instances connected with that instance.\n     *\n     * @param {Boolean} fastDraw If fast drawing is enabled than additionally className clearing is applied.\n     */\n  }, {\n    key: \"refreshSelections\",\n    value: function refreshSelections(fastDraw) {\n      var wot = this.wot;\n      if (!wot.selections) {\n        return;\n      }\n      var highlights = Array.from(wot.selections);\n      var len = highlights.length;\n      if (fastDraw) {\n        var classesToRemove = [];\n        for (var i = 0; i < len; i++) {\n          var _highlights$i$setting = highlights[i].settings,\n            highlightHeaderClassName = _highlights$i$setting.highlightHeaderClassName,\n            highlightRowClassName = _highlights$i$setting.highlightRowClassName,\n            highlightColumnClassName = _highlights$i$setting.highlightColumnClassName;\n          var classNames = highlights[i].classNames;\n          var classNamesLength = classNames.length;\n          for (var j = 0; j < classNamesLength; j++) {\n            if (!classesToRemove.includes(classNames[j])) {\n              classesToRemove.push(classNames[j]);\n            }\n          }\n          if (highlightHeaderClassName && !classesToRemove.includes(highlightHeaderClassName)) {\n            classesToRemove.push(highlightHeaderClassName);\n          }\n          if (highlightRowClassName && !classesToRemove.includes(highlightRowClassName)) {\n            classesToRemove.push(highlightRowClassName);\n          }\n          if (highlightColumnClassName && !classesToRemove.includes(highlightColumnClassName)) {\n            classesToRemove.push(highlightColumnClassName);\n          }\n        }\n        var additionalClassesToRemove = wot.getSetting('onBeforeRemoveCellClassNames');\n        if (Array.isArray(additionalClassesToRemove)) {\n          for (var _i = 0; _i < additionalClassesToRemove.length; _i++) {\n            classesToRemove.push(additionalClassesToRemove[_i]);\n          }\n        }\n        var classesToRemoveLength = classesToRemove.length;\n        for (var _i2 = 0; _i2 < classesToRemoveLength; _i2++) {\n          // there was no rerender, so we need to remove classNames by ourselves\n          this.removeClassFromCells(classesToRemove[_i2]);\n        }\n      }\n      for (var _i3 = 0; _i3 < len; _i3++) {\n        highlights[_i3].draw(wot, fastDraw);\n      }\n    }\n    /**\n     * Get cell element at coords.\n     * Negative coords.row or coords.col are used to retrieve header cells. If there are multiple header levels, the\n     * negative value corresponds to the distance from the working area. For example, when there are 3 levels of column\n     * headers, coords.col=-1 corresponds to the most inner header element, while coords.col=-3 corresponds to the\n     * outmost header element.\n     *\n     * In case an element for the coords is not rendered, the method returns an error code.\n     * To produce the error code, the input parameters are validated in the order in which they\n     * are given. Thus, if both the row and the column coords are out of the rendered bounds,\n     * the method returns the error code for the row.\n     *\n     * @param {CellCoords} coords\n     * @returns {HTMLElement|Number} HTMLElement on success or Number one of the exit codes on error:\n     *  -1 row before viewport\n     *  -2 row after viewport\n     *  -3 column before viewport\n     *  -4 column after viewport\n     */\n  }, {\n    key: \"getCell\",\n    value: function getCell(coords) {\n      var row = coords.row;\n      var column = coords.col;\n      var hookResult = this.wot.getSetting('onModifyGetCellCoords', row, column);\n      if (hookResult && Array.isArray(hookResult)) {\n        var _hookResult = _slicedToArray(hookResult, 2);\n        row = _hookResult[0];\n        column = _hookResult[1];\n      }\n      if (this.isRowBeforeRenderedRows(row)) {\n        // row before rendered rows\n        return -1;\n      } else if (this.isRowAfterRenderedRows(row)) {\n        // row after rendered rows\n        return -2;\n      } else if (this.isColumnBeforeRenderedColumns(column)) {\n        // column before rendered columns\n        return -3;\n      } else if (this.isColumnAfterRenderedColumns(column)) {\n        // column after rendered columns\n        return -4;\n      }\n      if (row < 0) {\n        var columnHeaders = this.wot.getSetting('columnHeaders');\n        var columnHeadersCount = columnHeaders.length;\n        var zeroBasedHeaderLevel = columnHeadersCount + row;\n        return this.getColumnHeader(column, zeroBasedHeaderLevel);\n      }\n      var TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n      if (!TR && row >= 0) {\n        throw new Error('TR was expected to be rendered but is not');\n      }\n      var TD = TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(column)];\n      if (!TD && column >= 0) {\n        throw new Error('TD or TH was expected to be rendered but is not');\n      }\n      return TD;\n    }\n    /**\n     * getColumnHeader\n     *\n     * @param {Number} col Column index\n     * @param {Number} [level=0] Header level (0 = most distant to the table)\n     * @returns {Object} HTMLElement on success or undefined on error\n     */\n  }, {\n    key: \"getColumnHeader\",\n    value: function getColumnHeader(col) {\n      var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var TR = this.THEAD.childNodes[level];\n      if (TR) {\n        return TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(col)];\n      }\n    }\n    /**\n     * getRowHeader\n     *\n     * @param {Number} row Row index\n     * @returns {HTMLElement} HTMLElement on success or Number one of the exit codes on error: `null table doesn't have row headers`\n     */\n  }, {\n    key: \"getRowHeader\",\n    value: function getRowHeader(row) {\n      if (this.columnFilter.sourceColumnToVisibleRowHeadedColumn(0) === 0) {\n        return null;\n      }\n      var TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n      if (TR) {\n        return TR.childNodes[0];\n      }\n    }\n    /**\n     * Returns cell coords object for a given TD (or a child element of a TD element).\n     *\n     * @param {HTMLTableCellElement} TD A cell DOM element (or a child of one).\n     * @returns {CellCoords|null} The coordinates of the provided TD element (or the closest TD element) or null, if the provided element is not applicable.\n     */\n  }, {\n    key: \"getCoords\",\n    value: function getCoords(TD) {\n      var cellElement = TD;\n      if (cellElement.nodeName !== 'TD' && cellElement.nodeName !== 'TH') {\n        cellElement = closest(cellElement, ['TD', 'TH']);\n      }\n      if (cellElement === null) {\n        return null;\n      }\n      var TR = cellElement.parentNode;\n      var CONTAINER = TR.parentNode;\n      var row = index(TR);\n      var col = cellElement.cellIndex;\n      if (overlayContainsElement(Overlay.CLONE_TOP_LEFT_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(Overlay.CLONE_TOP, cellElement, this.wtRootElement)) {\n        if (CONTAINER.nodeName === 'THEAD') {\n          row -= CONTAINER.childNodes.length;\n        }\n      } else if (overlayContainsElement(Overlay.CLONE_BOTTOM_LEFT_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(Overlay.CLONE_BOTTOM, cellElement, this.wtRootElement)) {\n        var totalRows = this.wot.getSetting('totalRows');\n        row = totalRows - CONTAINER.childNodes.length + row;\n      } else if (CONTAINER === this.THEAD) {\n        row = this.rowFilter.visibleColHeadedRowToSourceRow(row);\n      } else {\n        row = this.rowFilter.renderedToSource(row);\n      }\n      if (overlayContainsElement(Overlay.CLONE_TOP_LEFT_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(Overlay.CLONE_LEFT, cellElement, this.wtRootElement) || overlayContainsElement(Overlay.CLONE_BOTTOM_LEFT_CORNER, cellElement, this.wtRootElement)) {\n        col = this.columnFilter.offsettedTH(col);\n      } else {\n        col = this.columnFilter.visibleRowHeadedColumnToSourceColumn(col);\n      }\n      return new CellCoords(row, col);\n    }\n    /**\n     * Check if any of the rendered rows is higher than expected, and if so, cache them\n     */\n  }, {\n    key: \"markOversizedRows\",\n    value: function markOversizedRows() {\n      if (this.wot.getSetting('externalRowCalculator')) {\n        return;\n      }\n      var rowCount = this.TBODY.childNodes.length;\n      var expectedTableHeight = rowCount * this.wot.wtSettings.settings.defaultRowHeight;\n      var actualTableHeight = innerHeight(this.TBODY) - 1;\n      var previousRowHeight;\n      var rowInnerHeight;\n      var sourceRowIndex;\n      var currentTr;\n      var rowHeader;\n      if (expectedTableHeight === actualTableHeight && !this.wot.getSetting('fixedRowsBottom')) {\n        // If the actual table height equals rowCount * default single row height, no row is oversized -> no need to iterate over them\n        return;\n      }\n      while (rowCount) {\n        rowCount -= 1;\n        sourceRowIndex = this.rowFilter.renderedToSource(rowCount);\n        previousRowHeight = this.getRowHeight(sourceRowIndex);\n        currentTr = this.getTrForRow(sourceRowIndex);\n        rowHeader = currentTr.querySelector('th');\n        if (rowHeader) {\n          rowInnerHeight = innerHeight(rowHeader);\n        } else {\n          rowInnerHeight = innerHeight(currentTr) - 1;\n        }\n        if (!previousRowHeight && this.wot.wtSettings.settings.defaultRowHeight < rowInnerHeight || previousRowHeight < rowInnerHeight) {\n          rowInnerHeight += 1;\n          this.wot.wtViewport.oversizedRows[sourceRowIndex] = rowInnerHeight;\n        }\n      }\n    }\n  }, {\n    key: \"getTrForRow\",\n    value: function getTrForRow(row) {\n      return this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n    }\n    /**\n     * 0-based index of column header\n     *\n     * @param {Number} level\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"isColumnHeaderLevelRendered\",\n    value: function isColumnHeaderLevelRendered(level) {\n      var columnHeaders = this.wot.getSetting('columnHeaders');\n      var columnHeadersCount = columnHeaders.length;\n      return level > columnHeadersCount - 1;\n    }\n    /**\n     * 0-based index of row header\n     *\n     * @param {Number} level\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"isRowHeaderLevelRendered\",\n    value: function isRowHeaderLevelRendered(level) {\n      var columnHeaders = this.wot.getSetting('rowHeaders');\n      var columnHeadersCount = columnHeaders.length;\n      return level > columnHeadersCount - 1;\n    }\n    /**\n     * Check if the given row index is smaller than the index of the first row that is currently redered\n     * and return TRUE in that case, or FALSE otherwise.\n     *\n     * Negative row index is used to check the header cells. As a simplification, it checks negative row index\n     * the same way as a regular row 0. You can interpret this as follows: If the row 0 is rendered, all header\n     * cells are also rendered.\n     *\n     * @param {Number} row\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"isRowBeforeRenderedRows\",\n    value: function isRowBeforeRenderedRows(row) {\n      var first = this.getFirstRenderedRow();\n      if (row < 0) {\n        row = 0;\n      }\n      if (first === -1) {\n        return true;\n      }\n      return row < first;\n    }\n  }, {\n    key: \"isRowAfterViewport\",\n    value: function isRowAfterViewport(row) {\n      return this.rowFilter && row > this.getLastVisibleRow();\n    }\n    /**\n     * Check if the given column index is larger than the index of the last column that is currently redered\n     * and return TRUE in that case, or FALSE otherwise.\n     *\n     * Negative column index is used to check the header cells.\n     *\n     * @param {Number} column\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"isRowAfterRenderedRows\",\n    value: function isRowAfterRenderedRows(row) {\n      if (row < 0) {\n        var columnHeaders = this.wot.getSetting('columnHeaders');\n        var columnHeadersCount = columnHeaders.length;\n        var zeroBasedHeaderLevel = columnHeadersCount + row;\n        return this.isColumnHeaderLevelRendered(zeroBasedHeaderLevel);\n      }\n      return row > this.getLastRenderedRow();\n    }\n  }, {\n    key: \"isColumnBeforeViewport\",\n    value: function isColumnBeforeViewport(column) {\n      return this.columnFilter && this.columnFilter.sourceToRendered(column) < 0 && column >= 0;\n    }\n    /**\n     * Check if the given column index is smaller than the index of the first column that is currently redered\n     * and return TRUE in that case, or FALSE otherwise.\n     *\n     * Negative column index is used to check the header cells. As a simplification, it checks negative column index\n     * the same way as a regular column 0. You can interpret this as follows: If the column 0 is rendered, all header\n     * cells are also rendered.\n     *\n     * @param {Number} column\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"isColumnBeforeRenderedColumns\",\n    value: function isColumnBeforeRenderedColumns(column) {\n      var first = this.getFirstRenderedColumn();\n      if (column < 0) {\n        column = 0;\n      }\n      if (first === -1) {\n        return true;\n      }\n      return column < first;\n    }\n  }, {\n    key: \"isColumnAfterViewport\",\n    value: function isColumnAfterViewport(column) {\n      return this.columnFilter && column > this.getLastVisibleColumn();\n    }\n    /**\n     * Check if the given column index is larger than the index of the last column that is currently redered\n     * and return TRUE in that case, or FALSE otherwise.\n     *\n     * Negative column index is used to check the header cells.\n     *\n     * @param {Number} column\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"isColumnAfterRenderedColumns\",\n    value: function isColumnAfterRenderedColumns(column) {\n      if (column < 0) {\n        var rowHeaders = this.wot.getSetting('rowHeaders');\n        var rowHeadersCount = rowHeaders.length;\n        var zeroBasedHeaderLevel = rowHeadersCount + column;\n        return this.isRowHeaderLevelRendered(zeroBasedHeaderLevel);\n      }\n      return this.columnFilter && column > this.getLastRenderedColumn();\n    }\n  }, {\n    key: \"isLastRowFullyVisible\",\n    value: function isLastRowFullyVisible() {\n      return this.getLastVisibleRow() === this.getLastRenderedRow();\n    }\n  }, {\n    key: \"isLastColumnFullyVisible\",\n    value: function isLastColumnFullyVisible() {\n      return this.getLastVisibleColumn() === this.getLastRenderedColumn();\n    }\n  }, {\n    key: \"allRowsInViewport\",\n    value: function allRowsInViewport() {\n      return this.wot.getSetting('totalRows') === this.getVisibleRowsCount();\n    }\n  }, {\n    key: \"allColumnsInViewport\",\n    value: function allColumnsInViewport() {\n      return this.wot.getSetting('totalColumns') === this.getVisibleColumnsCount();\n    }\n    /**\n     * Checks if any of the row's cells content exceeds its initial height, and if so, returns the oversized height\n     *\n     * @param {Number} sourceRow\n     * @returns {Number}\n     */\n  }, {\n    key: \"getRowHeight\",\n    value: function getRowHeight(sourceRow) {\n      return this.rowUtils.getHeight(sourceRow);\n    }\n  }, {\n    key: \"getColumnHeaderHeight\",\n    value: function getColumnHeaderHeight(level) {\n      return this.columnUtils.getHeaderHeight(level);\n    }\n  }, {\n    key: \"getColumnWidth\",\n    value: function getColumnWidth(sourceColumn) {\n      return this.columnUtils.getWidth(sourceColumn);\n    }\n  }, {\n    key: \"getStretchedColumnWidth\",\n    value: function getStretchedColumnWidth(sourceColumn) {\n      return this.columnUtils.getStretchedColumnWidth(sourceColumn);\n    }\n    /**\n     * Checks if the table has defined size. It returns `true` when the table has width and height\n     * set bigger than `0px`.\n     *\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"hasDefinedSize\",\n    value: function hasDefinedSize() {\n      return this.hasTableHeight && this.hasTableWidth;\n    }\n    /**\n     * Checks if the table is visible. It returns `true` when the holder element (or its parents)\n     * has CSS 'display' property different than 'none'.\n     *\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"isVisible\",\n    value: function isVisible() {\n      return _isVisible(this.TABLE);\n    }\n    /**\n     * Modify row header widths provided by user in class contructor.\n     *\n     * @private\n     */\n  }, {\n    key: \"_modifyRowHeaderWidth\",\n    value: function _modifyRowHeaderWidth(rowHeaderWidthFactory) {\n      var widths = isFunction(rowHeaderWidthFactory) ? rowHeaderWidthFactory() : null;\n      if (Array.isArray(widths)) {\n        widths = _toConsumableArray(widths);\n        widths[widths.length - 1] = this._correctRowHeaderWidth(widths[widths.length - 1]);\n      } else {\n        widths = this._correctRowHeaderWidth(widths);\n      }\n      return widths;\n    }\n    /**\n     * Correct row header width if necessary.\n     *\n     * @private\n     */\n  }, {\n    key: \"_correctRowHeaderWidth\",\n    value: function _correctRowHeaderWidth(width) {\n      var rowHeaderWidth = width;\n      if (typeof width !== 'number') {\n        rowHeaderWidth = this.wot.getSetting('defaultColumnWidth');\n      }\n      if (this.correctHeaderWidth) {\n        rowHeaderWidth += 1;\n      }\n      return rowHeaderWidth;\n    }\n  }]);\n  return Table;\n}();\nexport default Table;","map":{"version":3,"names":["_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","Object","prototype","toString","call","Array","from","isArray","i","arr2","length","_slicedToArray","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","_arr","_n","_d","_e","undefined","_i","_s","next","done","push","value","err","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","hasClass","index","offset","removeClass","removeTextNodes","overlayContainsElement","closest","outerWidth","innerHeight","isVisible","_isVisible","isFunction","CellCoords","ColumnFilter","RowFilter","Renderer","Overlay","ColumnUtils","RowUtils","Table","wotInstance","table","_this","isMaster","cloneOverlay","wot","TABLE","TBODY","THEAD","COLGROUP","tableOffset","holderOffset","hasTableHeight","hasTableWidth","isTableVisible","spreader","createSpreader","hider","createHider","holder","createHolder","wtRootElement","parentNode","alignOverlaysWithTrimmingContainer","fixTableDomTree","rowFilter","columnFilter","correctHeaderWidth","origRowHeaderWidth","wtSettings","settings","rowHeaderWidth","_modifyRowHeaderWidth","rowUtils","columnUtils","tableRenderer","cellRenderer","is","overlayTypeName","isOverlayTypeOf","rootDocument","querySelector","createElement","appendChild","insertBefore","getSetting","childNodes","parent","nodeType","Node","ELEMENT_NODE","className","style","position","draw","fastDraw","arguments","wtOverlays","wtViewport","totalRows","totalColumns","rowHeaders","rowHeadersCount","columnHeaders","columnHeadersCount","syncScroll","runFastDraw","createRenderCalculators","leftScrollPos","leftOverlay","getScrollPosition","previousState","prepareOverlays","createVisibleCalculators","refresh","cloneSource","wtTable","startRow","getFirstRenderedRow","startColumn","getFirstRenderedColumn","performRedraw","skipRender","setHeaderContentRenderers","CLONE_BOTTOM","CLONE_BOTTOM_LEFT_CORNER","resetOversizedRows","setViewportSize","getRenderedRowsCount","getRenderedColumnsCount","setFilters","render","workspaceWidth","getWorkspaceWidth","containerWidth","markOversizedColumnHeaders","adjustColumnHeaderHeights","markOversizedRows","applyToDOM","hiderWidth","tableWidth","calculateWidths","renderer","colGroup","adjustElementsSize","refreshSelections","topOverlay","resetFixedPosition","bottomOverlay","clone","topLeftCornerOverlay","bottomLeftCornerOverlay","syncScrollWithMaster","drawn","markIfOversizedColumnHeader","col","sourceColIndex","renderedToSource","level","defaultRowHeight","previousColHeaderHeight","currentHeader","currentHeaderHeight","columnHeaderHeightSetting","getColumnHeaderHeight","getColumnHeader","oversizedColumnHeaders","isNaN","children","len","height","concat","rowsToRender","visibleRowIndex","sourceRow","oversizedRows","removeClassFromCells","nodes","querySelectorAll","selections","highlights","classesToRemove","_highlights$i$setting","highlightHeaderClassName","highlightRowClassName","highlightColumnClassName","classNames","classNamesLength","j","includes","additionalClassesToRemove","classesToRemoveLength","_i2","_i3","getCell","coords","row","column","hookResult","_hookResult","isRowBeforeRenderedRows","isRowAfterRenderedRows","isColumnBeforeRenderedColumns","isColumnAfterRenderedColumns","zeroBasedHeaderLevel","TR","sourceToRendered","Error","TD","sourceColumnToVisibleRowHeadedColumn","getRowHeader","getCoords","cellElement","nodeName","CONTAINER","cellIndex","CLONE_TOP_LEFT_CORNER","CLONE_TOP","visibleColHeadedRowToSourceRow","CLONE_LEFT","offsettedTH","visibleRowHeadedColumnToSourceColumn","rowCount","expectedTableHeight","actualTableHeight","previousRowHeight","rowInnerHeight","sourceRowIndex","currentTr","rowHeader","getRowHeight","getTrForRow","isColumnHeaderLevelRendered","isRowHeaderLevelRendered","first","isRowAfterViewport","getLastVisibleRow","getLastRenderedRow","isColumnBeforeViewport","isColumnAfterViewport","getLastVisibleColumn","getLastRenderedColumn","isLastRowFullyVisible","isLastColumnFullyVisible","allRowsInViewport","getVisibleRowsCount","allColumnsInViewport","getVisibleColumnsCount","getHeight","getHeaderHeight","getColumnWidth","sourceColumn","getWidth","getStretchedColumnWidth","hasDefinedSize","rowHeaderWidthFactory","widths","_correctRowHeaderWidth","width"],"sources":["C:/Users/mrezy/VSCode/internships-master/node_modules/handsontable/es/3rdparty/walkontable/src/table.js"],"sourcesContent":["import \"core-js/modules/es.symbol\";\nimport \"core-js/modules/es.symbol.description\";\nimport \"core-js/modules/es.symbol.iterator\";\nimport \"core-js/modules/es.array.from\";\nimport \"core-js/modules/es.array.includes\";\nimport \"core-js/modules/es.array.iterator\";\nimport \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.regexp.to-string\";\nimport \"core-js/modules/es.string.iterator\";\nimport \"core-js/modules/web.dom-collections.iterator\";\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport { hasClass, index, offset, removeClass, removeTextNodes, overlayContainsElement, closest, outerWidth, innerHeight, isVisible as _isVisible } from './../../../helpers/dom/element';\nimport { isFunction } from './../../../helpers/function';\nimport CellCoords from './cell/coords';\nimport ColumnFilter from './filter/column';\nimport RowFilter from './filter/row';\nimport { Renderer } from './renderer';\nimport Overlay from './overlay/_base';\nimport ColumnUtils from './utils/column';\nimport RowUtils from './utils/row';\n/**\n *\n */\n\nvar Table =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {Walkontable} wotInstance\n   * @param {HTMLTableElement} table\n   */\n  function Table(wotInstance, table) {\n    var _this = this;\n\n    _classCallCheck(this, Table);\n\n    /**\n     * Indicates if this instance is of type `MasterTable` (i.e. it is NOT an overlay)\n     *\n     * @type {Boolean}\n     */\n    this.isMaster = !wotInstance.cloneOverlay; // \"instanceof\" operator isn't used, because it caused a circular reference in Webpack\n\n    this.wot = wotInstance; // legacy support\n\n    this.instance = this.wot;\n    this.TABLE = table;\n    this.TBODY = null;\n    this.THEAD = null;\n    this.COLGROUP = null;\n    this.tableOffset = 0;\n    this.holderOffset = 0;\n    /**\n     * Indicates if the table has height bigger than 0px.\n     *\n     * @type {Boolean}\n     */\n\n    this.hasTableHeight = true;\n    /**\n     * Indicates if the table has width bigger than 0px.\n     *\n     * @type {Boolean}\n     */\n\n    this.hasTableWidth = true;\n    /**\n     * Indicates if the table is visible. By visible, it means that the holder\n     * element has CSS 'display' property different than 'none'.\n     *\n     * @type {Boolean}\n     */\n\n    this.isTableVisible = false;\n    removeTextNodes(this.TABLE);\n    this.spreader = this.createSpreader(this.TABLE);\n    this.hider = this.createHider(this.spreader);\n    this.holder = this.createHolder(this.hider);\n    this.wtRootElement = this.holder.parentNode;\n\n    if (this.isMaster) {\n      this.alignOverlaysWithTrimmingContainer();\n    }\n\n    this.fixTableDomTree();\n    this.rowFilter = null;\n    this.columnFilter = null;\n    this.correctHeaderWidth = false;\n    var origRowHeaderWidth = this.wot.wtSettings.settings.rowHeaderWidth; // Fix for jumping row headers (https://github.com/handsontable/handsontable/issues/3850)\n\n    this.wot.wtSettings.settings.rowHeaderWidth = function () {\n      return _this._modifyRowHeaderWidth(origRowHeaderWidth);\n    };\n\n    this.rowUtils = new RowUtils(this.wot);\n    this.columnUtils = new ColumnUtils(this.wot);\n    this.tableRenderer = new Renderer({\n      TABLE: this.TABLE,\n      THEAD: this.THEAD,\n      COLGROUP: this.COLGROUP,\n      TBODY: this.TBODY,\n      rowUtils: this.rowUtils,\n      columnUtils: this.columnUtils,\n      cellRenderer: this.wot.wtSettings.settings.cellRenderer\n    });\n  }\n  /**\n   * Returns a boolean that is true if this intance of Table represents a specific overlay, identified by the overlay name.\n   * For MasterTable, it returns false.\n   *\n   * @param {String} overlayTypeName\n   * @returns {Boolean}\n   */\n\n\n  _createClass(Table, [{\n    key: \"is\",\n    value: function is(overlayTypeName) {\n      return Overlay.isOverlayTypeOf(this.wot.cloneOverlay, overlayTypeName);\n    }\n    /**\n     *\n     */\n\n  }, {\n    key: \"fixTableDomTree\",\n    value: function fixTableDomTree() {\n      var rootDocument = this.wot.rootDocument;\n      this.TBODY = this.TABLE.querySelector('tbody');\n\n      if (!this.TBODY) {\n        this.TBODY = rootDocument.createElement('tbody');\n        this.TABLE.appendChild(this.TBODY);\n      }\n\n      this.THEAD = this.TABLE.querySelector('thead');\n\n      if (!this.THEAD) {\n        this.THEAD = rootDocument.createElement('thead');\n        this.TABLE.insertBefore(this.THEAD, this.TBODY);\n      }\n\n      this.COLGROUP = this.TABLE.querySelector('colgroup');\n\n      if (!this.COLGROUP) {\n        this.COLGROUP = rootDocument.createElement('colgroup');\n        this.TABLE.insertBefore(this.COLGROUP, this.THEAD);\n      }\n\n      if (this.wot.getSetting('columnHeaders').length && !this.THEAD.childNodes.length) {\n        this.THEAD.appendChild(rootDocument.createElement('TR'));\n      }\n    }\n    /**\n     * @param table\n     * @returns {HTMLElement}\n     */\n\n  }, {\n    key: \"createSpreader\",\n    value: function createSpreader(table) {\n      var parent = table.parentNode;\n      var spreader;\n\n      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\n        spreader = this.wot.rootDocument.createElement('div');\n        spreader.className = 'wtSpreader';\n\n        if (parent) {\n          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n          parent.insertBefore(spreader, table);\n        }\n\n        spreader.appendChild(table);\n      }\n\n      spreader.style.position = 'relative';\n      return spreader;\n    }\n    /**\n     * @param spreader\n     * @returns {HTMLElement}\n     */\n\n  }, {\n    key: \"createHider\",\n    value: function createHider(spreader) {\n      var parent = spreader.parentNode;\n      var hider;\n\n      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\n        hider = this.wot.rootDocument.createElement('div');\n        hider.className = 'wtHider';\n\n        if (parent) {\n          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n          parent.insertBefore(hider, spreader);\n        }\n\n        hider.appendChild(spreader);\n      }\n\n      return hider;\n    }\n    /**\n     *\n     * @param hider\n     * @returns {HTMLElement}\n     */\n\n  }, {\n    key: \"createHolder\",\n    value: function createHolder(hider) {\n      var parent = hider.parentNode;\n      var holder;\n\n      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\n        holder = this.wot.rootDocument.createElement('div');\n        holder.style.position = 'relative';\n        holder.className = 'wtHolder';\n\n        if (parent) {\n          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n          parent.insertBefore(holder, hider);\n        }\n\n        if (this.isMaster) {\n          holder.parentNode.className += 'ht_master handsontable';\n        }\n\n        holder.appendChild(hider);\n      }\n\n      return holder;\n    }\n    /**\n     * Redraws the table\n     *\n     * @param {Boolean} [fastDraw=false] If TRUE, will try to avoid full redraw and only update the border positions.\n     *                                   If FALSE or UNDEFINED, will perform a full redraw.\n     * @returns {Table}\n     */\n\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var wot = this.wot;\n      var wtOverlays = wot.wtOverlays,\n          wtViewport = wot.wtViewport;\n      var totalRows = wot.getSetting('totalRows');\n      var totalColumns = wot.getSetting('totalColumns');\n      var rowHeaders = wot.getSetting('rowHeaders');\n      var rowHeadersCount = rowHeaders.length;\n      var columnHeaders = wot.getSetting('columnHeaders');\n      var columnHeadersCount = columnHeaders.length;\n      var syncScroll = false;\n      var runFastDraw = fastDraw;\n\n      if (this.isMaster) {\n        this.holderOffset = offset(this.holder);\n        runFastDraw = wtViewport.createRenderCalculators(runFastDraw);\n\n        if (rowHeadersCount && !wot.getSetting('fixedColumnsLeft')) {\n          var leftScrollPos = wtOverlays.leftOverlay.getScrollPosition();\n          var previousState = this.correctHeaderWidth;\n          this.correctHeaderWidth = leftScrollPos > 0;\n\n          if (previousState !== this.correctHeaderWidth) {\n            runFastDraw = false;\n          }\n        }\n      }\n\n      if (this.isMaster) {\n        syncScroll = wtOverlays.prepareOverlays();\n      }\n\n      if (runFastDraw) {\n        if (this.isMaster) {\n          // in case we only scrolled without redraw, update visible rows information in oldRowsCalculator\n          wtViewport.createVisibleCalculators();\n        }\n\n        if (wtOverlays) {\n          wtOverlays.refresh(true);\n        }\n      } else {\n        if (this.isMaster) {\n          this.tableOffset = offset(this.TABLE);\n        } else {\n          this.tableOffset = this.wot.cloneSource.wtTable.tableOffset;\n        }\n\n        var startRow = totalRows > 0 ? this.getFirstRenderedRow() : 0;\n        var startColumn = totalColumns > 0 ? this.getFirstRenderedColumn() : 0;\n        this.rowFilter = new RowFilter(startRow, totalRows, columnHeadersCount);\n        this.columnFilter = new ColumnFilter(startColumn, totalColumns, rowHeadersCount);\n        var performRedraw = true; // Only master table rendering can be skipped\n\n        if (this.isMaster) {\n          this.alignOverlaysWithTrimmingContainer();\n          var skipRender = {};\n          this.wot.getSetting('beforeDraw', true, skipRender);\n          performRedraw = skipRender.skipRender !== true;\n        }\n\n        if (performRedraw) {\n          this.tableRenderer.setHeaderContentRenderers(rowHeaders, columnHeaders);\n\n          if (this.is(Overlay.CLONE_BOTTOM) || this.is(Overlay.CLONE_BOTTOM_LEFT_CORNER)) {\n            // do NOT render headers on the bottom or bottom-left corner overlay\n            this.tableRenderer.setHeaderContentRenderers(rowHeaders, []);\n          }\n\n          this.resetOversizedRows();\n          this.tableRenderer.setViewportSize(this.getRenderedRowsCount(), this.getRenderedColumnsCount()).setFilters(this.rowFilter, this.columnFilter).render();\n          var workspaceWidth;\n\n          if (this.isMaster) {\n            workspaceWidth = this.wot.wtViewport.getWorkspaceWidth();\n            this.wot.wtViewport.containerWidth = null;\n            this.markOversizedColumnHeaders();\n          }\n\n          this.adjustColumnHeaderHeights();\n\n          if (this.isMaster || this.is(Overlay.CLONE_BOTTOM)) {\n            this.markOversizedRows();\n          }\n\n          if (this.isMaster) {\n            this.wot.wtViewport.createVisibleCalculators();\n            this.wot.wtOverlays.refresh(false);\n            this.wot.wtOverlays.applyToDOM();\n            var hiderWidth = outerWidth(this.hider);\n            var tableWidth = outerWidth(this.TABLE);\n\n            if (hiderWidth !== 0 && tableWidth !== hiderWidth) {\n              // Recalculate the column widths, if width changes made in the overlays removed the scrollbar, thus changing the viewport width.\n              this.columnUtils.calculateWidths();\n              this.tableRenderer.renderer.colGroup.render();\n            }\n\n            if (workspaceWidth !== this.wot.wtViewport.getWorkspaceWidth()) {\n              // workspace width changed though to shown/hidden vertical scrollbar. Let's reapply stretching\n              this.wot.wtViewport.containerWidth = null;\n              this.columnUtils.calculateWidths();\n              this.tableRenderer.renderer.colGroup.render();\n            }\n\n            this.wot.getSetting('onDraw', true);\n          } else if (this.is(Overlay.CLONE_BOTTOM)) {\n            this.wot.cloneSource.wtOverlays.adjustElementsSize();\n          }\n        }\n      }\n\n      this.refreshSelections(runFastDraw);\n\n      if (this.isMaster) {\n        wtOverlays.topOverlay.resetFixedPosition();\n\n        if (wtOverlays.bottomOverlay.clone) {\n          wtOverlays.bottomOverlay.resetFixedPosition();\n        }\n\n        wtOverlays.leftOverlay.resetFixedPosition();\n\n        if (wtOverlays.topLeftCornerOverlay) {\n          wtOverlays.topLeftCornerOverlay.resetFixedPosition();\n        }\n\n        if (wtOverlays.bottomLeftCornerOverlay && wtOverlays.bottomLeftCornerOverlay.clone) {\n          wtOverlays.bottomLeftCornerOverlay.resetFixedPosition();\n        }\n      }\n\n      if (syncScroll) {\n        wtOverlays.syncScrollWithMaster();\n      }\n\n      wot.drawn = true;\n      return this;\n    }\n  }, {\n    key: \"markIfOversizedColumnHeader\",\n    value: function markIfOversizedColumnHeader(col) {\n      var sourceColIndex = this.wot.wtTable.columnFilter.renderedToSource(col);\n      var level = this.wot.getSetting('columnHeaders').length;\n      var defaultRowHeight = this.wot.wtSettings.settings.defaultRowHeight;\n      var previousColHeaderHeight;\n      var currentHeader;\n      var currentHeaderHeight;\n      var columnHeaderHeightSetting = this.wot.getSetting('columnHeaderHeight') || [];\n\n      while (level) {\n        level -= 1;\n        previousColHeaderHeight = this.wot.wtTable.getColumnHeaderHeight(level);\n        currentHeader = this.wot.wtTable.getColumnHeader(sourceColIndex, level);\n\n        if (!currentHeader) {\n          /* eslint-disable no-continue */\n          continue;\n        }\n\n        currentHeaderHeight = innerHeight(currentHeader);\n\n        if (!previousColHeaderHeight && defaultRowHeight < currentHeaderHeight || previousColHeaderHeight < currentHeaderHeight) {\n          this.wot.wtViewport.oversizedColumnHeaders[level] = currentHeaderHeight;\n        }\n\n        if (Array.isArray(columnHeaderHeightSetting)) {\n          if (columnHeaderHeightSetting[level] !== null && columnHeaderHeightSetting[level] !== void 0) {\n            this.wot.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level];\n          }\n        } else if (!isNaN(columnHeaderHeightSetting)) {\n          this.wot.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting;\n        }\n\n        if (this.wot.wtViewport.oversizedColumnHeaders[level] < (columnHeaderHeightSetting[level] || columnHeaderHeightSetting)) {\n          this.wot.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level] || columnHeaderHeightSetting;\n        }\n      }\n    }\n  }, {\n    key: \"adjustColumnHeaderHeights\",\n    value: function adjustColumnHeaderHeights() {\n      var wot = this.wot;\n      var children = wot.wtTable.THEAD.childNodes;\n      var oversizedColumnHeaders = wot.wtViewport.oversizedColumnHeaders;\n      var columnHeaders = wot.getSetting('columnHeaders');\n\n      for (var i = 0, len = columnHeaders.length; i < len; i++) {\n        if (oversizedColumnHeaders[i]) {\n          if (!children[i] || children[i].childNodes.length === 0) {\n            return;\n          }\n\n          children[i].childNodes[0].style.height = \"\".concat(oversizedColumnHeaders[i], \"px\");\n        }\n      }\n    }\n    /**\n     * Resets cache of row heights. The cache should be cached for each render cycle in a case\n     * when new cell values have content which increases/decreases cell height.\n     */\n\n  }, {\n    key: \"resetOversizedRows\",\n    value: function resetOversizedRows() {\n      var wot = this.wot;\n\n      if (!this.isMaster && !this.is(Overlay.CLONE_BOTTOM)) {\n        return;\n      }\n\n      if (!wot.getSetting('externalRowCalculator')) {\n        var rowsToRender = this.getRenderedRowsCount(); // Reset the oversized row cache for rendered rows\n\n        for (var visibleRowIndex = 0; visibleRowIndex < rowsToRender; visibleRowIndex++) {\n          var sourceRow = this.rowFilter.renderedToSource(visibleRowIndex);\n\n          if (wot.wtViewport.oversizedRows && wot.wtViewport.oversizedRows[sourceRow]) {\n            wot.wtViewport.oversizedRows[sourceRow] = void 0;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"removeClassFromCells\",\n    value: function removeClassFromCells(className) {\n      var nodes = this.TABLE.querySelectorAll(\".\".concat(className));\n\n      for (var i = 0, len = nodes.length; i < len; i++) {\n        removeClass(nodes[i], className);\n      }\n    }\n    /**\n     * Refresh the table selection by re-rendering Selection instances connected with that instance.\n     *\n     * @param {Boolean} fastDraw If fast drawing is enabled than additionally className clearing is applied.\n     */\n\n  }, {\n    key: \"refreshSelections\",\n    value: function refreshSelections(fastDraw) {\n      var wot = this.wot;\n\n      if (!wot.selections) {\n        return;\n      }\n\n      var highlights = Array.from(wot.selections);\n      var len = highlights.length;\n\n      if (fastDraw) {\n        var classesToRemove = [];\n\n        for (var i = 0; i < len; i++) {\n          var _highlights$i$setting = highlights[i].settings,\n              highlightHeaderClassName = _highlights$i$setting.highlightHeaderClassName,\n              highlightRowClassName = _highlights$i$setting.highlightRowClassName,\n              highlightColumnClassName = _highlights$i$setting.highlightColumnClassName;\n          var classNames = highlights[i].classNames;\n          var classNamesLength = classNames.length;\n\n          for (var j = 0; j < classNamesLength; j++) {\n            if (!classesToRemove.includes(classNames[j])) {\n              classesToRemove.push(classNames[j]);\n            }\n          }\n\n          if (highlightHeaderClassName && !classesToRemove.includes(highlightHeaderClassName)) {\n            classesToRemove.push(highlightHeaderClassName);\n          }\n\n          if (highlightRowClassName && !classesToRemove.includes(highlightRowClassName)) {\n            classesToRemove.push(highlightRowClassName);\n          }\n\n          if (highlightColumnClassName && !classesToRemove.includes(highlightColumnClassName)) {\n            classesToRemove.push(highlightColumnClassName);\n          }\n        }\n\n        var additionalClassesToRemove = wot.getSetting('onBeforeRemoveCellClassNames');\n\n        if (Array.isArray(additionalClassesToRemove)) {\n          for (var _i = 0; _i < additionalClassesToRemove.length; _i++) {\n            classesToRemove.push(additionalClassesToRemove[_i]);\n          }\n        }\n\n        var classesToRemoveLength = classesToRemove.length;\n\n        for (var _i2 = 0; _i2 < classesToRemoveLength; _i2++) {\n          // there was no rerender, so we need to remove classNames by ourselves\n          this.removeClassFromCells(classesToRemove[_i2]);\n        }\n      }\n\n      for (var _i3 = 0; _i3 < len; _i3++) {\n        highlights[_i3].draw(wot, fastDraw);\n      }\n    }\n    /**\n     * Get cell element at coords.\n     * Negative coords.row or coords.col are used to retrieve header cells. If there are multiple header levels, the\n     * negative value corresponds to the distance from the working area. For example, when there are 3 levels of column\n     * headers, coords.col=-1 corresponds to the most inner header element, while coords.col=-3 corresponds to the\n     * outmost header element.\n     *\n     * In case an element for the coords is not rendered, the method returns an error code.\n     * To produce the error code, the input parameters are validated in the order in which they\n     * are given. Thus, if both the row and the column coords are out of the rendered bounds,\n     * the method returns the error code for the row.\n     *\n     * @param {CellCoords} coords\n     * @returns {HTMLElement|Number} HTMLElement on success or Number one of the exit codes on error:\n     *  -1 row before viewport\n     *  -2 row after viewport\n     *  -3 column before viewport\n     *  -4 column after viewport\n     */\n\n  }, {\n    key: \"getCell\",\n    value: function getCell(coords) {\n      var row = coords.row;\n      var column = coords.col;\n      var hookResult = this.wot.getSetting('onModifyGetCellCoords', row, column);\n\n      if (hookResult && Array.isArray(hookResult)) {\n        var _hookResult = _slicedToArray(hookResult, 2);\n\n        row = _hookResult[0];\n        column = _hookResult[1];\n      }\n\n      if (this.isRowBeforeRenderedRows(row)) {\n        // row before rendered rows\n        return -1;\n      } else if (this.isRowAfterRenderedRows(row)) {\n        // row after rendered rows\n        return -2;\n      } else if (this.isColumnBeforeRenderedColumns(column)) {\n        // column before rendered columns\n        return -3;\n      } else if (this.isColumnAfterRenderedColumns(column)) {\n        // column after rendered columns\n        return -4;\n      }\n\n      if (row < 0) {\n        var columnHeaders = this.wot.getSetting('columnHeaders');\n        var columnHeadersCount = columnHeaders.length;\n        var zeroBasedHeaderLevel = columnHeadersCount + row;\n        return this.getColumnHeader(column, zeroBasedHeaderLevel);\n      }\n\n      var TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n\n      if (!TR && row >= 0) {\n        throw new Error('TR was expected to be rendered but is not');\n      }\n\n      var TD = TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(column)];\n\n      if (!TD && column >= 0) {\n        throw new Error('TD or TH was expected to be rendered but is not');\n      }\n\n      return TD;\n    }\n    /**\n     * getColumnHeader\n     *\n     * @param {Number} col Column index\n     * @param {Number} [level=0] Header level (0 = most distant to the table)\n     * @returns {Object} HTMLElement on success or undefined on error\n     */\n\n  }, {\n    key: \"getColumnHeader\",\n    value: function getColumnHeader(col) {\n      var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var TR = this.THEAD.childNodes[level];\n\n      if (TR) {\n        return TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(col)];\n      }\n    }\n    /**\n     * getRowHeader\n     *\n     * @param {Number} row Row index\n     * @returns {HTMLElement} HTMLElement on success or Number one of the exit codes on error: `null table doesn't have row headers`\n     */\n\n  }, {\n    key: \"getRowHeader\",\n    value: function getRowHeader(row) {\n      if (this.columnFilter.sourceColumnToVisibleRowHeadedColumn(0) === 0) {\n        return null;\n      }\n\n      var TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n\n      if (TR) {\n        return TR.childNodes[0];\n      }\n    }\n    /**\n     * Returns cell coords object for a given TD (or a child element of a TD element).\n     *\n     * @param {HTMLTableCellElement} TD A cell DOM element (or a child of one).\n     * @returns {CellCoords|null} The coordinates of the provided TD element (or the closest TD element) or null, if the provided element is not applicable.\n     */\n\n  }, {\n    key: \"getCoords\",\n    value: function getCoords(TD) {\n      var cellElement = TD;\n\n      if (cellElement.nodeName !== 'TD' && cellElement.nodeName !== 'TH') {\n        cellElement = closest(cellElement, ['TD', 'TH']);\n      }\n\n      if (cellElement === null) {\n        return null;\n      }\n\n      var TR = cellElement.parentNode;\n      var CONTAINER = TR.parentNode;\n      var row = index(TR);\n      var col = cellElement.cellIndex;\n\n      if (overlayContainsElement(Overlay.CLONE_TOP_LEFT_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(Overlay.CLONE_TOP, cellElement, this.wtRootElement)) {\n        if (CONTAINER.nodeName === 'THEAD') {\n          row -= CONTAINER.childNodes.length;\n        }\n      } else if (overlayContainsElement(Overlay.CLONE_BOTTOM_LEFT_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(Overlay.CLONE_BOTTOM, cellElement, this.wtRootElement)) {\n        var totalRows = this.wot.getSetting('totalRows');\n        row = totalRows - CONTAINER.childNodes.length + row;\n      } else if (CONTAINER === this.THEAD) {\n        row = this.rowFilter.visibleColHeadedRowToSourceRow(row);\n      } else {\n        row = this.rowFilter.renderedToSource(row);\n      }\n\n      if (overlayContainsElement(Overlay.CLONE_TOP_LEFT_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(Overlay.CLONE_LEFT, cellElement, this.wtRootElement) || overlayContainsElement(Overlay.CLONE_BOTTOM_LEFT_CORNER, cellElement, this.wtRootElement)) {\n        col = this.columnFilter.offsettedTH(col);\n      } else {\n        col = this.columnFilter.visibleRowHeadedColumnToSourceColumn(col);\n      }\n\n      return new CellCoords(row, col);\n    }\n    /**\n     * Check if any of the rendered rows is higher than expected, and if so, cache them\n     */\n\n  }, {\n    key: \"markOversizedRows\",\n    value: function markOversizedRows() {\n      if (this.wot.getSetting('externalRowCalculator')) {\n        return;\n      }\n\n      var rowCount = this.TBODY.childNodes.length;\n      var expectedTableHeight = rowCount * this.wot.wtSettings.settings.defaultRowHeight;\n      var actualTableHeight = innerHeight(this.TBODY) - 1;\n      var previousRowHeight;\n      var rowInnerHeight;\n      var sourceRowIndex;\n      var currentTr;\n      var rowHeader;\n\n      if (expectedTableHeight === actualTableHeight && !this.wot.getSetting('fixedRowsBottom')) {\n        // If the actual table height equals rowCount * default single row height, no row is oversized -> no need to iterate over them\n        return;\n      }\n\n      while (rowCount) {\n        rowCount -= 1;\n        sourceRowIndex = this.rowFilter.renderedToSource(rowCount);\n        previousRowHeight = this.getRowHeight(sourceRowIndex);\n        currentTr = this.getTrForRow(sourceRowIndex);\n        rowHeader = currentTr.querySelector('th');\n\n        if (rowHeader) {\n          rowInnerHeight = innerHeight(rowHeader);\n        } else {\n          rowInnerHeight = innerHeight(currentTr) - 1;\n        }\n\n        if (!previousRowHeight && this.wot.wtSettings.settings.defaultRowHeight < rowInnerHeight || previousRowHeight < rowInnerHeight) {\n          rowInnerHeight += 1;\n          this.wot.wtViewport.oversizedRows[sourceRowIndex] = rowInnerHeight;\n        }\n      }\n    }\n  }, {\n    key: \"getTrForRow\",\n    value: function getTrForRow(row) {\n      return this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n    }\n    /**\n     * 0-based index of column header\n     *\n     * @param {Number} level\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isColumnHeaderLevelRendered\",\n    value: function isColumnHeaderLevelRendered(level) {\n      var columnHeaders = this.wot.getSetting('columnHeaders');\n      var columnHeadersCount = columnHeaders.length;\n      return level > columnHeadersCount - 1;\n    }\n    /**\n     * 0-based index of row header\n     *\n     * @param {Number} level\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isRowHeaderLevelRendered\",\n    value: function isRowHeaderLevelRendered(level) {\n      var columnHeaders = this.wot.getSetting('rowHeaders');\n      var columnHeadersCount = columnHeaders.length;\n      return level > columnHeadersCount - 1;\n    }\n    /**\n     * Check if the given row index is smaller than the index of the first row that is currently redered\n     * and return TRUE in that case, or FALSE otherwise.\n     *\n     * Negative row index is used to check the header cells. As a simplification, it checks negative row index\n     * the same way as a regular row 0. You can interpret this as follows: If the row 0 is rendered, all header\n     * cells are also rendered.\n     *\n     * @param {Number} row\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isRowBeforeRenderedRows\",\n    value: function isRowBeforeRenderedRows(row) {\n      var first = this.getFirstRenderedRow();\n\n      if (row < 0) {\n        row = 0;\n      }\n\n      if (first === -1) {\n        return true;\n      }\n\n      return row < first;\n    }\n  }, {\n    key: \"isRowAfterViewport\",\n    value: function isRowAfterViewport(row) {\n      return this.rowFilter && row > this.getLastVisibleRow();\n    }\n    /**\n     * Check if the given column index is larger than the index of the last column that is currently redered\n     * and return TRUE in that case, or FALSE otherwise.\n     *\n     * Negative column index is used to check the header cells.\n     *\n     * @param {Number} column\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isRowAfterRenderedRows\",\n    value: function isRowAfterRenderedRows(row) {\n      if (row < 0) {\n        var columnHeaders = this.wot.getSetting('columnHeaders');\n        var columnHeadersCount = columnHeaders.length;\n        var zeroBasedHeaderLevel = columnHeadersCount + row;\n        return this.isColumnHeaderLevelRendered(zeroBasedHeaderLevel);\n      }\n\n      return row > this.getLastRenderedRow();\n    }\n  }, {\n    key: \"isColumnBeforeViewport\",\n    value: function isColumnBeforeViewport(column) {\n      return this.columnFilter && this.columnFilter.sourceToRendered(column) < 0 && column >= 0;\n    }\n    /**\n     * Check if the given column index is smaller than the index of the first column that is currently redered\n     * and return TRUE in that case, or FALSE otherwise.\n     *\n     * Negative column index is used to check the header cells. As a simplification, it checks negative column index\n     * the same way as a regular column 0. You can interpret this as follows: If the column 0 is rendered, all header\n     * cells are also rendered.\n     *\n     * @param {Number} column\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isColumnBeforeRenderedColumns\",\n    value: function isColumnBeforeRenderedColumns(column) {\n      var first = this.getFirstRenderedColumn();\n\n      if (column < 0) {\n        column = 0;\n      }\n\n      if (first === -1) {\n        return true;\n      }\n\n      return column < first;\n    }\n  }, {\n    key: \"isColumnAfterViewport\",\n    value: function isColumnAfterViewport(column) {\n      return this.columnFilter && column > this.getLastVisibleColumn();\n    }\n    /**\n     * Check if the given column index is larger than the index of the last column that is currently redered\n     * and return TRUE in that case, or FALSE otherwise.\n     *\n     * Negative column index is used to check the header cells.\n     *\n     * @param {Number} column\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isColumnAfterRenderedColumns\",\n    value: function isColumnAfterRenderedColumns(column) {\n      if (column < 0) {\n        var rowHeaders = this.wot.getSetting('rowHeaders');\n        var rowHeadersCount = rowHeaders.length;\n        var zeroBasedHeaderLevel = rowHeadersCount + column;\n        return this.isRowHeaderLevelRendered(zeroBasedHeaderLevel);\n      }\n\n      return this.columnFilter && column > this.getLastRenderedColumn();\n    }\n  }, {\n    key: \"isLastRowFullyVisible\",\n    value: function isLastRowFullyVisible() {\n      return this.getLastVisibleRow() === this.getLastRenderedRow();\n    }\n  }, {\n    key: \"isLastColumnFullyVisible\",\n    value: function isLastColumnFullyVisible() {\n      return this.getLastVisibleColumn() === this.getLastRenderedColumn();\n    }\n  }, {\n    key: \"allRowsInViewport\",\n    value: function allRowsInViewport() {\n      return this.wot.getSetting('totalRows') === this.getVisibleRowsCount();\n    }\n  }, {\n    key: \"allColumnsInViewport\",\n    value: function allColumnsInViewport() {\n      return this.wot.getSetting('totalColumns') === this.getVisibleColumnsCount();\n    }\n    /**\n     * Checks if any of the row's cells content exceeds its initial height, and if so, returns the oversized height\n     *\n     * @param {Number} sourceRow\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"getRowHeight\",\n    value: function getRowHeight(sourceRow) {\n      return this.rowUtils.getHeight(sourceRow);\n    }\n  }, {\n    key: \"getColumnHeaderHeight\",\n    value: function getColumnHeaderHeight(level) {\n      return this.columnUtils.getHeaderHeight(level);\n    }\n  }, {\n    key: \"getColumnWidth\",\n    value: function getColumnWidth(sourceColumn) {\n      return this.columnUtils.getWidth(sourceColumn);\n    }\n  }, {\n    key: \"getStretchedColumnWidth\",\n    value: function getStretchedColumnWidth(sourceColumn) {\n      return this.columnUtils.getStretchedColumnWidth(sourceColumn);\n    }\n    /**\n     * Checks if the table has defined size. It returns `true` when the table has width and height\n     * set bigger than `0px`.\n     *\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"hasDefinedSize\",\n    value: function hasDefinedSize() {\n      return this.hasTableHeight && this.hasTableWidth;\n    }\n    /**\n     * Checks if the table is visible. It returns `true` when the holder element (or its parents)\n     * has CSS 'display' property different than 'none'.\n     *\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isVisible\",\n    value: function isVisible() {\n      return _isVisible(this.TABLE);\n    }\n    /**\n     * Modify row header widths provided by user in class contructor.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_modifyRowHeaderWidth\",\n    value: function _modifyRowHeaderWidth(rowHeaderWidthFactory) {\n      var widths = isFunction(rowHeaderWidthFactory) ? rowHeaderWidthFactory() : null;\n\n      if (Array.isArray(widths)) {\n        widths = _toConsumableArray(widths);\n        widths[widths.length - 1] = this._correctRowHeaderWidth(widths[widths.length - 1]);\n      } else {\n        widths = this._correctRowHeaderWidth(widths);\n      }\n\n      return widths;\n    }\n    /**\n     * Correct row header width if necessary.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_correctRowHeaderWidth\",\n    value: function _correctRowHeaderWidth(width) {\n      var rowHeaderWidth = width;\n\n      if (typeof width !== 'number') {\n        rowHeaderWidth = this.wot.getSetting('defaultColumnWidth');\n      }\n\n      if (this.correctHeaderWidth) {\n        rowHeaderWidth += 1;\n      }\n\n      return rowHeaderWidth;\n    }\n  }]);\n\n  return Table;\n}();\n\nexport default Table;"],"mappings":"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"},"metadata":{},"sourceType":"module"}