{"ast":null,"code":"import \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.regexp.to-string\";\nimport { arrayEach } from '../../../helpers/array';\nimport { cellCoordFactory, isFormulaExpression } from '../utils';\nimport CellValue from '../cell/value';\nimport ExpressionModifier from '../expressionModifier';\n/**\n * When \"insert_row\" is triggered the following operations must be performed:\n *\n * - All formulas which contain cell coordinates must be updated and saved into source data - Row must be increased\n *   by \"amount\" of times (eq: D4 to D5, $F$5 to $F$6);\n * - Mark all formulas which need update with \"STATE_OUT_OFF_DATE\" flag, so they can be recalculated after the operation.\n */\n\nexport var OPERATION_NAME = 'insert_row';\n/**\n * Execute changes.\n *\n * @param {Number} start Index row from which the operation starts.\n * @param {Number} amount Count of rows to be inserted.\n * @param {Boolean} [modifyFormula=true] If `true` all formula expressions will be modified according to the changes.\n *                                       `false` value is used by UndoRedo plugin which saves snapshoots before alter\n *                                       operation so it doesn't modify formulas if undo action is triggered.\n */\n\nexport function operate(start, amount) {\n  var modifyFormula = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  var matrix = this.matrix,\n    dataProvider = this.dataProvider;\n  var translate = [amount, 0];\n  arrayEach(matrix.cellReferences, function (cell) {\n    if (cell.row >= start) {\n      cell.translateTo.apply(cell, translate);\n    }\n  });\n  arrayEach(matrix.data, function (cell) {\n    var origRow = cell.row,\n      origColumn = cell.column;\n    if (cell.row >= start) {\n      cell.translateTo.apply(cell, translate);\n      cell.setState(CellValue.STATE_OUT_OFF_DATE);\n    }\n    if (modifyFormula) {\n      var row = cell.row,\n        column = cell.column;\n      var value = dataProvider.getSourceDataAtCell(row, column);\n      if (isFormulaExpression(value)) {\n        var startCoord = cellCoordFactory('row', start);\n        var expModifier = new ExpressionModifier(value);\n        expModifier.useCustomModifier(customTranslateModifier);\n        expModifier.translate({\n          row: amount\n        }, startCoord({\n          row: origRow,\n          column: origColumn\n        }));\n        dataProvider.updateSourceData(row, column, expModifier.toString());\n      }\n    }\n  });\n}\nfunction customTranslateModifier(cell, axis, delta, startFromIndex) {\n  var start = cell.start,\n    end = cell.end;\n  var startIndex = start[axis].index;\n  var endIndex = end[axis].index;\n  var deltaStart = delta;\n  var deltaEnd = delta; // Do not translate cells above inserted row or on the left of inserted column\n\n  if (startFromIndex > startIndex) {\n    deltaStart = 0;\n  }\n  if (startFromIndex > endIndex) {\n    deltaEnd = 0;\n  }\n  return [deltaStart, deltaEnd, false];\n}","map":{"version":3,"names":["arrayEach","cellCoordFactory","isFormulaExpression","CellValue","ExpressionModifier","OPERATION_NAME","operate","start","amount","modifyFormula","arguments","length","undefined","matrix","dataProvider","translate","cellReferences","cell","row","translateTo","apply","data","origRow","origColumn","column","setState","STATE_OUT_OFF_DATE","value","getSourceDataAtCell","startCoord","expModifier","useCustomModifier","customTranslateModifier","updateSourceData","toString","axis","delta","startFromIndex","end","startIndex","index","endIndex","deltaStart","deltaEnd"],"sources":["C:/Users/mrezy/VSCode/internships-master/node_modules/handsontable/es/plugins/formulas/alterOperation/insertRow.js"],"sourcesContent":["import \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.regexp.to-string\";\nimport { arrayEach } from '../../../helpers/array';\nimport { cellCoordFactory, isFormulaExpression } from '../utils';\nimport CellValue from '../cell/value';\nimport ExpressionModifier from '../expressionModifier';\n/**\n * When \"insert_row\" is triggered the following operations must be performed:\n *\n * - All formulas which contain cell coordinates must be updated and saved into source data - Row must be increased\n *   by \"amount\" of times (eq: D4 to D5, $F$5 to $F$6);\n * - Mark all formulas which need update with \"STATE_OUT_OFF_DATE\" flag, so they can be recalculated after the operation.\n */\n\nexport var OPERATION_NAME = 'insert_row';\n/**\n * Execute changes.\n *\n * @param {Number} start Index row from which the operation starts.\n * @param {Number} amount Count of rows to be inserted.\n * @param {Boolean} [modifyFormula=true] If `true` all formula expressions will be modified according to the changes.\n *                                       `false` value is used by UndoRedo plugin which saves snapshoots before alter\n *                                       operation so it doesn't modify formulas if undo action is triggered.\n */\n\nexport function operate(start, amount) {\n  var modifyFormula = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  var matrix = this.matrix,\n      dataProvider = this.dataProvider;\n  var translate = [amount, 0];\n  arrayEach(matrix.cellReferences, function (cell) {\n    if (cell.row >= start) {\n      cell.translateTo.apply(cell, translate);\n    }\n  });\n  arrayEach(matrix.data, function (cell) {\n    var origRow = cell.row,\n        origColumn = cell.column;\n\n    if (cell.row >= start) {\n      cell.translateTo.apply(cell, translate);\n      cell.setState(CellValue.STATE_OUT_OFF_DATE);\n    }\n\n    if (modifyFormula) {\n      var row = cell.row,\n          column = cell.column;\n      var value = dataProvider.getSourceDataAtCell(row, column);\n\n      if (isFormulaExpression(value)) {\n        var startCoord = cellCoordFactory('row', start);\n        var expModifier = new ExpressionModifier(value);\n        expModifier.useCustomModifier(customTranslateModifier);\n        expModifier.translate({\n          row: amount\n        }, startCoord({\n          row: origRow,\n          column: origColumn\n        }));\n        dataProvider.updateSourceData(row, column, expModifier.toString());\n      }\n    }\n  });\n}\n\nfunction customTranslateModifier(cell, axis, delta, startFromIndex) {\n  var start = cell.start,\n      end = cell.end;\n  var startIndex = start[axis].index;\n  var endIndex = end[axis].index;\n  var deltaStart = delta;\n  var deltaEnd = delta; // Do not translate cells above inserted row or on the left of inserted column\n\n  if (startFromIndex > startIndex) {\n    deltaStart = 0;\n  }\n\n  if (startFromIndex > endIndex) {\n    deltaEnd = 0;\n  }\n\n  return [deltaStart, deltaEnd, false];\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}