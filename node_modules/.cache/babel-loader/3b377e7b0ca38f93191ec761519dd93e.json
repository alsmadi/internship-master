{"ast":null,"code":"import \"core-js/modules/es.symbol\";\nimport \"core-js/modules/es.symbol.description\";\nimport \"core-js/modules/es.symbol.iterator\";\nimport \"core-js/modules/es.array.from\";\nimport \"core-js/modules/es.array.includes\";\nimport \"core-js/modules/es.array.iterator\";\nimport \"core-js/modules/es.array.sort\";\nimport \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.regexp.to-string\";\nimport \"core-js/modules/es.set\";\nimport \"core-js/modules/es.string.includes\";\nimport \"core-js/modules/es.string.iterator\";\nimport \"core-js/modules/web.dom-collections.iterator\";\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nimport { CellRange } from './../3rdparty/walkontable/src';\nimport { arrayEach, arrayReduce } from './../helpers/array';\nimport { isUndefined } from './../helpers/mixed';\nexport var SELECTION_TYPE_UNRECOGNIZED = 0;\nexport var SELECTION_TYPE_EMPTY = 1;\nexport var SELECTION_TYPE_ARRAY = 2;\nexport var SELECTION_TYPE_OBJECT = 3;\nexport var SELECTION_TYPES = [SELECTION_TYPE_OBJECT, SELECTION_TYPE_ARRAY];\nvar ARRAY_TYPE_PATTERN = [['number'], ['number', 'string'], ['number', 'undefined'], ['number', 'string', 'undefined']];\nvar rootCall = Symbol('root');\nvar childCall = Symbol('child');\n/**\n * Detect selection schema structure.\n *\n * @param {*} selectionRanges The selected range or and array of selected ranges. This type of data is produced by\n *                            `hot.getSelected()`, `hot.getSelectedLast()`, `hot.getSelectedRange()`\n *                            and `hot.getSelectedRangeLast()` methods.\n * @returns {Number} Returns a number that specifies the type of detected selection schema. If selection schema type\n *                   is unrecognized than it returns `0`.\n */\n\nexport function detectSelectionType(selectionRanges) {\n  var _callSymbol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : rootCall;\n  if (_callSymbol !== rootCall && _callSymbol !== childCall) {\n    throw new Error('The second argument is used internally only and cannot be overwritten.');\n  }\n  var isArray = Array.isArray(selectionRanges);\n  var isRootCall = _callSymbol === rootCall;\n  var result = SELECTION_TYPE_UNRECOGNIZED;\n  if (isArray) {\n    var firstItem = selectionRanges[0];\n    if (selectionRanges.length === 0) {\n      result = SELECTION_TYPE_EMPTY;\n    } else if (isRootCall && firstItem instanceof CellRange) {\n      result = SELECTION_TYPE_OBJECT;\n    } else if (isRootCall && Array.isArray(firstItem)) {\n      result = detectSelectionType(firstItem, childCall);\n    } else if (selectionRanges.length >= 2 && selectionRanges.length <= 4) {\n      var isArrayType = !selectionRanges.some(function (value, index) {\n        return !ARRAY_TYPE_PATTERN[index].includes(_typeof(value));\n      });\n      if (isArrayType) {\n        result = SELECTION_TYPE_ARRAY;\n      }\n    }\n  }\n  return result;\n}\n/**\n * Factory function designed for normalization data schema from different data structures of the selection ranges.\n *\n * @param {String} type Selection type which will be processed.\n * @param {Object} [options]\n * @param {Boolean} [options.keepDirection=false] If `true`, the coordinates which contain the direction of the\n *                                                selected cells won't be changed. Otherwise, the selection will be\n *                                                normalized to values starting from top-left to bottom-right.\n * @param {Function} [options.propToCol] Pass the converting function (usually `datamap.propToCol`) if the column\n *                                       defined as props should be normalized to the numeric values.\n * @returns {Number[]} Returns normalized data about selected range as an array (`[rowStart, columnStart, rowEnd, columnEnd]`).\n */\n\nexport function normalizeSelectionFactory(type) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref$keepDirection = _ref.keepDirection,\n    keepDirection = _ref$keepDirection === void 0 ? false : _ref$keepDirection,\n    propToCol = _ref.propToCol;\n  if (!SELECTION_TYPES.includes(type)) {\n    throw new Error('Unsupported selection ranges schema type was provided.');\n  }\n  return function (selection) {\n    var isObjectType = type === SELECTION_TYPE_OBJECT;\n    var rowStart = isObjectType ? selection.from.row : selection[0];\n    var columnStart = isObjectType ? selection.from.col : selection[1];\n    var rowEnd = isObjectType ? selection.to.row : selection[2];\n    var columnEnd = isObjectType ? selection.to.col : selection[3];\n    if (typeof propToCol === 'function') {\n      if (typeof columnStart === 'string') {\n        columnStart = propToCol(columnStart);\n      }\n      if (typeof columnEnd === 'string') {\n        columnEnd = propToCol(columnEnd);\n      }\n    }\n    if (isUndefined(rowEnd)) {\n      rowEnd = rowStart;\n    }\n    if (isUndefined(columnEnd)) {\n      columnEnd = columnStart;\n    }\n    if (!keepDirection) {\n      var origRowStart = rowStart;\n      var origColumnStart = columnStart;\n      var origRowEnd = rowEnd;\n      var origColumnEnd = columnEnd;\n      rowStart = Math.min(origRowStart, origRowEnd);\n      columnStart = Math.min(origColumnStart, origColumnEnd);\n      rowEnd = Math.max(origRowStart, origRowEnd);\n      columnEnd = Math.max(origColumnStart, origColumnEnd);\n    }\n    return [rowStart, columnStart, rowEnd, columnEnd];\n  };\n}\n/**\n * Function transform selection ranges (produced by `hot.getSelected()` and `hot.getSelectedRange()`) to normalized\n * data structure. It merges repeated ranges into consecutive coordinates. The returned structure\n * contains an array of arrays. The single item contains at index 0 visual column index from the selection was\n * started and at index 1 distance as a count of selected columns.\n *\n * @param {Array[]|CellRange[]} selectionRanges Selection ranges produced by Handsontable.\n * @return {Array[]} Returns an array of arrays with ranges defines in that schema:\n *                   `[[visualColumnStart, distance], [visualColumnStart, distance], ...]`.\n *                   The column distances are always created starting from the left (zero index) to the\n *                   right (the latest column index).\n */\n\nexport function transformSelectionToColumnDistance(selectionRanges) {\n  var selectionType = detectSelectionType(selectionRanges);\n  if (selectionType === SELECTION_TYPE_UNRECOGNIZED || selectionType === SELECTION_TYPE_EMPTY) {\n    return [];\n  }\n  var selectionSchemaNormalizer = normalizeSelectionFactory(selectionType);\n  var unorderedIndexes = new Set(); // Iterate through all ranges and collect all column indexes which are not saved yet.\n\n  arrayEach(selectionRanges, function (selection) {\n    var _selectionSchemaNorma = selectionSchemaNormalizer(selection),\n      _selectionSchemaNorma2 = _slicedToArray(_selectionSchemaNorma, 4),\n      columnStart = _selectionSchemaNorma2[1],\n      columnEnd = _selectionSchemaNorma2[3];\n    var amount = columnEnd - columnStart + 1;\n    arrayEach(Array.from(new Array(amount), function (_, i) {\n      return columnStart + i;\n    }), function (index) {\n      if (!unorderedIndexes.has(index)) {\n        unorderedIndexes.add(index);\n      }\n    });\n  }); // Sort indexes in ascending order to easily detecting non-consecutive columns.\n\n  var orderedIndexes = Array.from(unorderedIndexes).sort(function (a, b) {\n    return a - b;\n  });\n  var normalizedColumnRanges = arrayReduce(orderedIndexes, function (acc, visualColumnIndex, index, array) {\n    if (index !== 0 && visualColumnIndex === array[index - 1] + 1) {\n      acc[acc.length - 1][1] += 1;\n    } else {\n      acc.push([visualColumnIndex, 1]);\n    }\n    return acc;\n  }, []);\n  return normalizedColumnRanges;\n}\n/**\n * Function transform selection ranges (produced by `hot.getSelected()` and `hot.getSelectedRange()`) to normalized\n * data structure. It merges repeated ranges into consecutive coordinates. The returned structure\n * contains an array of arrays. The single item contains at index 0 visual column index from the selection was\n * started and at index 1 distance as a count of selected columns.\n *\n * @param {Array[]|CellRange[]} selectionRanges Selection ranges produced by Handsontable.\n * @return {Array[]} Returns an array of arrays with ranges defines in that schema:\n *                   `[[visualColumnStart, distance], [visualColumnStart, distance], ...]`.\n *                   The column distances are always created starting from the left (zero index) to the\n *                   right (the latest column index).\n */\n\nexport function transformSelectionToRowDistance(selectionRanges) {\n  var selectionType = detectSelectionType(selectionRanges);\n  if (selectionType === SELECTION_TYPE_UNRECOGNIZED || selectionType === SELECTION_TYPE_EMPTY) {\n    return [];\n  }\n  var selectionSchemaNormalizer = normalizeSelectionFactory(selectionType);\n  var unorderedIndexes = new Set(); // Iterate through all ranges and collect all column indexes which are not saved yet.\n\n  arrayEach(selectionRanges, function (selection) {\n    var _selectionSchemaNorma3 = selectionSchemaNormalizer(selection),\n      _selectionSchemaNorma4 = _slicedToArray(_selectionSchemaNorma3, 3),\n      rowStart = _selectionSchemaNorma4[0],\n      rowEnd = _selectionSchemaNorma4[2];\n    var amount = rowEnd - rowStart + 1;\n    arrayEach(Array.from(new Array(amount), function (_, i) {\n      return rowStart + i;\n    }), function (index) {\n      if (!unorderedIndexes.has(index)) {\n        unorderedIndexes.add(index);\n      }\n    });\n  }); // Sort indexes in ascending order to easily detecting non-consecutive columns.\n\n  var orderedIndexes = Array.from(unorderedIndexes).sort(function (a, b) {\n    return a - b;\n  });\n  var normalizedRowRanges = arrayReduce(orderedIndexes, function (acc, rowIndex, index, array) {\n    if (index !== 0 && rowIndex === array[index - 1] + 1) {\n      acc[acc.length - 1][1] += 1;\n    } else {\n      acc.push([rowIndex, 1]);\n    }\n    return acc;\n  }, []);\n  return normalizedRowRanges;\n}\n/**\n * Check if passed value can be treated as valid cell coordinate. The second argument is\n * used to check if the value doesn't exceed the defined max table rows/columns count.\n *\n * @param {*} coord\n * @param {Number} maxTableItemsCount The value that declares the maximum coordinate that is still validatable.\n * @return {Boolean}\n */\n\nexport function isValidCoord(coord) {\n  var maxTableItemsCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;\n  return typeof coord === 'number' && coord >= 0 && coord < maxTableItemsCount;\n}","map":{"version":3,"names":["_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","TypeError","Symbol","iterator","Object","prototype","toString","call","_arr","_n","_d","_e","undefined","_i","_s","next","done","push","value","length","err","Array","isArray","_typeof","obj","constructor","CellRange","arrayEach","arrayReduce","isUndefined","SELECTION_TYPE_UNRECOGNIZED","SELECTION_TYPE_EMPTY","SELECTION_TYPE_ARRAY","SELECTION_TYPE_OBJECT","SELECTION_TYPES","ARRAY_TYPE_PATTERN","rootCall","childCall","detectSelectionType","selectionRanges","_callSymbol","arguments","Error","isRootCall","result","firstItem","isArrayType","some","index","includes","normalizeSelectionFactory","type","_ref","_ref$keepDirection","keepDirection","propToCol","selection","isObjectType","rowStart","from","row","columnStart","col","rowEnd","to","columnEnd","origRowStart","origColumnStart","origRowEnd","origColumnEnd","Math","min","max","transformSelectionToColumnDistance","selectionType","selectionSchemaNormalizer","unorderedIndexes","Set","_selectionSchemaNorma","_selectionSchemaNorma2","amount","_","has","add","orderedIndexes","sort","a","b","normalizedColumnRanges","acc","visualColumnIndex","array","transformSelectionToRowDistance","_selectionSchemaNorma3","_selectionSchemaNorma4","normalizedRowRanges","rowIndex","isValidCoord","coord","maxTableItemsCount","Infinity"],"sources":["C:/Users/mrezy/VSCode/internships-master/node_modules/handsontable/es/selection/utils.js"],"sourcesContent":["import \"core-js/modules/es.symbol\";\nimport \"core-js/modules/es.symbol.description\";\nimport \"core-js/modules/es.symbol.iterator\";\nimport \"core-js/modules/es.array.from\";\nimport \"core-js/modules/es.array.includes\";\nimport \"core-js/modules/es.array.iterator\";\nimport \"core-js/modules/es.array.some\";\nimport \"core-js/modules/es.array.sort\";\nimport \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.regexp.to-string\";\nimport \"core-js/modules/es.set\";\nimport \"core-js/modules/es.string.includes\";\nimport \"core-js/modules/es.string.iterator\";\nimport \"core-js/modules/web.dom-collections.iterator\";\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nimport { CellRange } from './../3rdparty/walkontable/src';\nimport { arrayEach, arrayReduce } from './../helpers/array';\nimport { isUndefined } from './../helpers/mixed';\nexport var SELECTION_TYPE_UNRECOGNIZED = 0;\nexport var SELECTION_TYPE_EMPTY = 1;\nexport var SELECTION_TYPE_ARRAY = 2;\nexport var SELECTION_TYPE_OBJECT = 3;\nexport var SELECTION_TYPES = [SELECTION_TYPE_OBJECT, SELECTION_TYPE_ARRAY];\nvar ARRAY_TYPE_PATTERN = [['number'], ['number', 'string'], ['number', 'undefined'], ['number', 'string', 'undefined']];\nvar rootCall = Symbol('root');\nvar childCall = Symbol('child');\n/**\n * Detect selection schema structure.\n *\n * @param {*} selectionRanges The selected range or and array of selected ranges. This type of data is produced by\n *                            `hot.getSelected()`, `hot.getSelectedLast()`, `hot.getSelectedRange()`\n *                            and `hot.getSelectedRangeLast()` methods.\n * @returns {Number} Returns a number that specifies the type of detected selection schema. If selection schema type\n *                   is unrecognized than it returns `0`.\n */\n\nexport function detectSelectionType(selectionRanges) {\n  var _callSymbol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : rootCall;\n\n  if (_callSymbol !== rootCall && _callSymbol !== childCall) {\n    throw new Error('The second argument is used internally only and cannot be overwritten.');\n  }\n\n  var isArray = Array.isArray(selectionRanges);\n  var isRootCall = _callSymbol === rootCall;\n  var result = SELECTION_TYPE_UNRECOGNIZED;\n\n  if (isArray) {\n    var firstItem = selectionRanges[0];\n\n    if (selectionRanges.length === 0) {\n      result = SELECTION_TYPE_EMPTY;\n    } else if (isRootCall && firstItem instanceof CellRange) {\n      result = SELECTION_TYPE_OBJECT;\n    } else if (isRootCall && Array.isArray(firstItem)) {\n      result = detectSelectionType(firstItem, childCall);\n    } else if (selectionRanges.length >= 2 && selectionRanges.length <= 4) {\n      var isArrayType = !selectionRanges.some(function (value, index) {\n        return !ARRAY_TYPE_PATTERN[index].includes(_typeof(value));\n      });\n\n      if (isArrayType) {\n        result = SELECTION_TYPE_ARRAY;\n      }\n    }\n  }\n\n  return result;\n}\n/**\n * Factory function designed for normalization data schema from different data structures of the selection ranges.\n *\n * @param {String} type Selection type which will be processed.\n * @param {Object} [options]\n * @param {Boolean} [options.keepDirection=false] If `true`, the coordinates which contain the direction of the\n *                                                selected cells won't be changed. Otherwise, the selection will be\n *                                                normalized to values starting from top-left to bottom-right.\n * @param {Function} [options.propToCol] Pass the converting function (usually `datamap.propToCol`) if the column\n *                                       defined as props should be normalized to the numeric values.\n * @returns {Number[]} Returns normalized data about selected range as an array (`[rowStart, columnStart, rowEnd, columnEnd]`).\n */\n\nexport function normalizeSelectionFactory(type) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$keepDirection = _ref.keepDirection,\n      keepDirection = _ref$keepDirection === void 0 ? false : _ref$keepDirection,\n      propToCol = _ref.propToCol;\n\n  if (!SELECTION_TYPES.includes(type)) {\n    throw new Error('Unsupported selection ranges schema type was provided.');\n  }\n\n  return function (selection) {\n    var isObjectType = type === SELECTION_TYPE_OBJECT;\n    var rowStart = isObjectType ? selection.from.row : selection[0];\n    var columnStart = isObjectType ? selection.from.col : selection[1];\n    var rowEnd = isObjectType ? selection.to.row : selection[2];\n    var columnEnd = isObjectType ? selection.to.col : selection[3];\n\n    if (typeof propToCol === 'function') {\n      if (typeof columnStart === 'string') {\n        columnStart = propToCol(columnStart);\n      }\n\n      if (typeof columnEnd === 'string') {\n        columnEnd = propToCol(columnEnd);\n      }\n    }\n\n    if (isUndefined(rowEnd)) {\n      rowEnd = rowStart;\n    }\n\n    if (isUndefined(columnEnd)) {\n      columnEnd = columnStart;\n    }\n\n    if (!keepDirection) {\n      var origRowStart = rowStart;\n      var origColumnStart = columnStart;\n      var origRowEnd = rowEnd;\n      var origColumnEnd = columnEnd;\n      rowStart = Math.min(origRowStart, origRowEnd);\n      columnStart = Math.min(origColumnStart, origColumnEnd);\n      rowEnd = Math.max(origRowStart, origRowEnd);\n      columnEnd = Math.max(origColumnStart, origColumnEnd);\n    }\n\n    return [rowStart, columnStart, rowEnd, columnEnd];\n  };\n}\n/**\n * Function transform selection ranges (produced by `hot.getSelected()` and `hot.getSelectedRange()`) to normalized\n * data structure. It merges repeated ranges into consecutive coordinates. The returned structure\n * contains an array of arrays. The single item contains at index 0 visual column index from the selection was\n * started and at index 1 distance as a count of selected columns.\n *\n * @param {Array[]|CellRange[]} selectionRanges Selection ranges produced by Handsontable.\n * @return {Array[]} Returns an array of arrays with ranges defines in that schema:\n *                   `[[visualColumnStart, distance], [visualColumnStart, distance], ...]`.\n *                   The column distances are always created starting from the left (zero index) to the\n *                   right (the latest column index).\n */\n\nexport function transformSelectionToColumnDistance(selectionRanges) {\n  var selectionType = detectSelectionType(selectionRanges);\n\n  if (selectionType === SELECTION_TYPE_UNRECOGNIZED || selectionType === SELECTION_TYPE_EMPTY) {\n    return [];\n  }\n\n  var selectionSchemaNormalizer = normalizeSelectionFactory(selectionType);\n  var unorderedIndexes = new Set(); // Iterate through all ranges and collect all column indexes which are not saved yet.\n\n  arrayEach(selectionRanges, function (selection) {\n    var _selectionSchemaNorma = selectionSchemaNormalizer(selection),\n        _selectionSchemaNorma2 = _slicedToArray(_selectionSchemaNorma, 4),\n        columnStart = _selectionSchemaNorma2[1],\n        columnEnd = _selectionSchemaNorma2[3];\n\n    var amount = columnEnd - columnStart + 1;\n    arrayEach(Array.from(new Array(amount), function (_, i) {\n      return columnStart + i;\n    }), function (index) {\n      if (!unorderedIndexes.has(index)) {\n        unorderedIndexes.add(index);\n      }\n    });\n  }); // Sort indexes in ascending order to easily detecting non-consecutive columns.\n\n  var orderedIndexes = Array.from(unorderedIndexes).sort(function (a, b) {\n    return a - b;\n  });\n  var normalizedColumnRanges = arrayReduce(orderedIndexes, function (acc, visualColumnIndex, index, array) {\n    if (index !== 0 && visualColumnIndex === array[index - 1] + 1) {\n      acc[acc.length - 1][1] += 1;\n    } else {\n      acc.push([visualColumnIndex, 1]);\n    }\n\n    return acc;\n  }, []);\n  return normalizedColumnRanges;\n}\n/**\n * Function transform selection ranges (produced by `hot.getSelected()` and `hot.getSelectedRange()`) to normalized\n * data structure. It merges repeated ranges into consecutive coordinates. The returned structure\n * contains an array of arrays. The single item contains at index 0 visual column index from the selection was\n * started and at index 1 distance as a count of selected columns.\n *\n * @param {Array[]|CellRange[]} selectionRanges Selection ranges produced by Handsontable.\n * @return {Array[]} Returns an array of arrays with ranges defines in that schema:\n *                   `[[visualColumnStart, distance], [visualColumnStart, distance], ...]`.\n *                   The column distances are always created starting from the left (zero index) to the\n *                   right (the latest column index).\n */\n\nexport function transformSelectionToRowDistance(selectionRanges) {\n  var selectionType = detectSelectionType(selectionRanges);\n\n  if (selectionType === SELECTION_TYPE_UNRECOGNIZED || selectionType === SELECTION_TYPE_EMPTY) {\n    return [];\n  }\n\n  var selectionSchemaNormalizer = normalizeSelectionFactory(selectionType);\n  var unorderedIndexes = new Set(); // Iterate through all ranges and collect all column indexes which are not saved yet.\n\n  arrayEach(selectionRanges, function (selection) {\n    var _selectionSchemaNorma3 = selectionSchemaNormalizer(selection),\n        _selectionSchemaNorma4 = _slicedToArray(_selectionSchemaNorma3, 3),\n        rowStart = _selectionSchemaNorma4[0],\n        rowEnd = _selectionSchemaNorma4[2];\n\n    var amount = rowEnd - rowStart + 1;\n    arrayEach(Array.from(new Array(amount), function (_, i) {\n      return rowStart + i;\n    }), function (index) {\n      if (!unorderedIndexes.has(index)) {\n        unorderedIndexes.add(index);\n      }\n    });\n  }); // Sort indexes in ascending order to easily detecting non-consecutive columns.\n\n  var orderedIndexes = Array.from(unorderedIndexes).sort(function (a, b) {\n    return a - b;\n  });\n  var normalizedRowRanges = arrayReduce(orderedIndexes, function (acc, rowIndex, index, array) {\n    if (index !== 0 && rowIndex === array[index - 1] + 1) {\n      acc[acc.length - 1][1] += 1;\n    } else {\n      acc.push([rowIndex, 1]);\n    }\n\n    return acc;\n  }, []);\n  return normalizedRowRanges;\n}\n/**\n * Check if passed value can be treated as valid cell coordinate. The second argument is\n * used to check if the value doesn't exceed the defined max table rows/columns count.\n *\n * @param {*} coord\n * @param {Number} maxTableItemsCount The value that declares the maximum coordinate that is still validatable.\n * @return {Boolean}\n */\n\nexport function isValidCoord(coord) {\n  var maxTableItemsCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;\n  return typeof coord === 'number' && coord >= 0 && coord < maxTableItemsCount;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}