{"ast":null,"code":"import \"core-js/modules/es.array.index-of\";\nimport \"core-js/modules/es.array.iterator\";\nimport \"core-js/modules/es.map\";\nimport \"core-js/modules/es.object.keys\";\nimport \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.string.iterator\";\nimport \"core-js/modules/web.dom-collections.iterator\";\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nimport { isObject } from './../helpers/object';\nimport { rangeEach } from './../helpers/number';\nimport { stringify } from './../helpers/mixed';\n/**\n * @class SamplesGenerator\n * @util\n */\n\nvar SamplesGenerator = /*#__PURE__*/\nfunction () {\n  _createClass(SamplesGenerator, null, [{\n    key: \"SAMPLE_COUNT\",\n    /**\n     * Number of samples to take of each value length.\n     *\n     * @type {Number}\n     */\n    get: function get() {\n      return 3;\n    }\n  }]);\n  function SamplesGenerator(dataFactory) {\n    _classCallCheck(this, SamplesGenerator);\n\n    /**\n     * Samples prepared for calculations.\n     *\n     * @type {Map}\n     * @default {null}\n     */\n    this.samples = null;\n    /**\n     * Function which give the data to collect samples.\n     *\n     * @type {Function}\n     */\n\n    this.dataFactory = dataFactory;\n    /**\n     * Custom number of samples to take of each value length.\n     *\n     * @type {Number}\n     * @default {null}\n     */\n\n    this.customSampleCount = null;\n    /**\n     * `true` if duplicate samples collection should be allowed, `false` otherwise.\n     *\n     * @type {Boolean}\n     * @default {false}\n     */\n\n    this.allowDuplicates = false;\n  }\n  /**\n   * Get the sample count for this instance.\n   *\n   * @returns {Number}\n   */\n\n  _createClass(SamplesGenerator, [{\n    key: \"getSampleCount\",\n    value: function getSampleCount() {\n      if (this.customSampleCount) {\n        return this.customSampleCount;\n      }\n      return SamplesGenerator.SAMPLE_COUNT;\n    }\n    /**\n     * Set the sample count.\n     *\n     * @param {Number} sampleCount Number of samples to be collected.\n     */\n  }, {\n    key: \"setSampleCount\",\n    value: function setSampleCount(sampleCount) {\n      this.customSampleCount = sampleCount;\n    }\n    /**\n     * Set if the generator should accept duplicate values.\n     *\n     * @param {Boolean} allowDuplicates `true` to allow duplicate values.\n     */\n  }, {\n    key: \"setAllowDuplicates\",\n    value: function setAllowDuplicates(allowDuplicates) {\n      this.allowDuplicates = allowDuplicates;\n    }\n    /**\n     * Generate samples for row. You can control which area should be sampled by passing `rowRange` object and `colRange` object.\n     *\n     * @param {Object|Number} rowRange\n     * @param {Object} colRange\n     * @returns {Object}\n     */\n  }, {\n    key: \"generateRowSamples\",\n    value: function generateRowSamples(rowRange, colRange) {\n      return this.generateSamples('row', colRange, rowRange);\n    }\n    /**\n     * Generate samples for column. You can control which area should be sampled by passing `colRange` object and `rowRange` object.\n     *\n     * @param {Object} colRange Column index.\n     * @param {Object} rowRange Column index.\n     * @returns {Object}\n     */\n  }, {\n    key: \"generateColumnSamples\",\n    value: function generateColumnSamples(colRange, rowRange) {\n      return this.generateSamples('col', rowRange, colRange);\n    }\n    /**\n     * Generate collection of samples.\n     *\n     * @param {String} type Type to generate. Can be `col` or `row`.\n     * @param {Object} range\n     * @param {Object|Number} specifierRange\n     * @returns {Map}\n     */\n  }, {\n    key: \"generateSamples\",\n    value: function generateSamples(type, range, specifierRange) {\n      var _this = this;\n      var samples = new Map();\n      var _ref = typeof specifierRange === 'number' ? {\n          from: specifierRange,\n          to: specifierRange\n        } : specifierRange,\n        from = _ref.from,\n        to = _ref.to;\n      rangeEach(from, to, function (index) {\n        var sample = _this.generateSample(type, range, index);\n        samples.set(index, sample);\n      });\n      return samples;\n    }\n    /**\n     * Generate sample for specified type (`row` or `col`).\n     *\n     * @param {String} type Samples type `row` or `col`.\n     * @param {Object} range\n     * @param {Number} specifierValue\n     * @returns {Map}\n     */\n  }, {\n    key: \"generateSample\",\n    value: function generateSample(type, range, specifierValue) {\n      var _this2 = this;\n      if (type !== 'row' && type !== 'col') {\n        throw new Error('Unsupported sample type');\n      }\n      var samples = new Map();\n      var computedKey = type === 'row' ? 'col' : 'row';\n      var sampledValues = [];\n      rangeEach(range.from, range.to, function (index) {\n        var _ref2 = type === 'row' ? _this2.dataFactory(specifierValue, index) : _this2.dataFactory(index, specifierValue),\n          value = _ref2.value,\n          bundleCountSeed = _ref2.bundleCountSeed;\n        var hasCustomBundleSeed = bundleCountSeed > 0;\n        var length;\n        if (isObject(value)) {\n          length = Object.keys(value).length;\n        } else if (Array.isArray(value)) {\n          length = value.length;\n        } else {\n          length = stringify(value).length;\n        }\n        if (hasCustomBundleSeed) {\n          length += bundleCountSeed;\n        }\n        if (!samples.has(length)) {\n          samples.set(length, {\n            needed: _this2.getSampleCount(),\n            strings: []\n          });\n        }\n        var sample = samples.get(length);\n        if (sample.needed) {\n          var duplicate = sampledValues.indexOf(value) > -1;\n          if (!duplicate || _this2.allowDuplicates || hasCustomBundleSeed) {\n            sample.strings.push(_defineProperty({\n              value: value\n            }, computedKey, index));\n            sampledValues.push(value);\n            sample.needed -= 1;\n          }\n        }\n      });\n      return samples;\n    }\n  }]);\n  return SamplesGenerator;\n}();\nexport default SamplesGenerator;","map":{"version":3,"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","_createClass","protoProps","staticProps","prototype","isObject","rangeEach","stringify","SamplesGenerator","get","dataFactory","samples","customSampleCount","allowDuplicates","getSampleCount","SAMPLE_COUNT","setSampleCount","sampleCount","setAllowDuplicates","generateRowSamples","rowRange","colRange","generateSamples","generateColumnSamples","type","range","specifierRange","_this","Map","_ref","from","to","index","sample","generateSample","set","specifierValue","_this2","Error","computedKey","sampledValues","_ref2","bundleCountSeed","hasCustomBundleSeed","keys","Array","isArray","has","needed","strings","duplicate","indexOf","push"],"sources":["C:/Users/mrezy/VSCode/internships-master/node_modules/handsontable/es/utils/samplesGenerator.js"],"sourcesContent":["import \"core-js/modules/es.array.index-of\";\nimport \"core-js/modules/es.array.iterator\";\nimport \"core-js/modules/es.map\";\nimport \"core-js/modules/es.object.keys\";\nimport \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.string.iterator\";\nimport \"core-js/modules/web.dom-collections.iterator\";\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport { isObject } from './../helpers/object';\nimport { rangeEach } from './../helpers/number';\nimport { stringify } from './../helpers/mixed';\n/**\n * @class SamplesGenerator\n * @util\n */\n\nvar SamplesGenerator =\n/*#__PURE__*/\nfunction () {\n  _createClass(SamplesGenerator, null, [{\n    key: \"SAMPLE_COUNT\",\n\n    /**\n     * Number of samples to take of each value length.\n     *\n     * @type {Number}\n     */\n    get: function get() {\n      return 3;\n    }\n  }]);\n\n  function SamplesGenerator(dataFactory) {\n    _classCallCheck(this, SamplesGenerator);\n\n    /**\n     * Samples prepared for calculations.\n     *\n     * @type {Map}\n     * @default {null}\n     */\n    this.samples = null;\n    /**\n     * Function which give the data to collect samples.\n     *\n     * @type {Function}\n     */\n\n    this.dataFactory = dataFactory;\n    /**\n     * Custom number of samples to take of each value length.\n     *\n     * @type {Number}\n     * @default {null}\n     */\n\n    this.customSampleCount = null;\n    /**\n     * `true` if duplicate samples collection should be allowed, `false` otherwise.\n     *\n     * @type {Boolean}\n     * @default {false}\n     */\n\n    this.allowDuplicates = false;\n  }\n  /**\n   * Get the sample count for this instance.\n   *\n   * @returns {Number}\n   */\n\n\n  _createClass(SamplesGenerator, [{\n    key: \"getSampleCount\",\n    value: function getSampleCount() {\n      if (this.customSampleCount) {\n        return this.customSampleCount;\n      }\n\n      return SamplesGenerator.SAMPLE_COUNT;\n    }\n    /**\n     * Set the sample count.\n     *\n     * @param {Number} sampleCount Number of samples to be collected.\n     */\n\n  }, {\n    key: \"setSampleCount\",\n    value: function setSampleCount(sampleCount) {\n      this.customSampleCount = sampleCount;\n    }\n    /**\n     * Set if the generator should accept duplicate values.\n     *\n     * @param {Boolean} allowDuplicates `true` to allow duplicate values.\n     */\n\n  }, {\n    key: \"setAllowDuplicates\",\n    value: function setAllowDuplicates(allowDuplicates) {\n      this.allowDuplicates = allowDuplicates;\n    }\n    /**\n     * Generate samples for row. You can control which area should be sampled by passing `rowRange` object and `colRange` object.\n     *\n     * @param {Object|Number} rowRange\n     * @param {Object} colRange\n     * @returns {Object}\n     */\n\n  }, {\n    key: \"generateRowSamples\",\n    value: function generateRowSamples(rowRange, colRange) {\n      return this.generateSamples('row', colRange, rowRange);\n    }\n    /**\n     * Generate samples for column. You can control which area should be sampled by passing `colRange` object and `rowRange` object.\n     *\n     * @param {Object} colRange Column index.\n     * @param {Object} rowRange Column index.\n     * @returns {Object}\n     */\n\n  }, {\n    key: \"generateColumnSamples\",\n    value: function generateColumnSamples(colRange, rowRange) {\n      return this.generateSamples('col', rowRange, colRange);\n    }\n    /**\n     * Generate collection of samples.\n     *\n     * @param {String} type Type to generate. Can be `col` or `row`.\n     * @param {Object} range\n     * @param {Object|Number} specifierRange\n     * @returns {Map}\n     */\n\n  }, {\n    key: \"generateSamples\",\n    value: function generateSamples(type, range, specifierRange) {\n      var _this = this;\n\n      var samples = new Map();\n\n      var _ref = typeof specifierRange === 'number' ? {\n        from: specifierRange,\n        to: specifierRange\n      } : specifierRange,\n          from = _ref.from,\n          to = _ref.to;\n\n      rangeEach(from, to, function (index) {\n        var sample = _this.generateSample(type, range, index);\n\n        samples.set(index, sample);\n      });\n      return samples;\n    }\n    /**\n     * Generate sample for specified type (`row` or `col`).\n     *\n     * @param {String} type Samples type `row` or `col`.\n     * @param {Object} range\n     * @param {Number} specifierValue\n     * @returns {Map}\n     */\n\n  }, {\n    key: \"generateSample\",\n    value: function generateSample(type, range, specifierValue) {\n      var _this2 = this;\n\n      if (type !== 'row' && type !== 'col') {\n        throw new Error('Unsupported sample type');\n      }\n\n      var samples = new Map();\n      var computedKey = type === 'row' ? 'col' : 'row';\n      var sampledValues = [];\n      rangeEach(range.from, range.to, function (index) {\n        var _ref2 = type === 'row' ? _this2.dataFactory(specifierValue, index) : _this2.dataFactory(index, specifierValue),\n            value = _ref2.value,\n            bundleCountSeed = _ref2.bundleCountSeed;\n\n        var hasCustomBundleSeed = bundleCountSeed > 0;\n        var length;\n\n        if (isObject(value)) {\n          length = Object.keys(value).length;\n        } else if (Array.isArray(value)) {\n          length = value.length;\n        } else {\n          length = stringify(value).length;\n        }\n\n        if (hasCustomBundleSeed) {\n          length += bundleCountSeed;\n        }\n\n        if (!samples.has(length)) {\n          samples.set(length, {\n            needed: _this2.getSampleCount(),\n            strings: []\n          });\n        }\n\n        var sample = samples.get(length);\n\n        if (sample.needed) {\n          var duplicate = sampledValues.indexOf(value) > -1;\n\n          if (!duplicate || _this2.allowDuplicates || hasCustomBundleSeed) {\n            sample.strings.push(_defineProperty({\n              value: value\n            }, computedKey, index));\n            sampledValues.push(value);\n            sample.needed -= 1;\n          }\n        }\n      });\n      return samples;\n    }\n  }]);\n\n  return SamplesGenerator;\n}();\n\nexport default SamplesGenerator;"],"mappings":"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"},"metadata":{},"sourceType":"module"}