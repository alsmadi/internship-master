{"ast":null,"code":"import \"core-js/modules/web.immediate\";\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n    return arr2;\n  }\n}\nimport { addClass, empty, isChildOfWebComponentTable, removeClass } from './helpers/dom/element';\nimport { columnFactory } from './helpers/setting';\nimport { isFunction } from './helpers/function';\nimport { warn } from './helpers/console';\nimport { isDefined, isUndefined, isRegExp, _injectProductInfo, isEmpty } from './helpers/mixed';\nimport { isMobileBrowser } from './helpers/browser';\nimport DataMap from './dataMap';\nimport EditorManager from './editorManager';\nimport EventManager from './eventManager';\nimport { deepClone, duckSchema, extend, isObject, isObjectEqual, deepObjectSize, hasOwnProperty, createObjectPropListener, objectEach } from './helpers/object';\nimport { arrayFlatten, arrayMap, arrayEach, arrayReduce } from './helpers/array';\nimport { instanceToHTML } from './utils/parseTable';\nimport { getPlugin } from './plugins';\nimport { getRenderer } from './renderers';\nimport { getValidator } from './validators';\nimport { randomString } from './helpers/string';\nimport { rangeEach, rangeEachReverse } from './helpers/number';\nimport TableView from './tableView';\nimport DataSource from './dataSource';\nimport { translateRowsToColumns, cellMethodLookupFactory, spreadsheetColumnLabel } from './helpers/data';\nimport { getTranslator } from './utils/recordTranslator';\nimport { registerAsRootInstance, hasValidParameter, isRootInstance } from './utils/rootInstance';\nimport { CellCoords, ViewportColumnsCalculator } from './3rdparty/walkontable/src';\nimport Hooks from './pluginHooks';\nimport DefaultSettings from './defaultSettings';\nimport { getCellType } from './cellTypes';\nimport { getTranslatedPhrase } from './i18n';\nimport { hasLanguageDictionary } from './i18n/dictionariesManager';\nimport { warnUserAboutLanguageRegistration, applyLanguageSetting, normalizeLanguageCode } from './i18n/utils';\nimport { startObserving as keyStateStartObserving, stopObserving as keyStateStopObserving } from './utils/keyStateObserver';\nimport { Selection } from './selection';\nvar activeGuid = null;\n/**\n * Handsontable constructor\n *\n * @core\n * @constructor Core\n * @description\n *\n * After Handsontable is constructed, you can modify the grid behavior using the available public methods.\n *\n * ---\n * ## How to call methods\n *\n * These are 2 equal ways to call a Handsontable method:\n *\n * ```js\n * // all following examples assume that you constructed Handsontable like this\n * const hot = new Handsontable(document.getElementById('example1'), options);\n *\n * // now, to use setDataAtCell method, you can either:\n * ht.setDataAtCell(0, 0, 'new value');\n * ```\n *\n * Alternatively, you can call the method using jQuery wrapper (__obsolete__, requires initialization using our jQuery guide\n * ```js\n *   $('#example1').handsontable('setDataAtCell', 0, 0, 'new value');\n * ```\n * ---\n */\n\nexport default function Core(rootElement, userSettings) {\n  var _this = this;\n  var rootInstanceSymbol = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var preventScrollingToCell = false;\n  var instance = this;\n  var GridSettings = function GridSettings() {};\n  var eventManager = new EventManager(instance);\n  var priv;\n  var datamap;\n  var dataSource;\n  var grid;\n  var editorManager;\n  extend(GridSettings.prototype, DefaultSettings.prototype); // create grid settings as a copy of default settings\n\n  extend(GridSettings.prototype, userSettings); // overwrite defaults with user settings\n\n  extend(GridSettings.prototype, expandType(userSettings));\n  applyLanguageSetting(GridSettings.prototype, userSettings.language);\n  if (hasValidParameter(rootInstanceSymbol)) {\n    registerAsRootInstance(this);\n  } // TODO: check if references to DOM elements should be move to UI layer (Walkontable)\n\n  /**\n   * Reference to the container element.\n   *\n   * @private\n   * @type {HTMLElement}\n   */\n\n  this.rootElement = rootElement;\n  /**\n   * The nearest document over container.\n   *\n   * @private\n   * @type {Document}\n   */\n\n  this.rootDocument = rootElement.ownerDocument;\n  /**\n   * Window object over container's document.\n   *\n   * @private\n   * @type {Window}\n   */\n\n  this.rootWindow = this.rootDocument.defaultView;\n  keyStateStartObserving(this.rootDocument);\n  this.isDestroyed = false;\n  this.isHotTableEnv = isChildOfWebComponentTable(this.rootElement);\n  EventManager.isHotTableEnv = this.isHotTableEnv;\n  this.container = this.rootDocument.createElement('div');\n  this.renderCall = false;\n  rootElement.insertBefore(this.container, rootElement.firstChild);\n  if (isRootInstance(this)) {\n    _injectProductInfo(userSettings.licenseKey, rootElement);\n  }\n  this.guid = \"ht_\".concat(randomString()); // this is the namespace for global events\n\n  var recordTranslator = getTranslator(instance);\n  dataSource = new DataSource(instance);\n  if (!this.rootElement.id || this.rootElement.id.substring(0, 3) === 'ht_') {\n    this.rootElement.id = this.guid; // if root element does not have an id, assign a random id\n  }\n\n  priv = {\n    cellSettings: [],\n    columnSettings: [],\n    columnsSettingConflicts: ['data', 'width', 'language'],\n    settings: new GridSettings(),\n    // current settings instance\n    selRange: null,\n    // exposed by public method `getSelectedRange`\n    isPopulated: null,\n    scrollable: null,\n    firstRun: true\n  };\n  var selection = new Selection(priv.settings, {\n    countCols: function countCols() {\n      return instance.countCols();\n    },\n    countRows: function countRows() {\n      return instance.countRows();\n    },\n    propToCol: function propToCol(prop) {\n      return datamap.propToCol(prop);\n    },\n    isEditorOpened: function isEditorOpened() {\n      return instance.getActiveEditor() ? instance.getActiveEditor().isOpened() : false;\n    }\n  });\n  this.selection = selection;\n  this.selection.addLocalHook('beforeSetRangeStart', function (cellCoords) {\n    _this.runHooks('beforeSetRangeStart', cellCoords);\n  });\n  this.selection.addLocalHook('beforeSetRangeStartOnly', function (cellCoords) {\n    _this.runHooks('beforeSetRangeStartOnly', cellCoords);\n  });\n  this.selection.addLocalHook('beforeSetRangeEnd', function (cellCoords) {\n    _this.runHooks('beforeSetRangeEnd', cellCoords);\n    if (cellCoords.row < 0) {\n      cellCoords.row = _this.view.wt.wtTable.getFirstVisibleRow();\n    }\n    if (cellCoords.col < 0) {\n      cellCoords.col = _this.view.wt.wtTable.getFirstVisibleColumn();\n    }\n  });\n  this.selection.addLocalHook('afterSetRangeEnd', function (cellCoords) {\n    var preventScrolling = createObjectPropListener(false);\n    var selectionRange = _this.selection.getSelectedRange();\n    var _selectionRange$curre = selectionRange.current(),\n      from = _selectionRange$curre.from,\n      to = _selectionRange$curre.to;\n    var selectionLayerLevel = selectionRange.size() - 1;\n    _this.runHooks('afterSelection', from.row, from.col, to.row, to.col, preventScrolling, selectionLayerLevel);\n    _this.runHooks('afterSelectionByProp', from.row, instance.colToProp(from.col), to.row, instance.colToProp(to.col), preventScrolling, selectionLayerLevel);\n    var isSelectedByAnyHeader = _this.selection.isSelectedByAnyHeader();\n    var currentSelectedRange = _this.selection.selectedRange.current();\n    var scrollToCell = true;\n    if (preventScrollingToCell) {\n      scrollToCell = false;\n    }\n    if (preventScrolling.isTouched()) {\n      scrollToCell = !preventScrolling.value;\n    }\n    var isSelectedByRowHeader = _this.selection.isSelectedByRowHeader();\n    var isSelectedByColumnHeader = _this.selection.isSelectedByColumnHeader();\n    if (scrollToCell !== false) {\n      if (!isSelectedByAnyHeader) {\n        if (currentSelectedRange && !_this.selection.isMultiple()) {\n          _this.view.scrollViewport(currentSelectedRange.from);\n        } else {\n          _this.view.scrollViewport(cellCoords);\n        }\n      } else if (isSelectedByRowHeader) {\n        _this.view.scrollViewportVertically(cellCoords.row);\n      } else if (isSelectedByColumnHeader) {\n        _this.view.scrollViewportHorizontally(cellCoords.col);\n      }\n    } // @TODO: These CSS classes are no longer needed anymore. They are used only as a indicator of the selected\n    // rows/columns in the MergedCells plugin (via border.js#L520 in the walkontable module). After fixing\n    // the Border class this should be removed.\n\n    if (isSelectedByRowHeader && isSelectedByColumnHeader) {\n      addClass(_this.rootElement, ['ht__selection--rows', 'ht__selection--columns']);\n    } else if (isSelectedByRowHeader) {\n      removeClass(_this.rootElement, 'ht__selection--columns');\n      addClass(_this.rootElement, 'ht__selection--rows');\n    } else if (isSelectedByColumnHeader) {\n      removeClass(_this.rootElement, 'ht__selection--rows');\n      addClass(_this.rootElement, 'ht__selection--columns');\n    } else {\n      removeClass(_this.rootElement, ['ht__selection--rows', 'ht__selection--columns']);\n    }\n    _this._refreshBorders(null);\n  });\n  this.selection.addLocalHook('afterSelectionFinished', function (cellRanges) {\n    var selectionLayerLevel = cellRanges.length - 1;\n    var _cellRanges$selection = cellRanges[selectionLayerLevel],\n      from = _cellRanges$selection.from,\n      to = _cellRanges$selection.to;\n    _this.runHooks('afterSelectionEnd', from.row, from.col, to.row, to.col, selectionLayerLevel);\n    _this.runHooks('afterSelectionEndByProp', from.row, instance.colToProp(from.col), to.row, instance.colToProp(to.col), selectionLayerLevel);\n  });\n  this.selection.addLocalHook('afterIsMultipleSelection', function (isMultiple) {\n    var changedIsMultiple = _this.runHooks('afterIsMultipleSelection', isMultiple.value);\n    if (isMultiple.value) {\n      isMultiple.value = changedIsMultiple;\n    }\n  });\n  this.selection.addLocalHook('beforeModifyTransformStart', function (cellCoordsDelta) {\n    _this.runHooks('modifyTransformStart', cellCoordsDelta);\n  });\n  this.selection.addLocalHook('afterModifyTransformStart', function (coords, rowTransformDir, colTransformDir) {\n    _this.runHooks('afterModifyTransformStart', coords, rowTransformDir, colTransformDir);\n  });\n  this.selection.addLocalHook('beforeModifyTransformEnd', function (cellCoordsDelta) {\n    _this.runHooks('modifyTransformEnd', cellCoordsDelta);\n  });\n  this.selection.addLocalHook('afterModifyTransformEnd', function (coords, rowTransformDir, colTransformDir) {\n    _this.runHooks('afterModifyTransformEnd', coords, rowTransformDir, colTransformDir);\n  });\n  this.selection.addLocalHook('afterDeselect', function () {\n    editorManager.destroyEditor();\n    _this._refreshBorders();\n    removeClass(_this.rootElement, ['ht__selection--rows', 'ht__selection--columns']);\n    _this.runHooks('afterDeselect');\n  });\n  this.selection.addLocalHook('insertRowRequire', function (totalRows) {\n    _this.alter('insert_row', totalRows, 1, 'auto');\n  });\n  this.selection.addLocalHook('insertColRequire', function (totalCols) {\n    _this.alter('insert_col', totalCols, 1, 'auto');\n  });\n  grid = {\n    /**\n     * Inserts or removes rows and columns.\n     *\n     * @memberof Core#\n     * @function alter\n     * @private\n     * @param {String} action Possible values: \"insert_row\", \"insert_col\", \"remove_row\", \"remove_col\".\n     * @param {Number|Array} index Row or column visual index which from the alter action will be triggered.\n     *                             Alter actions such as \"remove_row\" and \"remove_col\" support array indexes in the\n     *                             format `[[index, amount], [index, amount]...]` this can be used to remove\n     *                             non-consecutive columns or rows in one call.\n     * @param {Number} [amount=1] Ammount rows or columns to remove.\n     * @param {String} [source] Optional. Source of hook runner.\n     * @param {Boolean} [keepEmptyRows] Optional. Flag for preventing deletion of empty rows.\n     */\n    alter: function alter(action, index) {\n      var amount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      var source = arguments.length > 3 ? arguments[3] : undefined;\n      var keepEmptyRows = arguments.length > 4 ? arguments[4] : undefined;\n      var delta;\n      function spliceWith(data, startIndex, count, toInject) {\n        var valueFactory = function valueFactory() {\n          var result;\n          if (toInject === 'array') {\n            result = [];\n          } else if (toInject === 'object') {\n            result = {};\n          }\n          return result;\n        };\n        var spliceArgs = arrayMap(new Array(count), function () {\n          return valueFactory();\n        });\n        spliceArgs.unshift(startIndex, 0);\n        data.splice.apply(data, _toConsumableArray(spliceArgs));\n      }\n      var normalizeIndexesGroup = function normalizeIndexesGroup(indexes) {\n        if (indexes.length === 0) {\n          return [];\n        }\n        var sortedIndexes = _toConsumableArray(indexes); // Sort the indexes in ascending order.\n\n        sortedIndexes.sort(function (_ref, _ref2) {\n          var _ref3 = _slicedToArray(_ref, 1),\n            indexA = _ref3[0];\n          var _ref4 = _slicedToArray(_ref2, 1),\n            indexB = _ref4[0];\n          if (indexA === indexB) {\n            return 0;\n          }\n          return indexA > indexB ? 1 : -1;\n        }); // Normalize the {index, amount} groups into bigger groups.\n\n        var normalizedIndexes = arrayReduce(sortedIndexes, function (acc, _ref5) {\n          var _ref6 = _slicedToArray(_ref5, 2),\n            groupIndex = _ref6[0],\n            groupAmount = _ref6[1];\n          var previousItem = acc[acc.length - 1];\n          var _previousItem = _slicedToArray(previousItem, 2),\n            prevIndex = _previousItem[0],\n            prevAmount = _previousItem[1];\n          var prevLastIndex = prevIndex + prevAmount;\n          if (groupIndex <= prevLastIndex) {\n            var amountToAdd = Math.max(groupAmount - (prevLastIndex - groupIndex), 0);\n            previousItem[1] += amountToAdd;\n          } else {\n            acc.push([groupIndex, groupAmount]);\n          }\n          return acc;\n        }, [sortedIndexes[0]]);\n        return normalizedIndexes;\n      };\n      /* eslint-disable no-case-declarations */\n\n      switch (action) {\n        case 'insert_row':\n          var numberOfSourceRows = instance.countSourceRows();\n          if (instance.getSettings().maxRows === numberOfSourceRows) {\n            return;\n          } // eslint-disable-next-line no-param-reassign\n\n          index = isDefined(index) ? index : numberOfSourceRows;\n          delta = datamap.createRow(index, amount, source);\n          spliceWith(priv.cellSettings, index, amount, 'array');\n          if (delta) {\n            if (selection.isSelected() && selection.selectedRange.current().from.row >= index) {\n              selection.selectedRange.current().from.row += delta;\n              selection.transformEnd(delta, 0); // will call render() internally\n            } else {\n              instance._refreshBorders(); // it will call render and prepare methods\n            }\n          }\n\n          break;\n        case 'insert_col':\n          delta = datamap.createCol(index, amount, source);\n          for (var row = 0, len = instance.countSourceRows(); row < len; row++) {\n            if (priv.cellSettings[row]) {\n              spliceWith(priv.cellSettings[row], index, amount);\n            }\n          }\n          if (delta) {\n            if (Array.isArray(instance.getSettings().colHeaders)) {\n              var spliceArray = [index, 0];\n              spliceArray.length += delta; // inserts empty (undefined) elements at the end of an array\n\n              Array.prototype.splice.apply(instance.getSettings().colHeaders, spliceArray); // inserts empty (undefined) elements into the colHeader array\n            }\n\n            if (selection.isSelected() && selection.selectedRange.current().from.col >= index) {\n              selection.selectedRange.current().from.col += delta;\n              selection.transformEnd(0, delta); // will call render() internally\n            } else {\n              instance._refreshBorders(); // it will call render and prepare methods\n            }\n          }\n\n          break;\n        case 'remove_row':\n          var removeRow = function removeRow(indexes) {\n            var offset = 0; // Normalize the {index, amount} groups into bigger groups.\n\n            arrayEach(indexes, function (_ref7) {\n              var _ref8 = _slicedToArray(_ref7, 2),\n                groupIndex = _ref8[0],\n                groupAmount = _ref8[1];\n              var calcIndex = isEmpty(groupIndex) ? instance.countRows() - 1 : Math.max(groupIndex - offset, 0); // If the 'index' is an integer decrease it by 'offset' otherwise pass it through to make the value\n              // compatible with datamap.removeCol method.\n\n              if (Number.isInteger(groupIndex)) {\n                // eslint-disable-next-line no-param-reassign\n                groupIndex = Math.max(groupIndex - offset, 0);\n              } // TODO: for datamap.removeRow index should be passed as it is (with undefined and null values). If not, the logic\n              // inside the datamap.removeRow breaks the removing functionality.\n\n              datamap.removeRow(groupIndex, groupAmount, source);\n              priv.cellSettings.splice(calcIndex, amount);\n              var totalRows = instance.countRows();\n              var fixedRowsTop = instance.getSettings().fixedRowsTop;\n              if (fixedRowsTop >= calcIndex + 1) {\n                instance.getSettings().fixedRowsTop -= Math.min(groupAmount, fixedRowsTop - calcIndex);\n              }\n              var fixedRowsBottom = instance.getSettings().fixedRowsBottom;\n              if (fixedRowsBottom && calcIndex >= totalRows - fixedRowsBottom) {\n                instance.getSettings().fixedRowsBottom -= Math.min(groupAmount, fixedRowsBottom);\n              }\n              offset += groupAmount;\n            });\n          };\n          if (Array.isArray(index)) {\n            removeRow(normalizeIndexesGroup(index));\n          } else {\n            removeRow([[index, amount]]);\n          }\n          grid.adjustRowsAndCols();\n          instance._refreshBorders(); // it will call render and prepare methods\n\n          break;\n        case 'remove_col':\n          var removeCol = function removeCol(indexes) {\n            var offset = 0; // Normalize the {index, amount} groups into bigger groups.\n\n            arrayEach(indexes, function (_ref9) {\n              var _ref10 = _slicedToArray(_ref9, 2),\n                groupIndex = _ref10[0],\n                groupAmount = _ref10[1];\n              var calcIndex = isEmpty(groupIndex) ? instance.countCols() - 1 : Math.max(groupIndex - offset, 0);\n              var visualColumnIndex = recordTranslator.toPhysicalColumn(calcIndex); // If the 'index' is an integer decrease it by 'offset' otherwise pass it through to make the value\n              // compatible with datamap.removeCol method.\n\n              if (Number.isInteger(groupIndex)) {\n                // eslint-disable-next-line no-param-reassign\n                groupIndex = Math.max(groupIndex - offset, 0);\n              } // TODO: for datamap.removeCol index should be passed as it is (with undefined and null values). If not, the logic\n              // inside the datamap.removeCol breaks the removing functionality.\n\n              datamap.removeCol(groupIndex, groupAmount, source);\n              for (var _row = 0, _len = instance.countSourceRows(); _row < _len; _row++) {\n                if (priv.cellSettings[_row]) {\n                  // if row hasn't been rendered it wouldn't have cellSettings\n                  priv.cellSettings[_row].splice(visualColumnIndex, groupAmount);\n                }\n              }\n              var fixedColumnsLeft = instance.getSettings().fixedColumnsLeft;\n              if (fixedColumnsLeft >= calcIndex + 1) {\n                instance.getSettings().fixedColumnsLeft -= Math.min(groupAmount, fixedColumnsLeft - calcIndex);\n              }\n              if (Array.isArray(instance.getSettings().colHeaders)) {\n                if (typeof visualColumnIndex === 'undefined') {\n                  visualColumnIndex = -1;\n                }\n                instance.getSettings().colHeaders.splice(visualColumnIndex, groupAmount);\n              }\n              offset += groupAmount;\n            });\n          };\n          if (Array.isArray(index)) {\n            removeCol(normalizeIndexesGroup(index));\n          } else {\n            removeCol([[index, amount]]);\n          }\n          grid.adjustRowsAndCols();\n          instance._refreshBorders(); // it will call render and prepare methods\n\n          break;\n        default:\n          throw new Error(\"There is no such action \\\"\".concat(action, \"\\\"\"));\n      }\n      if (!keepEmptyRows) {\n        grid.adjustRowsAndCols(); // makes sure that we did not add rows that will be removed in next refresh\n      }\n    },\n\n    /**\n     * Makes sure there are empty rows at the bottom of the table\n     */\n    adjustRowsAndCols: function adjustRowsAndCols() {\n      if (priv.settings.minRows) {\n        // should I add empty rows to data source to meet minRows?\n        var rows = instance.countRows();\n        if (rows < priv.settings.minRows) {\n          for (var r = 0, minRows = priv.settings.minRows; r < minRows - rows; r++) {\n            datamap.createRow(instance.countRows(), 1, 'auto');\n          }\n        }\n      }\n      if (priv.settings.minSpareRows) {\n        var emptyRows = instance.countEmptyRows(true); // should I add empty rows to meet minSpareRows?\n\n        if (emptyRows < priv.settings.minSpareRows) {\n          for (; emptyRows < priv.settings.minSpareRows && instance.countSourceRows() < priv.settings.maxRows; emptyRows++) {\n            datamap.createRow(instance.countRows(), 1, 'auto');\n          }\n        }\n      }\n      {\n        var emptyCols; // count currently empty cols\n\n        if (priv.settings.minCols || priv.settings.minSpareCols) {\n          emptyCols = instance.countEmptyCols(true);\n        } // should I add empty cols to meet minCols?\n\n        if (priv.settings.minCols && !priv.settings.columns && instance.countCols() < priv.settings.minCols) {\n          for (; instance.countCols() < priv.settings.minCols; emptyCols++) {\n            datamap.createCol(instance.countCols(), 1, 'auto');\n          }\n        } // should I add empty cols to meet minSpareCols?\n\n        if (priv.settings.minSpareCols && !priv.settings.columns && instance.dataType === 'array' && emptyCols < priv.settings.minSpareCols) {\n          for (; emptyCols < priv.settings.minSpareCols && instance.countCols() < priv.settings.maxCols; emptyCols++) {\n            datamap.createCol(instance.countCols(), 1, 'auto');\n          }\n        }\n      }\n      var rowCount = instance.countRows();\n      var colCount = instance.countCols();\n      if (rowCount === 0 || colCount === 0) {\n        selection.deselect();\n      }\n      if (selection.isSelected()) {\n        arrayEach(selection.selectedRange, function (range) {\n          var selectionChanged = false;\n          var fromRow = range.from.row;\n          var fromCol = range.from.col;\n          var toRow = range.to.row;\n          var toCol = range.to.col; // if selection is outside, move selection to last row\n\n          if (fromRow > rowCount - 1) {\n            fromRow = rowCount - 1;\n            selectionChanged = true;\n            if (toRow > fromRow) {\n              toRow = fromRow;\n            }\n          } else if (toRow > rowCount - 1) {\n            toRow = rowCount - 1;\n            selectionChanged = true;\n            if (fromRow > toRow) {\n              fromRow = toRow;\n            }\n          } // if selection is outside, move selection to last row\n\n          if (fromCol > colCount - 1) {\n            fromCol = colCount - 1;\n            selectionChanged = true;\n            if (toCol > fromCol) {\n              toCol = fromCol;\n            }\n          } else if (toCol > colCount - 1) {\n            toCol = colCount - 1;\n            selectionChanged = true;\n            if (fromCol > toCol) {\n              fromCol = toCol;\n            }\n          }\n          if (selectionChanged) {\n            instance.selectCell(fromRow, fromCol, toRow, toCol);\n          }\n        });\n      }\n      if (instance.view) {\n        instance.view.wt.wtOverlays.adjustElementsSize();\n      }\n    },\n    /**\n     * Populate the data from the provided 2d array from the given cell coordinates.\n     *\n     * @private\n     * @param {Object} start Start selection position. Visual indexes.\n     * @param {Array} input 2d data array.\n     * @param {Object} [end] End selection position (only for drag-down mode). Visual indexes.\n     * @param {String} [source=\"populateFromArray\"] Source information string.\n     * @param {String} [method=\"overwrite\"] Populate method. Possible options: `shift_down`, `shift_right`, `overwrite`.\n     * @param {String} direction (left|right|up|down) String specifying the direction.\n     * @param {Array} deltas The deltas array. A difference between values of adjacent cells.\n     *                       Useful **only** when the type of handled cells is `numeric`.\n     * @returns {Object|undefined} ending td in pasted area (only if any cell was changed).\n     */\n    populateFromArray: function populateFromArray(start, input, end, source, method, direction, deltas) {\n      // TODO: either remove or implement the `direction` argument. Currently it's not working at all.\n      var r;\n      var rlen;\n      var c;\n      var clen;\n      var setData = [];\n      var current = {};\n      rlen = input.length;\n      if (rlen === 0) {\n        return false;\n      }\n      var repeatCol;\n      var repeatRow;\n      var cmax;\n      var rmax;\n      /* eslint-disable no-case-declarations */\n      // insert data with specified pasteMode method\n\n      switch (method) {\n        case 'shift_down':\n          repeatCol = end ? end.col - start.col + 1 : 0;\n          repeatRow = end ? end.row - start.row + 1 : 0; // eslint-disable-next-line no-param-reassign\n\n          input = translateRowsToColumns(input);\n          for (c = 0, clen = input.length, cmax = Math.max(clen, repeatCol); c < cmax; c++) {\n            if (c < clen) {\n              var _instance;\n              for (r = 0, rlen = input[c].length; r < repeatRow - rlen; r++) {\n                input[c].push(input[c][r % rlen]);\n              }\n              input[c].unshift(start.col + c, start.row, 0);\n              (_instance = instance).spliceCol.apply(_instance, _toConsumableArray(input[c]));\n            } else {\n              var _instance2;\n              input[c % clen][0] = start.col + c;\n              (_instance2 = instance).spliceCol.apply(_instance2, _toConsumableArray(input[c % clen]));\n            }\n          }\n          break;\n        case 'shift_right':\n          repeatCol = end ? end.col - start.col + 1 : 0;\n          repeatRow = end ? end.row - start.row + 1 : 0;\n          for (r = 0, rlen = input.length, rmax = Math.max(rlen, repeatRow); r < rmax; r++) {\n            if (r < rlen) {\n              var _instance3;\n              for (c = 0, clen = input[r].length; c < repeatCol - clen; c++) {\n                input[r].push(input[r][c % clen]);\n              }\n              input[r].unshift(start.row + r, start.col, 0);\n              (_instance3 = instance).spliceRow.apply(_instance3, _toConsumableArray(input[r]));\n            } else {\n              var _instance4;\n              input[r % rlen][0] = start.row + r;\n              (_instance4 = instance).spliceRow.apply(_instance4, _toConsumableArray(input[r % rlen]));\n            }\n          }\n          break;\n        case 'overwrite':\n        default:\n          // overwrite and other not specified options\n          current.row = start.row;\n          current.col = start.col;\n          var selected = {\n            // selected range\n            row: end && start ? end.row - start.row + 1 : 1,\n            col: end && start ? end.col - start.col + 1 : 1\n          };\n          var skippedRow = 0;\n          var skippedColumn = 0;\n          var pushData = true;\n          var cellMeta;\n          var getInputValue = function getInputValue(row) {\n            var col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n            var rowValue = input[row % input.length];\n            if (col !== null) {\n              return rowValue[col % rowValue.length];\n            }\n            return rowValue;\n          };\n          var rowInputLength = input.length;\n          var rowSelectionLength = end ? end.row - start.row + 1 : 0;\n          if (end) {\n            rlen = rowSelectionLength;\n          } else {\n            rlen = Math.max(rowInputLength, rowSelectionLength);\n          }\n          for (r = 0; r < rlen; r++) {\n            if (end && current.row > end.row && rowSelectionLength > rowInputLength || !priv.settings.allowInsertRow && current.row > instance.countRows() - 1 || current.row >= priv.settings.maxRows) {\n              break;\n            }\n            var visualRow = r - skippedRow;\n            var colInputLength = getInputValue(visualRow).length;\n            var colSelectionLength = end ? end.col - start.col + 1 : 0;\n            if (end) {\n              clen = colSelectionLength;\n            } else {\n              clen = Math.max(colInputLength, colSelectionLength);\n            }\n            current.col = start.col;\n            cellMeta = instance.getCellMeta(current.row, current.col);\n            if ((source === 'CopyPaste.paste' || source === 'Autofill.fill') && cellMeta.skipRowOnPaste) {\n              skippedRow += 1;\n              current.row += 1;\n              rlen += 1;\n              /* eslint-disable no-continue */\n\n              continue;\n            }\n            skippedColumn = 0;\n            for (c = 0; c < clen; c++) {\n              if (end && current.col > end.col && colSelectionLength > colInputLength || !priv.settings.allowInsertColumn && current.col > instance.countCols() - 1 || current.col >= priv.settings.maxCols) {\n                break;\n              }\n              cellMeta = instance.getCellMeta(current.row, current.col);\n              if ((source === 'CopyPaste.paste' || source === 'Autofill.fill') && cellMeta.skipColumnOnPaste) {\n                skippedColumn += 1;\n                current.col += 1;\n                clen += 1;\n                continue;\n              }\n              if (cellMeta.readOnly) {\n                current.col += 1;\n                /* eslint-disable no-continue */\n\n                continue;\n              }\n              var visualColumn = c - skippedColumn;\n              var value = getInputValue(visualRow, visualColumn);\n              var orgValue = instance.getDataAtCell(current.row, current.col);\n              var index = {\n                row: visualRow,\n                col: visualColumn\n              };\n              if (source === 'Autofill.fill') {\n                var result = instance.runHooks('beforeAutofillInsidePopulate', index, direction, input, deltas, {}, selected);\n                if (result) {\n                  value = isUndefined(result.value) ? value : result.value;\n                }\n              }\n              if (value !== null && _typeof(value) === 'object') {\n                // when 'value' is array and 'orgValue' is null, set 'orgValue' to\n                // an empty array so that the null value can be compared to 'value'\n                // as an empty value for the array context\n                if (Array.isArray(value) && orgValue === null) orgValue = [];\n                if (orgValue === null || _typeof(orgValue) !== 'object') {\n                  pushData = false;\n                } else {\n                  var orgValueSchema = duckSchema(Array.isArray(orgValue) ? orgValue : orgValue[0] || orgValue);\n                  var valueSchema = duckSchema(Array.isArray(value) ? value : value[0] || value);\n                  /* eslint-disable max-depth */\n\n                  if (isObjectEqual(orgValueSchema, valueSchema)) {\n                    value = deepClone(value);\n                  } else {\n                    pushData = false;\n                  }\n                }\n              } else if (orgValue !== null && _typeof(orgValue) === 'object') {\n                pushData = false;\n              }\n              if (pushData) {\n                setData.push([current.row, current.col, value]);\n              }\n              pushData = true;\n              current.col += 1;\n            }\n            current.row += 1;\n          }\n          instance.setDataAtCell(setData, null, null, source || 'populateFromArray');\n          break;\n      }\n    }\n  };\n  /**\n   * Internal function to set `language` key of settings.\n   *\n   * @private\n   * @param {String} languageCode Language code for specific language i.e. 'en-US', 'pt-BR', 'de-DE'\n   * @fires Hooks#afterLanguageChange\n   */\n\n  function setLanguage(languageCode) {\n    var normalizedLanguageCode = normalizeLanguageCode(languageCode);\n    if (hasLanguageDictionary(normalizedLanguageCode)) {\n      instance.runHooks('beforeLanguageChange', normalizedLanguageCode);\n      GridSettings.prototype.language = normalizedLanguageCode;\n      instance.runHooks('afterLanguageChange', normalizedLanguageCode);\n    } else {\n      warnUserAboutLanguageRegistration(languageCode);\n    }\n  }\n  this.init = function () {\n    dataSource.setData(priv.settings.data);\n    instance.runHooks('beforeInit');\n    if (isMobileBrowser()) {\n      addClass(instance.rootElement, 'mobile');\n    }\n    this.updateSettings(priv.settings, true);\n    this.view = new TableView(this);\n    editorManager = EditorManager.getInstance(instance, priv, selection, datamap);\n    this.forceFullRender = true; // used when data was changed\n\n    instance.runHooks('init');\n    this.view.render();\n    if (_typeof(priv.firstRun) === 'object') {\n      instance.runHooks('afterChange', priv.firstRun[0], priv.firstRun[1]);\n      priv.firstRun = false;\n    }\n    instance.runHooks('afterInit');\n  };\n  function ValidatorsQueue() {\n    // moved this one level up so it can be used in any function here. Probably this should be moved to a separate file\n    var resolved = false;\n    return {\n      validatorsInQueue: 0,\n      valid: true,\n      addValidatorToQueue: function addValidatorToQueue() {\n        this.validatorsInQueue += 1;\n        resolved = false;\n      },\n      removeValidatorFormQueue: function removeValidatorFormQueue() {\n        this.validatorsInQueue = this.validatorsInQueue - 1 < 0 ? 0 : this.validatorsInQueue - 1;\n        this.checkIfQueueIsEmpty();\n      },\n      onQueueEmpty: function onQueueEmpty() {},\n      checkIfQueueIsEmpty: function checkIfQueueIsEmpty() {\n        if (this.validatorsInQueue === 0 && resolved === false) {\n          resolved = true;\n          this.onQueueEmpty(this.valid);\n        }\n      }\n    };\n  }\n  /**\n   * Get parsed number from numeric string.\n   *\n   * @private\n   * @param {String} numericData Float (separated by a dot or a comma) or integer.\n   * @returns {Number} Number if we get data in parsable format, not changed value otherwise.\n   */\n\n  function getParsedNumber(numericData) {\n    // Unifying \"float like\" string. Change from value with comma determiner to value with dot determiner,\n    // for example from `450,65` to `450.65`.\n    var unifiedNumericData = numericData.replace(',', '.');\n    if (isNaN(parseFloat(unifiedNumericData)) === false) {\n      return parseFloat(unifiedNumericData);\n    }\n    return numericData;\n  }\n  function validateChanges(changes, source, callback) {\n    if (!changes.length) {\n      return;\n    }\n    var activeEditor = instance.getActiveEditor();\n    var beforeChangeResult = instance.runHooks('beforeChange', changes, source || 'edit');\n    var shouldBeCanceled = true;\n    if (isFunction(beforeChangeResult)) {\n      warn('Your beforeChange callback returns a function. It\\'s not supported since Handsontable 0.12.1 (and the returned function will not be executed).');\n    } else if (beforeChangeResult === false) {\n      if (activeEditor) {\n        activeEditor.cancelChanges();\n      }\n      return;\n    }\n    var waitingForValidator = new ValidatorsQueue();\n    var isNumericData = function isNumericData(value) {\n      return value.length > 0 && /^\\s*[+-.]?\\s*(?:(?:\\d+(?:(\\.|,)\\d+)?(?:e[+-]?\\d+)?)|(?:0x[a-f\\d]+))\\s*$/.test(value);\n    };\n    waitingForValidator.onQueueEmpty = function (isValid) {\n      if (activeEditor && shouldBeCanceled) {\n        activeEditor.cancelChanges();\n      }\n      callback(isValid); // called when async validators are resolved and beforeChange was not async\n    };\n\n    for (var i = changes.length - 1; i >= 0; i--) {\n      if (changes[i] === null) {\n        changes.splice(i, 1);\n      } else {\n        var _changes$i = _slicedToArray(changes[i], 4),\n          row = _changes$i[0],\n          prop = _changes$i[1],\n          newValue = _changes$i[3];\n        var col = datamap.propToCol(prop);\n        var cellProperties = instance.getCellMeta(row, col);\n        if (cellProperties.type === 'numeric' && typeof newValue === 'string' && isNumericData(newValue)) {\n          changes[i][3] = getParsedNumber(newValue);\n        }\n        /* eslint-disable no-loop-func */\n\n        if (instance.getCellValidator(cellProperties)) {\n          waitingForValidator.addValidatorToQueue();\n          instance.validateCell(changes[i][3], cellProperties, function (index, cellPropertiesReference) {\n            return function (result) {\n              if (typeof result !== 'boolean') {\n                throw new Error('Validation error: result is not boolean');\n              }\n              if (result === false && cellPropertiesReference.allowInvalid === false) {\n                shouldBeCanceled = false;\n                changes.splice(index, 1); // cancel the change\n\n                cellPropertiesReference.valid = true; // we cancelled the change, so cell value is still valid\n\n                var cell = instance.getCell(cellPropertiesReference.visualRow, cellPropertiesReference.visualCol);\n                if (cell !== null) {\n                  removeClass(cell, instance.getSettings().invalidCellClassName);\n                } // index -= 1;\n              }\n\n              waitingForValidator.removeValidatorFormQueue();\n            };\n          }(i, cellProperties), source);\n        }\n      }\n    }\n    waitingForValidator.checkIfQueueIsEmpty();\n  }\n  /**\n   * Internal function to apply changes. Called after validateChanges\n   *\n   * @private\n   * @param {Array} changes Array in form of [row, prop, oldValue, newValue]\n   * @param {String} source String that identifies how this change will be described in changes array (useful in onChange callback)\n   * @fires Hooks#beforeChangeRender\n   * @fires Hooks#afterChange\n   */\n\n  function applyChanges(changes, source) {\n    var i = changes.length - 1;\n    if (i < 0) {\n      return;\n    }\n    for (; i >= 0; i--) {\n      var skipThisChange = false;\n      if (changes[i] === null) {\n        changes.splice(i, 1);\n        /* eslint-disable no-continue */\n\n        continue;\n      }\n      if ((changes[i][2] === null || changes[i][2] === void 0) && (changes[i][3] === null || changes[i][3] === void 0)) {\n        /* eslint-disable no-continue */\n        continue;\n      }\n      if (priv.settings.allowInsertRow) {\n        while (changes[i][0] > instance.countRows() - 1) {\n          var numberOfCreatedRows = datamap.createRow(void 0, void 0, source);\n          if (numberOfCreatedRows === 0) {\n            skipThisChange = true;\n            break;\n          }\n        }\n      }\n      if (instance.dataType === 'array' && (!priv.settings.columns || priv.settings.columns.length === 0) && priv.settings.allowInsertColumn) {\n        while (datamap.propToCol(changes[i][1]) > instance.countCols() - 1) {\n          var numberOfCreatedColumns = datamap.createCol(void 0, void 0, source);\n          if (numberOfCreatedColumns === 0) {\n            skipThisChange = true;\n            break;\n          }\n        }\n      }\n      if (skipThisChange) {\n        /* eslint-disable no-continue */\n        continue;\n      }\n      datamap.set(changes[i][0], changes[i][1], changes[i][3]);\n    }\n    instance.forceFullRender = true; // used when data was changed\n\n    grid.adjustRowsAndCols();\n    instance.runHooks('beforeChangeRender', changes, source);\n    editorManager.lockEditor();\n    instance._refreshBorders(null);\n    editorManager.unlockEditor();\n    instance.view.wt.wtOverlays.adjustElementsSize();\n    instance.runHooks('afterChange', changes, source || 'edit');\n    var activeEditor = instance.getActiveEditor();\n    if (activeEditor && isDefined(activeEditor.refreshValue)) {\n      activeEditor.refreshValue();\n    }\n  }\n  /**\n   * Validate a single cell.\n   *\n   * @param {String|Number} value\n   * @param cellProperties\n   * @param callback\n   * @param source\n   */\n\n  this.validateCell = function (value, cellProperties, callback, source) {\n    var validator = instance.getCellValidator(cellProperties); // the `canBeValidated = false` argument suggests, that the cell passes validation by default.\n\n    function done(valid) {\n      var canBeValidated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      // Fixes GH#3903\n      if (!canBeValidated || cellProperties.hidden === true) {\n        callback(valid);\n        return;\n      }\n      var col = cellProperties.visualCol;\n      var row = cellProperties.visualRow;\n      var td = instance.getCell(row, col, true);\n      if (td && td.nodeName !== 'TH') {\n        instance.view.wt.wtSettings.settings.cellRenderer(row, col, td);\n      }\n      callback(valid);\n    }\n    if (isRegExp(validator)) {\n      validator = function (expression) {\n        return function (cellValue, validatorCallback) {\n          validatorCallback(expression.test(cellValue));\n        };\n      }(validator);\n    }\n    if (isFunction(validator)) {\n      // eslint-disable-next-line no-param-reassign\n      value = instance.runHooks('beforeValidate', value, cellProperties.visualRow, cellProperties.prop, source); // To provide consistent behaviour, validation should be always asynchronous\n\n      instance._registerImmediate(function () {\n        validator.call(cellProperties, value, function (valid) {\n          if (!instance) {\n            return;\n          } // eslint-disable-next-line no-param-reassign\n\n          valid = instance.runHooks('afterValidate', valid, value, cellProperties.visualRow, cellProperties.prop, source);\n          cellProperties.valid = valid;\n          done(valid);\n          instance.runHooks('postAfterValidate', valid, value, cellProperties.visualRow, cellProperties.prop, source);\n        });\n      });\n    } else {\n      // resolve callback even if validator function was not found\n      instance._registerImmediate(function () {\n        cellProperties.valid = true;\n        done(cellProperties.valid, false);\n      });\n    }\n  };\n  function setDataInputToArray(row, propOrCol, value) {\n    if (_typeof(row) === 'object') {\n      // is it an array of changes\n      return row;\n    }\n    return [[row, propOrCol, value]];\n  }\n  /**\n   * @description\n   * Set new value to a cell. To change many cells at once (recommended way), pass an array of `changes` in format\n   * `[[row, col, value],...]` as the first argument.\n   *\n   * @memberof Core#\n   * @function setDataAtCell\n   * @param {Number|Array} row Visual row index or array of changes in format `[[row, col, value],...]`.\n   * @param {Number} [column] Visual column index.\n   * @param {String} [value] New value.\n   * @param {String} [source] String that identifies how this change will be described in the changes array (useful in onAfterChange or onBeforeChange callback).\n   */\n\n  this.setDataAtCell = function (row, column, value, source) {\n    var input = setDataInputToArray(row, column, value);\n    var changes = [];\n    var changeSource = source;\n    var i;\n    var ilen;\n    var prop;\n    for (i = 0, ilen = input.length; i < ilen; i++) {\n      if (_typeof(input[i]) !== 'object') {\n        throw new Error('Method `setDataAtCell` accepts row number or changes array of arrays as its first parameter');\n      }\n      if (typeof input[i][1] !== 'number') {\n        throw new Error('Method `setDataAtCell` accepts row and column number as its parameters. If you want to use object property name, use method `setDataAtRowProp`');\n      }\n      var physicalRow = recordTranslator.toPhysicalRow(input[i][0]);\n      prop = datamap.colToProp(input[i][1]);\n      changes.push([input[i][0], prop, dataSource.getAtCell(physicalRow, input[i][1]), input[i][2]]);\n    }\n    if (!changeSource && _typeof(row) === 'object') {\n      changeSource = column;\n    }\n    instance.runHooks('afterSetDataAtCell', changes, changeSource);\n    validateChanges(changes, changeSource, function () {\n      applyChanges(changes, changeSource);\n    });\n  };\n  /**\n   * @description\n   * Set new value to a cell. To change many cells at once (recommended way), pass an array of `changes` in format\n   * `[[row, prop, value],...]` as the first argument.\n   *\n   * @memberof Core#\n   * @function setDataAtRowProp\n   * @param {Number|Array} row Visual row index or array of changes in format `[[row, prop, value], ...]`.\n   * @param {String} prop Property name or the source string (e.g. `'first.name'` or `'0'`).\n   * @param {String} value Value to be set.\n   * @param {String} [source] String that identifies how this change will be described in changes array (useful in onChange callback).\n   */\n\n  this.setDataAtRowProp = function (row, prop, value, source) {\n    var input = setDataInputToArray(row, prop, value);\n    var changes = [];\n    var changeSource = source;\n    var i;\n    var ilen;\n    for (i = 0, ilen = input.length; i < ilen; i++) {\n      var physicalRow = recordTranslator.toPhysicalRow(input[i][0]);\n      changes.push([input[i][0], input[i][1], dataSource.getAtCell(physicalRow, input[i][1]), input[i][2]]);\n    }\n    if (!changeSource && _typeof(row) === 'object') {\n      changeSource = prop;\n    }\n    instance.runHooks('afterSetDataAtRowProp', changes, changeSource);\n    validateChanges(changes, changeSource, function () {\n      applyChanges(changes, changeSource);\n    });\n  };\n  /**\n   * Listen to the keyboard input on document body. This allows Handsontable to capture keyboard events and respond\n   * in the right way.\n   *\n   * @memberof Core#\n   * @function listen\n   * @param {Boolean} [modifyDocumentFocus=true] If `true`, currently focused element will be blured (which returns focus\n   *                                             to the document.body). Otherwise the active element does not lose its focus.\n   * @fires Hooks#afterListen\n   */\n\n  this.listen = function () {\n    var modifyDocumentFocus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    var _instance5 = instance,\n      rootDocument = _instance5.rootDocument;\n    if (modifyDocumentFocus) {\n      var invalidActiveElement = !rootDocument.activeElement || rootDocument.activeElement && rootDocument.activeElement.nodeName === void 0;\n      if (rootDocument.activeElement && rootDocument.activeElement !== rootDocument.body && !invalidActiveElement) {\n        rootDocument.activeElement.blur();\n      } else if (invalidActiveElement) {\n        // IE\n        rootDocument.body.focus();\n      }\n    }\n    if (instance && !instance.isListening()) {\n      activeGuid = instance.guid;\n      instance.runHooks('afterListen');\n    }\n  };\n  /**\n   * Stop listening to keyboard input on the document body. Calling this method makes the Handsontable inactive for\n   * any keyboard events.\n   *\n   * @memberof Core#\n   * @function unlisten\n   */\n\n  this.unlisten = function () {\n    if (this.isListening()) {\n      activeGuid = null;\n      instance.runHooks('afterUnlisten');\n    }\n  };\n  /**\n   * Returns `true` if the current Handsontable instance is listening to keyboard input on document body.\n   *\n   * @memberof Core#\n   * @function isListening\n   * @returns {Boolean} `true` if the instance is listening, `false` otherwise.\n   */\n\n  this.isListening = function () {\n    return activeGuid === instance.guid;\n  };\n  /**\n   * Destroys the current editor, render the table and prepares the editor of the newly selected cell.\n   *\n   * @memberof Core#\n   * @function destroyEditor\n   * @param {Boolean} [revertOriginal=false] If `true`, the previous value will be restored. Otherwise, the edited value will be saved.\n   * @param {Boolean} [prepareEditorIfNeeded=true] If `true` the editor under the selected cell will be prepared to open.\n   */\n\n  this.destroyEditor = function () {\n    var revertOriginal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var prepareEditorIfNeeded = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    instance._refreshBorders(revertOriginal, prepareEditorIfNeeded);\n  };\n  /**\n   * Populate cells at position with 2D input array (e.g. `[[1, 2], [3, 4]]`). Use `endRow`, `endCol` when you\n   * want to cut input when a certain row is reached.\n   *\n   * Optional `method` argument has the same effect as pasteMode option (see {@link Options#pasteMode}).\n   *\n   * @memberof Core#\n   * @function populateFromArray\n   * @param {Number} row Start visual row index.\n   * @param {Number} column Start visual column index.\n   * @param {Array} input 2d array\n   * @param {Number} [endRow] End visual row index (use when you want to cut input when certain row is reached).\n   * @param {Number} [endCol] End visual column index (use when you want to cut input when certain column is reached).\n   * @param {String} [source=populateFromArray] Used to identify this call in the resulting events (beforeChange, afterChange).\n   * @param {String} [method=overwrite] Populate method, possible values: `'shift_down'`, `'shift_right'`, `'overwrite'`.\n   * @param {String} direction Populate direction, possible values: `'left'`, `'right'`, `'up'`, `'down'`.\n   * @param {Array} deltas The deltas array. A difference between values of adjacent cells.\n   *                       Useful **only** when the type of handled cells is `numeric`.\n   */\n\n  this.populateFromArray = function (row, column, input, endRow, endCol, source, method, direction, deltas) {\n    if (!(_typeof(input) === 'object' && _typeof(input[0]) === 'object')) {\n      throw new Error('populateFromArray parameter `input` must be an array of arrays'); // API changed in 0.9-beta2, let's check if you use it correctly\n    }\n\n    var c = typeof endRow === 'number' ? new CellCoords(endRow, endCol) : null;\n    return grid.populateFromArray(new CellCoords(row, column), input, c, source, method, direction, deltas);\n  };\n  /**\n   * Adds/removes data from the column. This method works the same as Array.splice for arrays (see {@link DataMap#spliceCol}).\n   *\n   * @memberof Core#\n   * @function spliceCol\n   * @param {Number} column Index of the column in which do you want to do splice.\n   * @param {Number} index Index at which to start changing the array. If negative, will begin that many elements from the end.\n   * @param {Number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed.\n   * @param {...Number} [elements] The elements to add to the array. If you don't specify any elements, spliceCol simply removes elements from the array.\n   */\n\n  this.spliceCol = function (column, index, amount) {\n    var _datamap;\n    for (var _len2 = arguments.length, elements = new Array(_len2 > 3 ? _len2 - 3 : 0), _key = 3; _key < _len2; _key++) {\n      elements[_key - 3] = arguments[_key];\n    }\n    return (_datamap = datamap).spliceCol.apply(_datamap, [column, index, amount].concat(elements));\n  };\n  /**\n   * Adds/removes data from the row. This method works the same as Array.splice for arrays (see {@link DataMap#spliceRow}).\n   *\n   * @memberof Core#\n   * @function spliceRow\n   * @param {Number} row Index of column in which do you want to do splice.\n   * @param {Number} index Index at which to start changing the array. If negative, will begin that many elements from the end.\n   * @param {Number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed.\n   * @param {...Number} [elements] The elements to add to the array. If you don't specify any elements, spliceCol simply removes elements from the array.\n   */\n\n  this.spliceRow = function (row, index, amount) {\n    var _datamap2;\n    for (var _len3 = arguments.length, elements = new Array(_len3 > 3 ? _len3 - 3 : 0), _key2 = 3; _key2 < _len3; _key2++) {\n      elements[_key2 - 3] = arguments[_key2];\n    }\n    return (_datamap2 = datamap).spliceRow.apply(_datamap2, [row, index, amount].concat(elements));\n  };\n  /**\n   * Returns indexes of the currently selected cells as an array of arrays `[[startRow, startCol, endRow, endCol],...]`.\n   *\n   * Start row and start column are the coordinates of the active cell (where the selection was started).\n   *\n   * The version 0.36.0 adds a non-consecutive selection feature. Since this version, the method returns an array of arrays.\n   * Additionally to collect the coordinates of the currently selected area (as it was previously done by the method)\n   * you need to use `getSelectedLast` method.\n   *\n   * @memberof Core#\n   * @function getSelected\n   * @returns {Array[]|undefined} An array of arrays of the selection's coordinates.\n   */\n\n  this.getSelected = function () {\n    // https://github.com/handsontable/handsontable/issues/44  //cjl\n    if (selection.isSelected()) {\n      return arrayMap(selection.getSelectedRange(), function (_ref11) {\n        var from = _ref11.from,\n          to = _ref11.to;\n        return [from.row, from.col, to.row, to.col];\n      });\n    }\n  };\n  /**\n   * Returns the last coordinates applied to the table as a an array `[startRow, startCol, endRow, endCol]`.\n   *\n   * @since 0.36.0\n   * @memberof Core#\n   * @function getSelectedLast\n   * @returns {Array|undefined} An array of the selection's coordinates.\n   */\n\n  this.getSelectedLast = function () {\n    var selected = this.getSelected();\n    var result;\n    if (selected && selected.length > 0) {\n      result = selected[selected.length - 1];\n    }\n    return result;\n  };\n  /**\n   * Returns the current selection as an array of CellRange objects.\n   *\n   * The version 0.36.0 adds a non-consecutive selection feature. Since this version, the method returns an array of arrays.\n   * Additionally to collect the coordinates of the currently selected area (as it was previously done by the method)\n   * you need to use `getSelectedRangeLast` method.\n   *\n   * @memberof Core#\n   * @function getSelectedRange\n   * @returns {CellRange[]|undefined} Selected range object or undefined if there is no selection.\n   */\n\n  this.getSelectedRange = function () {\n    // https://github.com/handsontable/handsontable/issues/44  //cjl\n    if (selection.isSelected()) {\n      return Array.from(selection.getSelectedRange());\n    }\n  };\n  /**\n  * Returns the last coordinates applied to the table as a CellRange object.\n  *\n  * @memberof Core#\n  * @function getSelectedRangeLast\n  * @since 0.36.0\n  * @returns {CellRange|undefined} Selected range object or undefined` if there is no selection.\n   */\n\n  this.getSelectedRangeLast = function () {\n    var selectedRange = this.getSelectedRange();\n    var result;\n    if (selectedRange && selectedRange.length > 0) {\n      result = selectedRange[selectedRange.length - 1];\n    }\n    return result;\n  };\n  /**\n   * Erases content from cells that have been selected in the table.\n   *\n   * @memberof Core#\n   * @function emptySelectedCells\n   * @param {String} [source] String that identifies how this change will be described in the changes array (useful in onAfterChange or onBeforeChange callback).\n   * @since 0.36.0\n   */\n\n  this.emptySelectedCells = function (source) {\n    var _this2 = this;\n    if (!selection.isSelected()) {\n      return;\n    }\n    var changes = [];\n    arrayEach(selection.getSelectedRange(), function (cellRange) {\n      var topLeft = cellRange.getTopLeftCorner();\n      var bottomRight = cellRange.getBottomRightCorner();\n      rangeEach(topLeft.row, bottomRight.row, function (row) {\n        rangeEach(topLeft.col, bottomRight.col, function (column) {\n          if (!_this2.getCellMeta(row, column).readOnly) {\n            changes.push([row, column, null]);\n          }\n        });\n      });\n    });\n    if (changes.length > 0) {\n      this.setDataAtCell(changes, source);\n    }\n  };\n  /**\n   * Rerender the table. Calling this method starts the process of recalculating, redrawing and applying the changes\n   * to the DOM. While rendering the table all cell renderers are recalled.\n   *\n   * Calling this method manually is not recommended. Handsontable tries to render itself by choosing the most\n   * optimal moments in its lifecycle.\n   *\n   * @memberof Core#\n   * @function render\n   */\n\n  this.render = function () {\n    if (instance.view) {\n      instance.renderCall = true;\n      instance.forceFullRender = true; // used when data was changed\n\n      editorManager.lockEditor();\n      instance._refreshBorders(null);\n      editorManager.unlockEditor();\n    }\n  };\n  this.refreshDimensions = function () {\n    if (!instance.view) {\n      return;\n    }\n    var _instance$view$getLas = instance.view.getLastSize(),\n      lastWidth = _instance$view$getLas.width,\n      lastHeight = _instance$view$getLas.height;\n    var _instance$rootElement = instance.rootElement.getBoundingClientRect(),\n      width = _instance$rootElement.width,\n      height = _instance$rootElement.height;\n    var isSizeChanged = width !== lastWidth || height !== lastHeight;\n    var isResizeBlocked = instance.runHooks('beforeRefreshDimensions', {\n      width: lastWidth,\n      height: lastHeight\n    }, {\n      width: width,\n      height: height\n    }, isSizeChanged) === false;\n    if (isResizeBlocked) {\n      return;\n    }\n    if (isSizeChanged || instance.view.wt.wtOverlays.scrollableElement === instance.rootWindow) {\n      instance.view.setLastSize(width, height);\n      instance.render();\n    }\n    instance.runHooks('afterRefreshDimensions', {\n      width: lastWidth,\n      height: lastHeight\n    }, {\n      width: width,\n      height: height\n    }, isSizeChanged);\n  };\n  /**\n   * Loads new data to Handsontable. Loading new data resets the cell meta.\n   *\n   * @memberof Core#\n   * @function loadData\n   * @param {Array} data Array of arrays or array of objects containing data.\n   * @fires Hooks#afterLoadData\n   * @fires Hooks#afterChange\n   */\n\n  this.loadData = function (data) {\n    if (Array.isArray(priv.settings.dataSchema)) {\n      instance.dataType = 'array';\n    } else if (isFunction(priv.settings.dataSchema)) {\n      instance.dataType = 'function';\n    } else {\n      instance.dataType = 'object';\n    }\n    if (datamap) {\n      datamap.destroy();\n    }\n    datamap = new DataMap(instance, priv, GridSettings);\n    if (_typeof(data) === 'object' && data !== null) {\n      if (!(data.push && data.splice)) {\n        // check if data is array. Must use duck-type check so Backbone Collections also pass it\n        // when data is not an array, attempt to make a single-row array of it\n        // eslint-disable-next-line no-param-reassign\n        data = [data];\n      }\n    } else if (data === null) {\n      var dataSchema = datamap.getSchema(); // eslint-disable-next-line no-param-reassign\n\n      data = [];\n      var row;\n      var r = 0;\n      var rlen = 0;\n      for (r = 0, rlen = priv.settings.startRows; r < rlen; r++) {\n        if ((instance.dataType === 'object' || instance.dataType === 'function') && priv.settings.dataSchema) {\n          row = deepClone(dataSchema);\n          data.push(row);\n        } else if (instance.dataType === 'array') {\n          row = deepClone(dataSchema[0]);\n          data.push(row);\n        } else {\n          row = [];\n          for (var c = 0, clen = priv.settings.startCols; c < clen; c++) {\n            row.push(null);\n          }\n          data.push(row);\n        }\n      }\n    } else {\n      throw new Error(\"loadData only accepts array of objects or array of arrays (\".concat(_typeof(data), \" given)\"));\n    }\n    priv.isPopulated = false;\n    GridSettings.prototype.data = data;\n    if (Array.isArray(data[0])) {\n      instance.dataType = 'array';\n    }\n    datamap.dataSource = data;\n    dataSource.data = data;\n    dataSource.dataType = instance.dataType;\n    dataSource.colToProp = datamap.colToProp.bind(datamap);\n    dataSource.propToCol = datamap.propToCol.bind(datamap);\n    clearCellSettingCache();\n    grid.adjustRowsAndCols();\n    instance.runHooks('afterLoadData', priv.firstRun);\n    if (priv.firstRun) {\n      priv.firstRun = [null, 'loadData'];\n    } else {\n      instance.runHooks('afterChange', null, 'loadData');\n      instance.render();\n    }\n    priv.isPopulated = true;\n    function clearCellSettingCache() {\n      priv.cellSettings.length = 0;\n    }\n  };\n  /**\n   * Returns the current data object (the same one that was passed by `data` configuration option or `loadData` method,\n   * unless the `modifyRow` hook was used to trim some of the rows. If that's the case - use the {@link Core#getSourceData} method.).\n   *\n   * Optionally you can provide cell range by defining `row`, `column`, `row2`, `column2` to get only a fragment of table data.\n   *\n   * @memberof Core#\n   * @function getData\n   * @param {Number} [row] From visual row index.\n   * @param {Number} [column] From visual column index.\n   * @param {Number} [row2] To visual row index.\n   * @param {Number} [column2] To visual column index.\n   * @returns {Array[]} Array with the data.\n   * @example\n   * ```js\n   * // Get all data (in order how it is rendered in the table).\n   * hot.getData();\n   * // Get data fragment (from top-left 0, 0 to bottom-right 3, 3).\n   * hot.getData(3, 3);\n   * // Get data fragment (from top-left 2, 1 to bottom-right 3, 3).\n   * hot.getData(2, 1, 3, 3);\n   * ```\n   */\n\n  this.getData = function (row, column, row2, column2) {\n    if (isUndefined(row)) {\n      return datamap.getAll();\n    }\n    return datamap.getRange(new CellCoords(row, column), new CellCoords(row2, column2), datamap.DESTINATION_RENDERER);\n  };\n  /**\n   * Returns a string value of the selected range. Each column is separated by tab, each row is separated by a new\n   * line character (see {@link DataMap#getCopyableText}).\n   *\n   * @memberof Core#\n   * @function getCopyableText\n   * @param {Number} startRow From visual row index.\n   * @param {Number} startCol From visual column index.\n   * @param {Number} endRow To visual row index.\n   * @param {Number} endCol To visual column index.\n   * @returns {String}\n   */\n\n  this.getCopyableText = function (startRow, startCol, endRow, endCol) {\n    return datamap.getCopyableText(new CellCoords(startRow, startCol), new CellCoords(endRow, endCol));\n  };\n  /**\n   * Returns the data's copyable value at specified `row` and `column` index (see {@link DataMap#getCopyable}).\n   *\n   * @memberof Core#\n   * @function getCopyableData\n   * @param {Number} row Visual row index.\n   * @param {Number} column Visual column index.\n   * @returns {String}\n   */\n\n  this.getCopyableData = function (row, column) {\n    return datamap.getCopyable(row, datamap.colToProp(column));\n  };\n  /**\n   * Returns schema provided by constructor settings. If it doesn't exist then it returns the schema based on the data\n   * structure in the first row.\n   *\n   * @memberof Core#\n   * @function getSchema\n   * @returns {Object} Schema object.\n   */\n\n  this.getSchema = function () {\n    return datamap.getSchema();\n  };\n  /**\n   * Use it if you need to change configuration after initialization. The `settings` argument is an object containing the new\n   * settings, declared the same way as in the initial settings object.\n   *\n   * __Note__, that although the `updateSettings` method doesn't overwrite the previously declared settings, it might reset\n   * the settings made post-initialization. (for example - ignore changes made using the columnResize feature).\n   *\n   * @memberof Core#\n   * @function updateSettings\n   * @param {Object} settings New settings object (see {@link Options}).\n   * @param {Boolean} [init=false] Internally used for in initialization mode.\n   * @example\n   * ```js\n   * hot.updateSettings({\n   *    contextMenu: true,\n   *    colHeaders: true,\n   *    fixedRowsTop: 2\n   * });\n   * ```\n   * @fires Hooks#afterCellMetaReset\n   * @fires Hooks#afterUpdateSettings\n   */\n\n  this.updateSettings = function (settings) {\n    var init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var columnsAsFunc = false;\n    var i;\n    var j;\n    var clen;\n    if (isDefined(settings.rows)) {\n      throw new Error('\"rows\" setting is no longer supported. do you mean startRows, minRows or maxRows?');\n    }\n    if (isDefined(settings.cols)) {\n      throw new Error('\"cols\" setting is no longer supported. do you mean startCols, minCols or maxCols?');\n    } // eslint-disable-next-line no-restricted-syntax\n\n    for (i in settings) {\n      if (i === 'data') {\n        /* eslint-disable-next-line no-continue */\n        continue; // loadData will be triggered later\n      } else if (i === 'language') {\n        setLanguage(settings.language);\n        /* eslint-disable-next-line no-continue */\n\n        continue;\n      } else if (Hooks.getSingleton().getRegistered().indexOf(i) > -1) {\n        if (isFunction(settings[i]) || Array.isArray(settings[i])) {\n          settings[i].initialHook = true;\n          instance.addHook(i, settings[i]);\n        }\n      } else if (!init && hasOwnProperty(settings, i)) {\n        // Update settings\n        GridSettings.prototype[i] = settings[i];\n      }\n    } // Load data or create data map\n\n    if (settings.data === void 0 && priv.settings.data === void 0) {\n      instance.loadData(null); // data source created just now\n    } else if (settings.data !== void 0) {\n      instance.loadData(settings.data); // data source given as option\n    } else if (settings.columns !== void 0) {\n      datamap.createMap();\n    }\n    clen = instance.countCols();\n    var columnSetting = settings.columns || GridSettings.prototype.columns; // Init columns constructors configuration\n\n    if (columnSetting && isFunction(columnSetting)) {\n      clen = instance.countSourceCols();\n      columnsAsFunc = true;\n    } // Clear cellSettings cache\n\n    if (settings.cell !== void 0 || settings.cells !== void 0 || settings.columns !== void 0) {\n      priv.cellSettings.length = 0;\n    }\n    if (clen > 0) {\n      var proto;\n      var column;\n      for (i = 0, j = 0; i < clen; i++) {\n        if (columnsAsFunc && !columnSetting(i)) {\n          /* eslint-disable no-continue */\n          continue;\n        }\n        priv.columnSettings[j] = columnFactory(GridSettings, priv.columnsSettingConflicts); // shortcut for prototype\n\n        proto = priv.columnSettings[j].prototype; // Use settings provided by user\n\n        if (columnSetting) {\n          if (columnsAsFunc) {\n            column = columnSetting(i);\n          } else {\n            column = columnSetting[j];\n          }\n          if (column) {\n            extend(proto, column);\n            extend(proto, expandType(column));\n          }\n        }\n        j += 1;\n      }\n    }\n    if (isDefined(settings.cell)) {\n      objectEach(settings.cell, function (cell) {\n        instance.setCellMetaObject(cell.row, cell.col, cell);\n      });\n    }\n    instance.runHooks('afterCellMetaReset');\n    if (isDefined(settings.className)) {\n      if (GridSettings.prototype.className) {\n        removeClass(instance.rootElement, GridSettings.prototype.className);\n      }\n      if (settings.className) {\n        addClass(instance.rootElement, settings.className);\n      }\n    }\n    var currentHeight = instance.rootElement.style.height;\n    if (currentHeight !== '') {\n      currentHeight = parseInt(instance.rootElement.style.height, 10);\n    }\n    var height = settings.height;\n    if (isFunction(height)) {\n      height = height();\n    }\n    if (init) {\n      var initialStyle = instance.rootElement.getAttribute('style');\n      if (initialStyle) {\n        instance.rootElement.setAttribute('data-initialstyle', instance.rootElement.getAttribute('style'));\n      }\n    }\n    if (height === null) {\n      var _initialStyle = instance.rootElement.getAttribute('data-initialstyle');\n      if (_initialStyle && (_initialStyle.indexOf('height') > -1 || _initialStyle.indexOf('overflow') > -1)) {\n        instance.rootElement.setAttribute('style', _initialStyle);\n      } else {\n        instance.rootElement.style.height = '';\n        instance.rootElement.style.overflow = '';\n      }\n    } else if (height !== void 0) {\n      instance.rootElement.style.height = isNaN(height) ? \"\".concat(height) : \"\".concat(height, \"px\");\n      instance.rootElement.style.overflow = 'hidden';\n    }\n    if (typeof settings.width !== 'undefined') {\n      var width = settings.width;\n      if (isFunction(width)) {\n        width = width();\n      }\n      instance.rootElement.style.width = isNaN(width) ? \"\".concat(width) : \"\".concat(width, \"px\");\n    }\n    if (!init) {\n      datamap.clearLengthCache(); // force clear cache length on updateSettings() #3416\n\n      if (instance.view) {\n        instance.view.wt.wtViewport.resetHasOversizedColumnHeadersMarked();\n      }\n      instance.runHooks('afterUpdateSettings', settings);\n    }\n    grid.adjustRowsAndCols();\n    if (instance.view && !priv.firstRun) {\n      instance.forceFullRender = true; // used when data was changed\n\n      editorManager.lockEditor();\n      instance._refreshBorders(null);\n      editorManager.unlockEditor();\n    }\n    if (!init && instance.view && (currentHeight === '' || height === '' || height === void 0) && currentHeight !== height) {\n      instance.view.wt.wtOverlays.updateMainScrollableElements();\n    }\n  };\n  /**\n   * Get value from the selected cell.\n   *\n   * @memberof Core#\n   * @function getValue\n   * @returns {*} Value of selected cell.\n   */\n\n  this.getValue = function () {\n    var sel = instance.getSelectedLast();\n    if (GridSettings.prototype.getValue) {\n      if (isFunction(GridSettings.prototype.getValue)) {\n        return GridSettings.prototype.getValue.call(instance);\n      } else if (sel) {\n        return instance.getData()[sel[0][0]][GridSettings.prototype.getValue];\n      }\n    } else if (sel) {\n      return instance.getDataAtCell(sel[0], sel[1]);\n    }\n  };\n  function expandType(obj) {\n    if (!hasOwnProperty(obj, 'type')) {\n      // ignore obj.prototype.type\n      return;\n    }\n    var expandedType = {};\n    var type;\n    if (_typeof(obj.type) === 'object') {\n      type = obj.type;\n    } else if (typeof obj.type === 'string') {\n      type = getCellType(obj.type);\n    } // eslint-disable-next-line no-restricted-syntax\n\n    for (var i in type) {\n      if (hasOwnProperty(type, i) && !hasOwnProperty(obj, i)) {\n        expandedType[i] = type[i];\n      }\n    }\n    return expandedType;\n  }\n  /**\n   * Returns the object settings.\n   *\n   * @memberof Core#\n   * @function getSettings\n   * @returns {Object} Object containing the current table settings.\n   */\n\n  this.getSettings = function () {\n    return priv.settings;\n  };\n  /**\n   * Clears the data from the table (the table settings remain intact).\n   *\n   * @memberof Core#\n   * @function clear\n   */\n\n  this.clear = function () {\n    this.selectAll();\n    this.emptySelectedCells();\n  };\n  /**\n   * Allows altering the table structure by either inserting/removing rows or columns.\n   *\n   * @memberof Core#\n   * @function alter\n   * @param {String} action Possible alter operations:\n   *  * `'insert_row'`\n   *  * `'insert_col'`\n   *  * `'remove_row'`\n   *  * `'remove_col'`\n   * @param {Number|Number[]} index Visual index of the row/column before which the new row/column will be\n   *                                inserted/removed or an array of arrays in format `[[index, amount],...]`.\n   * @param {Number} [amount=1] Amount of rows/columns to be inserted or removed.\n   * @param {String} [source] Source indicator.\n   * @param {Boolean} [keepEmptyRows] Flag for preventing deletion of empty rows.\n   * @example\n   * ```js\n   * // Insert new row above the row at given visual index.\n   * hot.alter('insert_row', 10);\n   * // Insert 3 new columns before 10th column.\n   * hot.alter('insert_col', 10, 3);\n   * // Remove 2 rows starting from 10th row.\n   * hot.alter('remove_row', 10, 2);\n   * // Remove 5 non-contiquous rows (it removes 3 rows from visual index 1 and 2 rows from visual index 5).\n   * hot.alter('remove_row', [[1, 3], [5, 2]]);\n   * ```\n   */\n\n  this.alter = function (action, index, amount, source, keepEmptyRows) {\n    grid.alter(action, index, amount, source, keepEmptyRows);\n  };\n  /**\n   * Returns a TD element for the given `row` and `column` arguments, if it is rendered on screen.\n   * Returns `null` if the TD is not rendered on screen (probably because that part of the table is not visible).\n   *\n   * @memberof Core#\n   * @function getCell\n   * @param {Number} row Visual row index.\n   * @param {Number} column Visual column index.\n   * @param {Boolean} [topmost=false] If set to `true`, it returns the TD element from the topmost overlay. For example,\n   * if the wanted cell is in the range of fixed rows, it will return a TD element from the `top` overlay.\n   * @returns {HTMLTableCellElement|null} The cell's TD element.\n   */\n\n  this.getCell = function (row, column) {\n    var topmost = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    return instance.view.getCellAtCoords(new CellCoords(row, column), topmost);\n  };\n  /**\n   * Returns the coordinates of the cell, provided as a HTML table cell element.\n   *\n   * @memberof Core#\n   * @function getCoords\n   * @param {HTMLTableCellElement} element The HTML Element representing the cell.\n   * @returns {CellCoords} Visual coordinates object.\n   * @example\n   * ```js\n   * hot.getCoords(hot.getCell(1, 1));\n   * // it returns CellCoords object instance with props row: 1 and col: 1.\n   * ```\n   */\n\n  this.getCoords = function (element) {\n    return this.view.wt.wtTable.getCoords.call(this.view.wt.wtTable, element);\n  };\n  /**\n   * Returns the property name that corresponds with the given column index (see {@link DataMap#colToProp}).\n   * If the data source is an array of arrays, it returns the columns index.\n   *\n   * @memberof Core#\n   * @function colToProp\n   * @param {Number} column Visual column index.\n   * @returns {String|Number} Column property or physical column index.\n   */\n\n  this.colToProp = function (column) {\n    return datamap.colToProp(column);\n  };\n  /**\n   * Returns column index that corresponds with the given property (see {@link DataMap#propToCol}).\n   *\n   * @memberof Core#\n   * @function propToCol\n   * @param {String|Number} prop Property name or physical column index.\n   * @returns {Number} Visual column index.\n   */\n\n  this.propToCol = function (prop) {\n    return datamap.propToCol(prop);\n  };\n  /**\n   * Translate physical row index into visual.\n   *\n   * This method is useful when you want to retrieve visual row index which can be reordered, moved or trimmed\n   * based on a physical index\n   *\n   * @memberof Core#\n   * @function toVisualRow\n   * @param {Number} row Physical row index.\n   * @returns {Number} Returns visual row index.\n   */\n\n  this.toVisualRow = function (row) {\n    return recordTranslator.toVisualRow(row);\n  };\n  /**\n   * Translate physical column index into visual.\n   *\n   * This method is useful when you want to retrieve visual column index which can be reordered, moved or trimmed\n   * based on a physical index\n   *\n   * @memberof Core#\n   * @function toVisualColumn\n   * @param {Number} column Physical column index.\n   * @returns {Number} Returns visual column index.\n   */\n\n  this.toVisualColumn = function (column) {\n    return recordTranslator.toVisualColumn(column);\n  };\n  /**\n   * Translate visual row index into physical.\n   *\n   * This method is useful when you want to retrieve physical row index based on a visual index which can be\n   * reordered, moved or trimmed.\n   *\n   * @memberof Core#\n   * @function toPhysicalRow\n   * @param {Number} row Visual row index.\n   * @returns {Number} Returns physical row index.\n   */\n\n  this.toPhysicalRow = function (row) {\n    return recordTranslator.toPhysicalRow(row);\n  };\n  /**\n   * Translate visual column index into physical.\n   *\n   * This method is useful when you want to retrieve physical column index based on a visual index which can be\n   * reordered, moved or trimmed.\n   *\n   * @memberof Core#\n   * @function toPhysicalColumn\n   * @param {Number} column Visual column index.\n   * @returns {Number} Returns physical column index.\n   */\n\n  this.toPhysicalColumn = function (column) {\n    return recordTranslator.toPhysicalColumn(column);\n  };\n  /**\n   * @description\n   * Returns the cell value at `row`, `column`.\n   *\n   * __Note__: If data is reordered, sorted or trimmed, the currently visible order will be used.\n   *\n   * @memberof Core#\n   * @function getDataAtCell\n   * @param {Number} row Visual row index.\n   * @param {Number} column Visual column index.\n   * @returns {*} Data at cell.\n   */\n\n  this.getDataAtCell = function (row, column) {\n    return datamap.get(row, datamap.colToProp(column));\n  };\n  /**\n   * Returns value at visual `row` and `prop` indexes (see {@link DataMap#get}).\n   *\n   * __Note__: If data is reordered, sorted or trimmed, the currently visible order will be used.\n   *\n   * @memberof Core#\n   * @function getDataAtRowProp\n   * @param {Number} row Visual row index.\n   * @param {String} prop Property name.\n   * @returns {*} Cell value.\n   */\n\n  this.getDataAtRowProp = function (row, prop) {\n    return datamap.get(row, prop);\n  };\n  /**\n   * @description\n   * Returns array of column values from the data source.\n   *\n   * __Note__: If columns were reordered or sorted, the currently visible order will be used.\n   *\n   * @memberof Core#\n   * @function getDataAtCol\n   * @param {Number} column Visual column index.\n   * @returns {Array} Array of cell values.\n   */\n\n  this.getDataAtCol = function (column) {\n    var _ref12;\n    return (_ref12 = []).concat.apply(_ref12, _toConsumableArray(datamap.getRange(new CellCoords(0, column), new CellCoords(priv.settings.data.length - 1, column), datamap.DESTINATION_RENDERER)));\n  };\n  /**\n   * Given the object property name (e.g. `'first.name'` or `'0'`), returns an array of column's values from the table data.\n   * You can also provide a column index as the first argument.\n   *\n   * @memberof Core#\n   * @function getDataAtProp\n   * @param {String|Number} prop Property name or physical column index.\n   * @returns {Array} Array of cell values.\n   */\n  // TODO: Getting data from `datamap` should work on visual indexes.\n\n  this.getDataAtProp = function (prop) {\n    var _ref13;\n    var range = datamap.getRange(new CellCoords(0, datamap.propToCol(prop)), new CellCoords(priv.settings.data.length - 1, datamap.propToCol(prop)), datamap.DESTINATION_RENDERER);\n    return (_ref13 = []).concat.apply(_ref13, _toConsumableArray(range));\n  };\n  /**\n   * Returns the source data object (the same that was passed by `data` configuration option or `loadData` method).\n   * Optionally you can provide a cell range by using the `row`, `column`, `row2`, `column2` arguments, to get only a\n   * fragment of the table data.\n   *\n   * __Note__: This method does not participate in data transformation. If the visual data of the table is reordered,\n   * sorted or trimmed only physical indexes are correct.\n   *\n   * @memberof Core#\n   * @function getSourceData\n   * @param {Number} [row] From physical row index.\n   * @param {Number} [column] From physical column index (or visual index, if data type is an array of objects).\n   * @param {Number} [row2] To physical row index.\n   * @param {Number} [column2] To physical column index (or visual index, if data type is an array of objects).\n   * @returns {Array[]|Object[]} The table data.\n   */\n\n  this.getSourceData = function (row, column, row2, column2) {\n    var data;\n    if (row === void 0) {\n      data = dataSource.getData();\n    } else {\n      data = dataSource.getByRange(new CellCoords(row, column), new CellCoords(row2, column2));\n    }\n    return data;\n  };\n  /**\n   * Returns the source data object as an arrays of arrays format even when source data was provided in another format.\n   * Optionally you can provide a cell range by using the `row`, `column`, `row2`, `column2` arguments, to get only a\n   * fragment of the table data.\n   *\n   * __Note__: This method does not participate in data transformation. If the visual data of the table is reordered,\n   * sorted or trimmed only physical indexes are correct.\n   *\n   * @memberof Core#\n   * @function getSourceDataArray\n   * @param {Number} [row] From physical row index.\n   * @param {Number} [column] From physical column index (or visual index, if data type is an array of objects).\n   * @param {Number} [row2] To physical row index.\n   * @param {Number} [column2] To physical column index (or visual index, if data type is an array of objects).\n   * @returns {Array} An array of arrays.\n   */\n\n  this.getSourceDataArray = function (row, column, row2, column2) {\n    var data;\n    if (row === void 0) {\n      data = dataSource.getData(true);\n    } else {\n      data = dataSource.getByRange(new CellCoords(row, column), new CellCoords(row2, column2), true);\n    }\n    return data;\n  };\n  /**\n   * Returns an array of column values from the data source.\n   *\n   * @memberof Core#\n   * @function getSourceDataAtCol\n   * @param {Number} column Visual column index.\n   * @returns {Array} Array of the column's cell values.\n   */\n  // TODO: Getting data from `sourceData` should work always on physical indexes.\n\n  this.getSourceDataAtCol = function (column) {\n    return dataSource.getAtColumn(column);\n  };\n  /**\n   * Returns a single row of the data (array or object, depending on what data format you use).\n   *\n   * __Note__: This method does not participate in data transformation. If the visual data of the table is reordered,\n   * sorted or trimmed only physical indexes are correct.\n   *\n   * @memberof Core#\n   * @function getSourceDataAtRow\n   * @param {Number} row Physical row index.\n   * @returns {Array|Object} Single row of data.\n   */\n\n  this.getSourceDataAtRow = function (row) {\n    return dataSource.getAtRow(row);\n  };\n  /**\n   * Returns a single value from the data source.\n   *\n   * @memberof Core#\n   * @function getSourceDataAtCell\n   * @param {Number} row Physical row index.\n   * @param {Number} column Visual column index.\n   * @returns {*} Cell data.\n   */\n  // TODO: Getting data from `sourceData` should work always on physical indexes.\n\n  this.getSourceDataAtCell = function (row, column) {\n    return dataSource.getAtCell(row, column);\n  };\n  /**\n   * @description\n   * Returns a single row of the data.\n   *\n   * __Note__: If rows were reordered, sorted or trimmed, the currently visible order will be used.\n   *\n   * @memberof Core#\n   * @function getDataAtRow\n   * @param {Number} row Visual row index.\n   * @returns {Array} Array of row's cell data.\n   */\n\n  this.getDataAtRow = function (row) {\n    var data = datamap.getRange(new CellCoords(row, 0), new CellCoords(row, this.countCols() - 1), datamap.DESTINATION_RENDERER);\n    return data[0] || [];\n  };\n  /**\n   * @description\n   * Returns a data type defined in the Handsontable settings under the `type` key ([Options#type](http://docs.handsontable.com/Options.html#type)).\n   * If there are cells with different types in the selected range, it returns `'mixed'`.\n   *\n   * __Note__: If data is reordered, sorted or trimmed, the currently visible order will be used.\n   *\n   * @memberof Core#\n   * @function getDataType\n   * @param {Number} rowFrom From visual row index.\n   * @param {Number} columnFrom From visual column index.\n   * @param {Number} rowTo To visual row index.\n   * @param {Number} columnTo To visual column index.\n   * @returns {String} Cell type (e.q: `'mixed'`, `'text'`, `'numeric'`, `'autocomplete'`).\n   */\n\n  this.getDataType = function (rowFrom, columnFrom, rowTo, columnTo) {\n    var _this3 = this;\n    var coords = rowFrom === void 0 ? [0, 0, this.countRows(), this.countCols()] : [rowFrom, columnFrom, rowTo, columnTo];\n    var rowStart = coords[0],\n      columnStart = coords[1];\n    var rowEnd = coords[2],\n      columnEnd = coords[3];\n    var previousType = null;\n    var currentType = null;\n    if (rowEnd === void 0) {\n      rowEnd = rowStart;\n    }\n    if (columnEnd === void 0) {\n      columnEnd = columnStart;\n    }\n    var type = 'mixed';\n    rangeEach(Math.min(rowStart, rowEnd), Math.max(rowStart, rowEnd), function (row) {\n      var isTypeEqual = true;\n      rangeEach(Math.min(columnStart, columnEnd), Math.max(columnStart, columnEnd), function (column) {\n        var cellType = _this3.getCellMeta(row, column);\n        currentType = cellType.type;\n        if (previousType) {\n          isTypeEqual = previousType === currentType;\n        } else {\n          previousType = currentType;\n        }\n        return isTypeEqual;\n      });\n      type = isTypeEqual ? currentType : 'mixed';\n      return isTypeEqual;\n    });\n    return type;\n  };\n  /**\n   * Remove a property defined by the `key` argument from the cell meta object for the provided `row` and `column` coordinates.\n   *\n   * @memberof Core#\n   * @function removeCellMeta\n   * @param {Number} row Visual row index.\n   * @param {Number} column Visual column index.\n   * @param {String} key Property name.\n   * @fires Hooks#beforeRemoveCellMeta\n   * @fires Hooks#afterRemoveCellMeta\n   */\n\n  this.removeCellMeta = function (row, column, key) {\n    var _recordTranslator$toP = recordTranslator.toPhysical(row, column),\n      _recordTranslator$toP2 = _slicedToArray(_recordTranslator$toP, 2),\n      physicalRow = _recordTranslator$toP2[0],\n      physicalColumn = _recordTranslator$toP2[1];\n    var cachedValue = priv.cellSettings[physicalRow][physicalColumn][key];\n    var hookResult = instance.runHooks('beforeRemoveCellMeta', row, column, key, cachedValue);\n    if (hookResult !== false) {\n      delete priv.cellSettings[physicalRow][physicalColumn][key];\n      instance.runHooks('afterRemoveCellMeta', row, column, key, cachedValue);\n    }\n    cachedValue = null;\n  };\n  /**\n   * Remove one or more rows from the cell meta object.\n   *\n   * @since 0.30.0\n   * @param {Number} index An integer that specifies at what position to add/remove items, Use negative values to specify the position from the end of the array.\n   * @param {Number} deleteAmount The number of items to be removed. If set to 0, no items will be removed.\n   * @param {Array} items The new items to be added to the array.\n   */\n\n  this.spliceCellsMeta = function (index, deleteAmount) {\n    var _priv$cellSettings;\n    for (var _len4 = arguments.length, items = new Array(_len4 > 2 ? _len4 - 2 : 0), _key3 = 2; _key3 < _len4; _key3++) {\n      items[_key3 - 2] = arguments[_key3];\n    }\n    (_priv$cellSettings = priv.cellSettings).splice.apply(_priv$cellSettings, [index, deleteAmount].concat(items));\n  };\n  /**\n   * Set cell meta data object defined by `prop` to the corresponding params `row` and `column`.\n   *\n   * @memberof Core#\n   * @function setCellMetaObject\n   * @param {Number} row Visual row index.\n   * @param {Number} column Visual column index.\n   * @param {Object} prop Meta object.\n   */\n\n  this.setCellMetaObject = function (row, column, prop) {\n    var _this4 = this;\n    if (_typeof(prop) === 'object') {\n      objectEach(prop, function (value, key) {\n        _this4.setCellMeta(row, column, key, value);\n      });\n    }\n  };\n  /**\n   * Sets a property defined by the `key` property to the meta object of a cell corresponding to params `row` and `column`.\n   *\n   * @memberof Core#\n   * @function setCellMeta\n   * @param {Number} row Visual row index.\n   * @param {Number} column Visual column index.\n   * @param {String} key Property name.\n   * @param {String} value Property value.\n   * @fires Hooks#afterSetCellMeta\n   */\n\n  this.setCellMeta = function (row, column, key, value) {\n    var _recordTranslator$toP3 = recordTranslator.toPhysical(row, column),\n      _recordTranslator$toP4 = _slicedToArray(_recordTranslator$toP3, 2),\n      physicalRow = _recordTranslator$toP4[0],\n      physicalColumn = _recordTranslator$toP4[1];\n    if (!priv.columnSettings[physicalColumn]) {\n      priv.columnSettings[physicalColumn] = columnFactory(GridSettings, priv.columnsSettingConflicts);\n    }\n    if (!priv.cellSettings[physicalRow]) {\n      priv.cellSettings[physicalRow] = [];\n    }\n    if (!priv.cellSettings[physicalRow][physicalColumn]) {\n      priv.cellSettings[physicalRow][physicalColumn] = new priv.columnSettings[physicalColumn]();\n    }\n    priv.cellSettings[physicalRow][physicalColumn][key] = value;\n    instance.runHooks('afterSetCellMeta', row, column, key, value);\n  };\n  /**\n   * Get all the cells meta settings at least once generated in the table (in order of cell initialization).\n   *\n   * @memberof Core#\n   * @function getCellsMeta\n   * @returns {Array} Returns an array of ColumnSettings object instances.\n   */\n\n  this.getCellsMeta = function () {\n    return arrayFlatten(priv.cellSettings);\n  };\n  /**\n   * Returns the cell properties object for the given `row` and `column` coordinates.\n   *\n   * @memberof Core#\n   * @function getCellMeta\n   * @param {Number} row Visual row index.\n   * @param {Number} column Visual column index.\n   * @returns {Object} The cell properties object.\n   * @fires Hooks#beforeGetCellMeta\n   * @fires Hooks#afterGetCellMeta\n   */\n\n  this.getCellMeta = function (row, column) {\n    var prop = datamap.colToProp(column);\n    var _recordTranslator$toP5 = recordTranslator.toPhysical(row, column),\n      _recordTranslator$toP6 = _slicedToArray(_recordTranslator$toP5, 2),\n      potentialPhysicalRow = _recordTranslator$toP6[0],\n      physicalColumn = _recordTranslator$toP6[1];\n    var physicalRow = potentialPhysicalRow; // Workaround for #11. Connected also with #3849. It should be fixed within #4497.\n\n    if (physicalRow === null) {\n      physicalRow = row;\n    }\n    if (!priv.columnSettings[physicalColumn]) {\n      priv.columnSettings[physicalColumn] = columnFactory(GridSettings, priv.columnsSettingConflicts);\n    }\n    if (!priv.cellSettings[physicalRow]) {\n      priv.cellSettings[physicalRow] = [];\n    }\n    if (!priv.cellSettings[physicalRow][physicalColumn]) {\n      priv.cellSettings[physicalRow][physicalColumn] = new priv.columnSettings[physicalColumn]();\n    }\n    var cellProperties = priv.cellSettings[physicalRow][physicalColumn]; // retrieve cellProperties from cache\n\n    cellProperties.row = physicalRow;\n    cellProperties.col = physicalColumn;\n    cellProperties.visualRow = row;\n    cellProperties.visualCol = column;\n    cellProperties.prop = prop;\n    cellProperties.instance = instance;\n    instance.runHooks('beforeGetCellMeta', row, column, cellProperties);\n    extend(cellProperties, expandType(cellProperties)); // for `type` added in beforeGetCellMeta\n\n    if (cellProperties.cells) {\n      var settings = cellProperties.cells.call(cellProperties, physicalRow, physicalColumn, prop);\n      if (settings) {\n        extend(cellProperties, settings);\n        extend(cellProperties, expandType(settings)); // for `type` added in cells\n      }\n    }\n\n    instance.runHooks('afterGetCellMeta', row, column, cellProperties);\n    return cellProperties;\n  };\n  /**\n   * Returns an array of cell meta objects for specyfied physical row index.\n   *\n   * @memberof Core#\n   * @function getCellMetaAtRow\n   * @param {Number} row Physical row index.\n   * @returns {Array}\n   */\n\n  this.getCellMetaAtRow = function (row) {\n    return priv.cellSettings[row];\n  };\n  /**\n   * Checks if the data format and config allows user to modify the column structure.\n   *\n   * @memberof Core#\n   * @function isColumnModificationAllowed\n   * @returns {Boolean}\n   */\n\n  this.isColumnModificationAllowed = function () {\n    return !(instance.dataType === 'object' || instance.getSettings().columns);\n  };\n  var rendererLookup = cellMethodLookupFactory('renderer');\n  /**\n   * Returns the cell renderer function by given `row` and `column` arguments.\n   *\n   * @memberof Core#\n   * @function getCellRenderer\n   * @param {Number|Object} row Visual row index or cell meta object (see {@link Core#getCellMeta}).\n   * @param {Number} column Visual column index.\n   * @returns {Function} The renderer function.\n   * @example\n   * ```js\n   * // Get cell renderer using `row` and `column` coordinates.\n   * hot.getCellRenderer(1, 1);\n   * // Get cell renderer using cell meta object.\n   * hot.getCellRenderer(hot.getCellMeta(1, 1));\n   * ```\n   */\n\n  this.getCellRenderer = function (row, column) {\n    return getRenderer(rendererLookup.call(this, row, column));\n  };\n  /**\n   * Returns the cell editor class by the provided `row` and `column` arguments.\n   *\n   * @memberof Core#\n   * @function getCellEditor\n   * @param {Number} row Visual row index or cell meta object (see {@link Core#getCellMeta}).\n   * @param {Number} column Visual column index.\n   * @returns {Function} The editor class.\n   * @example\n   * ```js\n   * // Get cell editor class using `row` and `column` coordinates.\n   * hot.getCellEditor(1, 1);\n   * // Get cell editor class using cell meta object.\n   * hot.getCellEditor(hot.getCellMeta(1, 1));\n   * ```\n   */\n\n  this.getCellEditor = cellMethodLookupFactory('editor');\n  var validatorLookup = cellMethodLookupFactory('validator');\n  /**\n   * Returns the cell validator by `row` and `column`.\n   *\n   * @memberof Core#\n   * @function getCellValidator\n   * @param {Number|Object} row Visual row index or cell meta object (see {@link Core#getCellMeta}).\n   * @param {Number} column Visual column index.\n   * @returns {Function|RegExp|undefined} The validator function.\n   * @example\n   * ```js\n   * // Get cell valiator using `row` and `column` coordinates.\n   * hot.getCellValidator(1, 1);\n   * // Get cell valiator using cell meta object.\n   * hot.getCellValidator(hot.getCellMeta(1, 1));\n   * ```\n   */\n\n  this.getCellValidator = function (row, column) {\n    var validator = validatorLookup.call(this, row, column);\n    if (typeof validator === 'string') {\n      validator = getValidator(validator);\n    }\n    return validator;\n  };\n  /**\n   * Validates all cells using their validator functions and calls callback when finished.\n   *\n   * If one of the cells is invalid, the callback will be fired with `'valid'` arguments as `false` - otherwise it\n   * would equal `true`.\n   *\n   * @memberof Core#\n   * @function validateCells\n   * @param {Function} [callback] The callback function.\n   * @example\n   * ```js\n   * hot.validateCells((valid) => {\n   *   if (valid) {\n   *     // ... code for validated cells\n   *   }\n   * })\n   * ```\n   */\n\n  this.validateCells = function (callback) {\n    this._validateCells(callback);\n  };\n  /**\n   * Validates rows using their validator functions and calls callback when finished.\n   *\n   * If one of the cells is invalid, the callback will be fired with `'valid'` arguments as `false` - otherwise it\n   *  would equal `true`.\n   *\n   * @memberof Core#\n   * @function validateRows\n   * @param {Array} [rows] Array of validation target visual row indexes.\n   * @param {Function} [callback] The callback function.\n   * @example\n   * ```js\n   * hot.validateRows([3, 4, 5], (valid) => {\n   *   if (valid) {\n   *     // ... code for validated rows\n   *   }\n   * })\n   * ```\n   */\n\n  this.validateRows = function (rows, callback) {\n    if (!Array.isArray(rows)) {\n      throw new Error('validateRows parameter `rows` must be an array');\n    }\n    this._validateCells(callback, rows);\n  };\n  /**\n   * Validates columns using their validator functions and calls callback when finished.\n   *\n   * If one of the cells is invalid, the callback will be fired with `'valid'` arguments as `false` - otherwise it\n   *  would equal `true`.\n   *\n   * @memberof Core#\n   * @function validateColumns\n   * @param {Array} [columns] Array of validation target visual columns indexes.\n   * @param {Function} [callback] The callback function.\n   * @example\n   * ```js\n   * hot.validateColumns([3, 4, 5], (valid) => {\n   *   if (valid) {\n   *     // ... code for validated columns\n   *   }\n   * })\n   * ```\n   */\n\n  this.validateColumns = function (columns, callback) {\n    if (!Array.isArray(columns)) {\n      throw new Error('validateColumns parameter `columns` must be an array');\n    }\n    this._validateCells(callback, undefined, columns);\n  };\n  /**\n   * Validates all cells using their validator functions and calls callback when finished.\n   *\n   * If one of the cells is invalid, the callback will be fired with `'valid'` arguments as `false` - otherwise it would equal `true`.\n   *\n   * Private use intended.\n   *\n   * @private\n   * @memberof Core#\n   * @function _validateCells\n   * @param {Function} [callback] The callback function.\n   * @param {Array} [rows] An array of validation target visual row indexes.\n   * @param {Array} [columns] An array of validation target visual column indexes.\n   */\n\n  this._validateCells = function (callback, rows, columns) {\n    var waitingForValidator = new ValidatorsQueue();\n    if (callback) {\n      waitingForValidator.onQueueEmpty = callback;\n    }\n    var i = instance.countRows() - 1;\n    while (i >= 0) {\n      if (rows !== undefined && rows.indexOf(i) === -1) {\n        i -= 1;\n        continue;\n      }\n      var j = instance.countCols() - 1;\n      while (j >= 0) {\n        if (columns !== undefined && columns.indexOf(j) === -1) {\n          j -= 1;\n          continue;\n        }\n        waitingForValidator.addValidatorToQueue();\n        instance.validateCell(instance.getDataAtCell(i, j), instance.getCellMeta(i, j), function (result) {\n          if (typeof result !== 'boolean') {\n            throw new Error('Validation error: result is not boolean');\n          }\n          if (result === false) {\n            waitingForValidator.valid = false;\n          }\n          waitingForValidator.removeValidatorFormQueue();\n        }, 'validateCells');\n        j -= 1;\n      }\n      i -= 1;\n    }\n    waitingForValidator.checkIfQueueIsEmpty();\n  };\n  /**\n   * Returns an array of row headers' values (if they are enabled). If param `row` was given, it returns the header of the given row as a string.\n   *\n   * @memberof Core#\n   * @function getRowHeader\n   * @param {Number} [row] Visual row index.\n   * @fires Hooks#modifyRowHeader\n   * @returns {Array|String|Number} Array of header values / single header value.\n   */\n\n  this.getRowHeader = function (row) {\n    var rowHeader = priv.settings.rowHeaders;\n    var physicalRow = row;\n    if (physicalRow !== void 0) {\n      physicalRow = instance.runHooks('modifyRowHeader', physicalRow);\n    }\n    if (physicalRow === void 0) {\n      rowHeader = [];\n      rangeEach(instance.countRows() - 1, function (i) {\n        rowHeader.push(instance.getRowHeader(i));\n      });\n    } else if (Array.isArray(rowHeader) && rowHeader[physicalRow] !== void 0) {\n      rowHeader = rowHeader[physicalRow];\n    } else if (isFunction(rowHeader)) {\n      rowHeader = rowHeader(physicalRow);\n    } else if (rowHeader && typeof rowHeader !== 'string' && typeof rowHeader !== 'number') {\n      rowHeader = physicalRow + 1;\n    }\n    return rowHeader;\n  };\n  /**\n   * Returns information about if this table is configured to display row headers.\n   *\n   * @memberof Core#\n   * @function hasRowHeaders\n   * @returns {Boolean} `true` if the instance has the row headers enabled, `false` otherwise.\n   */\n\n  this.hasRowHeaders = function () {\n    return !!priv.settings.rowHeaders;\n  };\n  /**\n   * Returns information about if this table is configured to display column headers.\n   *\n   * @memberof Core#\n   * @function hasColHeaders\n   * @returns {Boolean} `true` if the instance has the column headers enabled, `false` otherwise.\n   */\n\n  this.hasColHeaders = function () {\n    if (priv.settings.colHeaders !== void 0 && priv.settings.colHeaders !== null) {\n      // Polymer has empty value = null\n      return !!priv.settings.colHeaders;\n    }\n    for (var i = 0, ilen = instance.countCols(); i < ilen; i++) {\n      if (instance.getColHeader(i)) {\n        return true;\n      }\n    }\n    return false;\n  };\n  /**\n   * Returns an array of column headers (in string format, if they are enabled). If param `column` is given, it\n   * returns the header at the given column.\n   *\n   * @memberof Core#\n   * @function getColHeader\n   * @param {Number} [column] Visual column index.\n   * @fires Hooks#modifyColHeader\n   * @returns {Array|String|Number} The column header(s).\n   */\n\n  this.getColHeader = function (column) {\n    var columnsAsFunc = priv.settings.columns && isFunction(priv.settings.columns);\n    var columnIndex = instance.runHooks('modifyColHeader', column);\n    var result = priv.settings.colHeaders;\n    if (columnIndex === void 0) {\n      var out = [];\n      var ilen = columnsAsFunc ? instance.countSourceCols() : instance.countCols();\n      for (var i = 0; i < ilen; i++) {\n        out.push(instance.getColHeader(i));\n      }\n      result = out;\n    } else {\n      var translateVisualIndexToColumns = function translateVisualIndexToColumns(visualColumnIndex) {\n        var arr = [];\n        var columnsLen = instance.countSourceCols();\n        var index = 0;\n        for (; index < columnsLen; index++) {\n          if (isFunction(instance.getSettings().columns) && instance.getSettings().columns(index)) {\n            arr.push(index);\n          }\n        }\n        return arr[visualColumnIndex];\n      };\n      var baseCol = columnIndex;\n      var physicalColumn = instance.runHooks('modifyCol', baseCol);\n      var prop = translateVisualIndexToColumns(physicalColumn);\n      if (priv.settings.colHeaders === false) {\n        result = null;\n      } else if (priv.settings.columns && isFunction(priv.settings.columns) && priv.settings.columns(prop) && priv.settings.columns(prop).title) {\n        result = priv.settings.columns(prop).title;\n      } else if (priv.settings.columns && priv.settings.columns[physicalColumn] && priv.settings.columns[physicalColumn].title) {\n        result = priv.settings.columns[physicalColumn].title;\n      } else if (Array.isArray(priv.settings.colHeaders) && priv.settings.colHeaders[physicalColumn] !== void 0) {\n        result = priv.settings.colHeaders[physicalColumn];\n      } else if (isFunction(priv.settings.colHeaders)) {\n        result = priv.settings.colHeaders(physicalColumn);\n      } else if (priv.settings.colHeaders && typeof priv.settings.colHeaders !== 'string' && typeof priv.settings.colHeaders !== 'number') {\n        result = spreadsheetColumnLabel(baseCol); // see #1458\n      }\n    }\n\n    return result;\n  };\n  /**\n   * Return column width from settings (no guessing). Private use intended.\n   *\n   * @private\n   * @memberof Core#\n   * @function _getColWidthFromSettings\n   * @param {Number} col Visual col index.\n   * @returns {Number}\n   */\n\n  this._getColWidthFromSettings = function (col) {\n    var cellProperties = instance.getCellMeta(0, col);\n    var width = cellProperties.width;\n    if (width === void 0 || width === priv.settings.width) {\n      width = cellProperties.colWidths;\n    }\n    if (width !== void 0 && width !== null) {\n      switch (_typeof(width)) {\n        case 'object':\n          // array\n          width = width[col];\n          break;\n        case 'function':\n          width = width(col);\n          break;\n        default:\n          break;\n      }\n      if (typeof width === 'string') {\n        width = parseInt(width, 10);\n      }\n    }\n    return width;\n  };\n  /**\n   * Returns the width of the requested column.\n   *\n   * @memberof Core#\n   * @function getColWidth\n   * @param {Number} column Visual column index.\n   * @returns {Number} Column width.\n   * @fires Hooks#modifyColWidth\n   */\n\n  this.getColWidth = function (column) {\n    var width = instance._getColWidthFromSettings(column);\n    width = instance.runHooks('modifyColWidth', width, column);\n    if (width === void 0) {\n      width = ViewportColumnsCalculator.DEFAULT_WIDTH;\n    }\n    return width;\n  };\n  /**\n   * Return row height from settings (no guessing). Private use intended.\n   *\n   * @private\n   * @memberof Core#\n   * @function _getRowHeightFromSettings\n   * @param {Number} row Visual row index.\n   * @returns {Number}\n   */\n\n  this._getRowHeightFromSettings = function (row) {\n    // let cellProperties = instance.getCellMeta(row, 0);\n    // let height = cellProperties.height;\n    //\n    // if (height === void 0 || height === priv.settings.height) {\n    //  height = cellProperties.rowHeights;\n    // }\n    var height = priv.settings.rowHeights;\n    if (height !== void 0 && height !== null) {\n      switch (_typeof(height)) {\n        case 'object':\n          // array\n          height = height[row];\n          break;\n        case 'function':\n          height = height(row);\n          break;\n        default:\n          break;\n      }\n      if (typeof height === 'string') {\n        height = parseInt(height, 10);\n      }\n    }\n    return height;\n  };\n  /**\n   * Returns the row height.\n   *\n   * @memberof Core#\n   * @function getRowHeight\n   * @param {Number} row Visual row index.\n   * @returns {Number} The given row's height.\n   * @fires Hooks#modifyRowHeight\n   */\n\n  this.getRowHeight = function (row) {\n    var height = instance._getRowHeightFromSettings(row);\n    height = instance.runHooks('modifyRowHeight', height, row);\n    return height;\n  };\n  /**\n   * Returns the total number of rows in the data source.\n   *\n   * @memberof Core#\n   * @function countSourceRows\n   * @returns {Number} Total number of rows.\n   */\n\n  this.countSourceRows = function () {\n    var sourceLength = instance.runHooks('modifySourceLength');\n    return sourceLength || (instance.getSourceData() ? instance.getSourceData().length : 0);\n  };\n  /**\n   * Returns the total number of columns in the data source.\n   *\n   * @memberof Core#\n   * @function countSourceCols\n   * @returns {Number} Total number of columns.\n   */\n\n  this.countSourceCols = function () {\n    var len = 0;\n    var obj = instance.getSourceData() && instance.getSourceData()[0] ? instance.getSourceData()[0] : [];\n    if (isObject(obj)) {\n      len = deepObjectSize(obj);\n    } else {\n      len = obj.length || 0;\n    }\n    return len;\n  };\n  /**\n   * Returns the total number of visual rows in the table.\n   *\n   * @memberof Core#\n   * @function countRows\n   * @returns {Number} Total number of rows.\n   */\n\n  this.countRows = function () {\n    return datamap.getLength();\n  };\n  /**\n   * Returns the total number of visible columns in the table.\n   *\n   * @memberof Core#\n   * @function countCols\n   * @returns {Number} Total number of columns.\n   */\n\n  this.countCols = function () {\n    var maxCols = this.getSettings().maxCols;\n    var dataHasLength = false;\n    var dataLen = 0;\n    if (instance.dataType === 'array') {\n      dataHasLength = priv.settings.data && priv.settings.data[0] && priv.settings.data[0].length;\n    }\n    if (dataHasLength) {\n      dataLen = priv.settings.data[0].length;\n    }\n    if (priv.settings.columns) {\n      var columnsIsFunction = isFunction(priv.settings.columns);\n      if (columnsIsFunction) {\n        if (instance.dataType === 'array') {\n          var columnLen = 0;\n          for (var i = 0; i < dataLen; i++) {\n            if (priv.settings.columns(i)) {\n              columnLen += 1;\n            }\n          }\n          dataLen = columnLen;\n        } else if (instance.dataType === 'object' || instance.dataType === 'function') {\n          dataLen = datamap.colToPropCache.length;\n        }\n      } else {\n        dataLen = priv.settings.columns.length;\n      }\n    } else if (instance.dataType === 'object' || instance.dataType === 'function') {\n      dataLen = datamap.colToPropCache.length;\n    }\n    return Math.min(maxCols, dataLen);\n  };\n  /**\n   * Returns an visual index of the first rendered row.\n   * Returns -1 if no row is rendered.\n   *\n   * @memberof Core#\n   * @function rowOffset\n   * @returns {Number} Visual index of first rendered row.\n   */\n\n  this.rowOffset = function () {\n    return instance.view.wt.wtTable.getFirstRenderedRow();\n  };\n  /**\n   * Returns the visual index of the first rendered column.\n   * Returns -1 if no column is rendered.\n   *\n   * @memberof Core#\n   * @function colOffset\n   * @returns {Number} Visual index of the first visible column.\n   */\n\n  this.colOffset = function () {\n    return instance.view.wt.wtTable.getFirstRenderedColumn();\n  };\n  /**\n   * Returns the number of rendered rows (including rows partially or fully rendered outside viewport).\n   *\n   * @memberof Core#\n   * @function countRenderedRows\n   * @returns {Number} Returns -1 if table is not visible.\n   */\n\n  this.countRenderedRows = function () {\n    return instance.view.wt.drawn ? instance.view.wt.wtTable.getRenderedRowsCount() : -1;\n  };\n  /**\n   * Returns the number of visible rows (rendered rows that fully fit inside viewport).\n   *\n   * @memberof Core#\n   * @function countVisibleRows\n   * @returns {Number} Number of visible rows or -1.\n   */\n\n  this.countVisibleRows = function () {\n    return instance.view.wt.drawn ? instance.view.wt.wtTable.getVisibleRowsCount() : -1;\n  };\n  /**\n   * Returns the number of rendered columns (including columns partially or fully rendered outside viewport).\n   *\n   * @memberof Core#\n   * @function countRenderedCols\n   * @returns {Number} Returns -1 if table is not visible.\n   */\n\n  this.countRenderedCols = function () {\n    return instance.view.wt.drawn ? instance.view.wt.wtTable.getRenderedColumnsCount() : -1;\n  };\n  /**\n   * Returns the number of visible columns. Returns -1 if table is not visible\n   *\n   * @memberof Core#\n   * @function countVisibleCols\n   * @return {Number} Number of visible columns or -1.\n   */\n\n  this.countVisibleCols = function () {\n    return instance.view.wt.drawn ? instance.view.wt.wtTable.getVisibleColumnsCount() : -1;\n  };\n  /**\n   * Returns the number of empty rows. If the optional ending parameter is `true`, returns the\n   * number of empty rows at the bottom of the table.\n   *\n   * @memberof Core#\n   * @function countEmptyRows\n   * @param {Boolean} [ending=false] If `true`, will only count empty rows at the end of the data source.\n   * @returns {Number} Count empty rows.\n   */\n\n  this.countEmptyRows = function () {\n    var ending = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var emptyRows = 0;\n    rangeEachReverse(instance.countRows() - 1, function (visualIndex) {\n      if (instance.isEmptyRow(visualIndex)) {\n        emptyRows += 1;\n      } else if (ending === true) {\n        return false;\n      }\n    });\n    return emptyRows;\n  };\n  /**\n   * Returns the number of empty columns. If the optional ending parameter is `true`, returns the number of empty\n   * columns at right hand edge of the table.\n   *\n   * @memberof Core#\n   * @function countEmptyCols\n   * @param {Boolean} [ending=false] If `true`, will only count empty columns at the end of the data source row.\n   * @returns {Number} Count empty cols.\n   */\n\n  this.countEmptyCols = function () {\n    var ending = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (instance.countRows() < 1) {\n      return 0;\n    }\n    var emptyColumns = 0;\n    rangeEachReverse(instance.countCols() - 1, function (visualIndex) {\n      if (instance.isEmptyCol(visualIndex)) {\n        emptyColumns += 1;\n      } else if (ending === true) {\n        return false;\n      }\n    });\n    return emptyColumns;\n  };\n  /**\n   * Check if all cells in the row declared by the `row` argument are empty.\n   *\n   * @memberof Core#\n   * @function isEmptyRow\n   * @param {Number} row Visual row index.\n   * @returns {Boolean} `true` if the row at the given `row` is empty, `false` otherwise.\n   */\n\n  this.isEmptyRow = function (row) {\n    return priv.settings.isEmptyRow.call(instance, row);\n  };\n  /**\n   * Check if all cells in the the column declared by the `column` argument are empty.\n   *\n   * @memberof Core#\n   * @function isEmptyCol\n   * @param {Number} column Column index.\n   * @returns {Boolean} `true` if the column at the given `col` is empty, `false` otherwise.\n   */\n\n  this.isEmptyCol = function (column) {\n    return priv.settings.isEmptyCol.call(instance, column);\n  };\n  /**\n   * Select cell specified by `row` and `column` values or a range of cells finishing at `endRow`, `endCol`. If the table\n   * was configured to support data column properties that properties can be used to making a selection.\n   *\n   * By default, viewport will be scrolled to the selection. After the `selectCell` method had finished, the instance\n   * will be listening to keyboard input on the document.\n   *\n   * @example\n   * ```js\n   * // select a single cell\n   * hot.selectCell(2, 4);\n   * // select a single cell using column property\n   * hot.selectCell(2, 'address');\n   * // select a range of cells\n   * hot.selectCell(2, 4, 3, 5);\n   * // select a range of cells using column properties\n   * hot.selectCell(2, 'address', 3, 'phone_number');\n   * // select a range of cells without scrolling to them\n   * hot.selectCell(2, 'address', 3, 'phone_number', false);\n   * ```\n   *\n   * @memberof Core#\n   * @function selectCell\n   * @param {Number} row Visual row index.\n   * @param {Number|String} column Visual column index or column property.\n   * @param {Number} [endRow] Visual end row index (if selecting a range).\n   * @param {Number|String} [endColumn] Visual end column index or column property (if selecting a range).\n   * @param {Boolean} [scrollToCell=true] If `true`, the viewport will be scrolled to the selection.\n   * @param {Boolean} [changeListener=true] If `false`, Handsontable will not change keyboard events listener to himself.\n   * @returns {Boolean} `true` if selection was successful, `false` otherwise.\n   */\n\n  this.selectCell = function (row, column, endRow, endColumn) {\n    var scrollToCell = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    var changeListener = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n    if (isUndefined(row) || isUndefined(column)) {\n      return false;\n    }\n    return this.selectCells([[row, column, endRow, endColumn]], scrollToCell, changeListener);\n  };\n  /**\n   * Make multiple, non-contiguous selection specified by `row` and `column` values or a range of cells\n   * finishing at `endRow`, `endColumn`. The method supports two input formats which are the same as that\n   * produces by `getSelected` and `getSelectedRange` methods.\n   *\n   * By default, viewport will be scrolled to selection. After the `selectCells` method had finished, the instance\n   * will be listening to keyboard input on the document.\n   *\n   * @example\n   * ```js\n   * // Using an array of arrays.\n   * hot.selectCells([[1, 1, 2, 2], [3, 3], [6, 2, 0, 2]]);\n   * // Using an array of arrays with defined columns as props.\n   * hot.selectCells([[1, 'id', 2, 'first_name'], [3, 'full_name'], [6, 'last_name', 0, 'first_name']]);\n   * // Using an array of CellRange objects (produced by `.getSelectedRange()` method).\n   * const selected = hot.getSelectedRange();\n   *\n   * selected[0].from.row = 0;\n   * selected[0].from.col = 0;\n   *\n   * hot.selectCells(selected);\n   * ```\n   *\n   * @memberof Core#\n   * @since 0.38.0\n   * @function selectCells\n   * @param {Array[]|CellRange[]} coords Visual coords passed as an array of array (`[[rowStart, columnStart, rowEnd, columnEnd], ...]`)\n   *                                     the same format as `getSelected` method returns or as an CellRange objects\n   *                                     which is the same format what `getSelectedRange` method returns.\n   * @param {Boolean} [scrollToCell=true] If `true`, the viewport will be scrolled to the selection.\n   * @param {Boolean} [changeListener=true] If `false`, Handsontable will not change keyboard events listener to himself.\n   * @returns {Boolean} `true` if selection was successful, `false` otherwise.\n   */\n\n  this.selectCells = function () {\n    var coords = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [[]];\n    var scrollToCell = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var changeListener = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    if (scrollToCell === false) {\n      preventScrollingToCell = true;\n    }\n    var wasSelected = selection.selectCells(coords);\n    if (wasSelected && changeListener) {\n      instance.listen();\n    }\n    preventScrollingToCell = false;\n    return wasSelected;\n  };\n  /**\n   * Select column specified by `startColumn` visual index, column property or a range of columns finishing at `endColumn`.\n   *\n   * @example\n   * ```js\n   * // Select column using visual index.\n   * hot.selectColumns(1);\n   * // Select column using column property.\n   * hot.selectColumns('id');\n   * // Select range of columns using visual indexes.\n   * hot.selectColumns(1, 4);\n   * // Select range of columns using column properties.\n   * hot.selectColumns('id', 'last_name');\n   * ```\n   *\n   * @memberof Core#\n   * @since 0.38.0\n   * @function selectColumns\n   * @param {Number} startColumn The visual column index from which the selection starts.\n   * @param {Number} [endColumn=startColumn] The visual column index to which the selection finishes. If `endColumn`\n   *                                         is not defined the column defined by `startColumn` will be selected.\n   * @returns {Boolean} `true` if selection was successful, `false` otherwise.\n   */\n\n  this.selectColumns = function (startColumn) {\n    var endColumn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startColumn;\n    return selection.selectColumns(startColumn, endColumn);\n  };\n  /**\n   * Select row specified by `startRow` visual index or a range of rows finishing at `endRow`.\n   *\n   * @example\n   * ```js\n   * // Select row using visual index.\n   * hot.selectRows(1);\n   * // Select range of rows using visual indexes.\n   * hot.selectRows(1, 4);\n   * ```\n   *\n   * @memberof Core#\n   * @since 0.38.0\n   * @function selectRows\n   * @param {Number} startRow The visual row index from which the selection starts.\n   * @param {Number} [endRow=startRow] The visual row index to which the selection finishes. If `endRow`\n   *                                   is not defined the row defined by `startRow` will be selected.\n   * @returns {Boolean} `true` if selection was successful, `false` otherwise.\n   */\n\n  this.selectRows = function (startRow) {\n    var endRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startRow;\n    return selection.selectRows(startRow, endRow);\n  };\n  /**\n   * Deselects the current cell selection on the table.\n   *\n   * @memberof Core#\n   * @function deselectCell\n   */\n\n  this.deselectCell = function () {\n    selection.deselect();\n  };\n  /**\n   * Select the whole table. The previous selection will be overwritten.\n   *\n   * @since 0.38.2\n   * @memberof Core#\n   * @function selectAll\n   */\n\n  this.selectAll = function () {\n    preventScrollingToCell = true;\n    selection.selectAll();\n    preventScrollingToCell = false;\n  };\n  /**\n   * Scroll viewport to coordinates specified by the `row` and `column` arguments.\n   *\n   * @memberof Core#\n   * @function scrollViewportTo\n   * @param {Number} [row] Visual row index.\n   * @param {Number} [column] Visual column index.\n   * @param {Boolean} [snapToBottom = false] If `true`, viewport is scrolled to show the cell on the bottom of the table.\n   * @param {Boolean} [snapToRight = false] If `true`, viewport is scrolled to show the cell on the right side of the table.\n   * @returns {Boolean} `true` if scroll was successful, `false` otherwise.\n   */\n\n  this.scrollViewportTo = function (row, column) {\n    var snapToBottom = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var snapToRight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var snapToTop = !snapToBottom;\n    var snapToLeft = !snapToRight;\n    var result = false;\n    if (row !== void 0 && column !== void 0) {\n      result = instance.view.scrollViewport(new CellCoords(row, column), snapToTop, snapToRight, snapToBottom, snapToLeft);\n    }\n    if (typeof row === 'number' && typeof column !== 'number') {\n      result = instance.view.scrollViewportVertically(row, snapToTop, snapToBottom);\n    }\n    if (typeof column === 'number' && typeof row !== 'number') {\n      result = instance.view.scrollViewportHorizontally(column, snapToRight, snapToLeft);\n    }\n    return result;\n  };\n  /**\n   * Removes the table from the DOM and destroys the instance of the Handsontable.\n   *\n   * @memberof Core#\n   * @function destroy\n   * @fires Hooks#afterDestroy\n   */\n\n  this.destroy = function () {\n    instance._clearTimeouts();\n    instance._clearImmediates();\n    if (instance.view) {\n      // in case HT is destroyed before initialization has finished\n      instance.view.destroy();\n    }\n    if (dataSource) {\n      dataSource.destroy();\n    }\n    dataSource = null;\n    keyStateStopObserving();\n    if (isRootInstance(instance)) {\n      var licenseInfo = this.rootDocument.querySelector('#hot-display-license-info');\n      if (licenseInfo) {\n        licenseInfo.parentNode.removeChild(licenseInfo);\n      }\n    }\n    empty(instance.rootElement);\n    eventManager.destroy();\n    if (editorManager) {\n      editorManager.destroy();\n    }\n    instance.runHooks('afterDestroy');\n    Hooks.getSingleton().destroy(instance);\n    objectEach(instance, function (property, key, obj) {\n      // replace instance methods with post mortem\n      if (isFunction(property)) {\n        obj[key] = postMortem(key);\n      } else if (key !== 'guid') {\n        // replace instance properties with null (restores memory)\n        // it should not be necessary but this prevents a memory leak side effects that show itself in Jasmine tests\n        obj[key] = null;\n      }\n    });\n    instance.isDestroyed = true; // replace private properties with null (restores memory)\n    // it should not be necessary but this prevents a memory leak side effects that show itself in Jasmine tests\n\n    if (datamap) {\n      datamap.destroy();\n    }\n    datamap = null;\n    priv = null;\n    grid = null;\n    selection = null;\n    editorManager = null;\n    instance = null;\n    GridSettings = null;\n  };\n  /**\n   * Replacement for all methods after Handsotnable was destroyed.\n   *\n   * @private\n   */\n\n  function postMortem(method) {\n    return function () {\n      throw new Error(\"The \\\"\".concat(method, \"\\\" method cannot be called because this Handsontable instance has been destroyed\"));\n    };\n  }\n  /**\n   * Returns the active editor class instance.\n   *\n   * @memberof Core#\n   * @function getActiveEditor\n   * @returns {BaseEditor} The active editor instance.\n   */\n\n  this.getActiveEditor = function () {\n    return editorManager.getActiveEditor();\n  };\n  /**\n   * Returns plugin instance by provided its name.\n   *\n   * @memberof Core#\n   * @function getPlugin\n   * @param {String} pluginName The plugin name.\n   * @returns {BasePlugin} The plugin instance.\n   */\n\n  this.getPlugin = function (pluginName) {\n    return getPlugin(this, pluginName);\n  };\n  /**\n   * Returns the Handsontable instance.\n   *\n   * @memberof Core#\n   * @function getInstance\n   * @returns {Handsontable} The Handsontable instance.\n   */\n\n  this.getInstance = function () {\n    return instance;\n  };\n  /**\n   * Adds listener to the specified hook name (only for this Handsontable instance).\n   *\n   * @memberof Core#\n   * @function addHook\n   * @see Hooks#add\n   * @param {String} key Hook name (see {@link Hooks}).\n   * @param {Function|Array} callback Function or array of functions.\n   * @example\n   * ```js\n   * hot.addHook('beforeInit', myCallback);\n   * ```\n   */\n\n  this.addHook = function (key, callback) {\n    Hooks.getSingleton().add(key, callback, instance);\n  };\n  /**\n   * Check if for a specified hook name there are added listeners (only for this Handsontable instance). All available\n   * hooks you will find {@link Hooks}.\n   *\n   * @memberof Core#\n   * @function hasHook\n   * @see Hooks#has\n   * @param {String} key Hook name\n   * @return {Boolean}\n   *\n   * @example\n   * ```js\n   * const hasBeforeInitListeners = hot.hasHook('beforeInit');\n   * ```\n   */\n\n  this.hasHook = function (key) {\n    return Hooks.getSingleton().has(key, instance);\n  };\n  /**\n   * Adds listener to specified hook name (only for this Handsontable instance). After the listener is triggered,\n   * it will be automatically removed.\n   *\n   * @memberof Core#\n   * @function addHookOnce\n   * @see Hooks#once\n   * @param {String} key Hook name (see {@link Hooks}).\n   * @param {Function|Array} callback Function or array of functions.\n   * @example\n   * ```js\n   * hot.addHookOnce('beforeInit', myCallback);\n   * ```\n   */\n\n  this.addHookOnce = function (key, callback) {\n    Hooks.getSingleton().once(key, callback, instance);\n  };\n  /**\n   * Removes the hook listener previously registered with {@link Core#addHook}.\n   *\n   * @memberof Core#\n   * @function removeHook\n   * @see Hooks#remove\n   * @param {String} key Hook name.\n   * @param {Function} callback Reference to the function which has been registered using {@link Core#addHook}.\n   *\n   * @example\n   * ```js\n   * hot.removeHook('beforeInit', myCallback);\n   * ```\n   */\n\n  this.removeHook = function (key, callback) {\n    Hooks.getSingleton().remove(key, callback, instance);\n  };\n  /**\n   * Run the callbacks for the hook provided in the `key` argument using the parameters given in the other arguments.\n   *\n   * @memberof Core#\n   * @function runHooks\n   * @see Hooks#run\n   * @param {String} key Hook name.\n   * @param {*} [p1] Argument passed to the callback.\n   * @param {*} [p2] Argument passed to the callback.\n   * @param {*} [p3] Argument passed to the callback.\n   * @param {*} [p4] Argument passed to the callback.\n   * @param {*} [p5] Argument passed to the callback.\n   * @param {*} [p6] Argument passed to the callback.\n   * @returns {*}\n   *\n   * @example\n   * ```js\n   * // Run built-in hook\n   * hot.runHooks('beforeInit');\n   * // Run custom hook\n   * hot.runHooks('customAction', 10, 'foo');\n   * ```\n   */\n\n  this.runHooks = function (key, p1, p2, p3, p4, p5, p6) {\n    return Hooks.getSingleton().run(instance, key, p1, p2, p3, p4, p5, p6);\n  };\n  /**\n   * Get language phrase for specified dictionary key.\n   *\n   * @memberof Core#\n   * @function getTranslatedPhrase\n   * @since 0.35.0\n   * @param {String} dictionaryKey Constant which is dictionary key.\n   * @param {*} extraArguments Arguments which will be handled by formatters.\n   * @returns {String}\n   */\n\n  this.getTranslatedPhrase = function (dictionaryKey, extraArguments) {\n    return getTranslatedPhrase(priv.settings.language, dictionaryKey, extraArguments);\n  };\n  /**\n   * Converts instance into outerHTML of HTMLTableElement.\n   *\n   * @memberof Core#\n   * @function toHTML\n   * @since 7.1.0\n   * @returns {String}\n   */\n\n  this.toHTML = function () {\n    return instanceToHTML(_this);\n  };\n  /**\n   * Converts instance into HTMLTableElement.\n   *\n   * @memberof Core#\n   * @function toTableElement\n   * @since 7.1.0\n   * @returns {HTMLTableElement}\n   */\n\n  this.toTableElement = function () {\n    var tempElement = _this.rootDocument.createElement('div');\n    tempElement.insertAdjacentHTML('afterbegin', instanceToHTML(_this));\n    return tempElement.firstElementChild;\n  };\n  this.timeouts = [];\n  /**\n   * Sets timeout. Purpose of this method is to clear all known timeouts when `destroy` method is called.\n   *\n   * @param {Number|Function} handle Handler returned from setTimeout or function to execute (it will be automatically wraped\n   *                                 by setTimeout function).\n   * @param {Number} [delay=0] If first argument is passed as a function this argument set delay of the execution of that function.\n   * @private\n   */\n\n  this._registerTimeout = function (handle) {\n    var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var handleFunc = handle;\n    if (typeof handleFunc === 'function') {\n      handleFunc = setTimeout(handleFunc, delay);\n    }\n    this.timeouts.push(handleFunc);\n  };\n  /**\n   * Clears all known timeouts.\n   *\n   * @private\n   */\n\n  this._clearTimeouts = function () {\n    arrayEach(this.timeouts, function (handler) {\n      clearTimeout(handler);\n    });\n  };\n  this.immediates = [];\n  /**\n   * Execute function execution to the next event loop cycle. Purpose of this method is to clear all known timeouts when `destroy` method is called.\n   *\n   * @param {Function} callback Function to be delayed in execution.\n   * @private\n   */\n\n  this._registerImmediate = function (callback) {\n    this.immediates.push(setImmediate(callback));\n  };\n  /**\n   * Clears all known timeouts.\n   *\n   * @private\n   */\n\n  this._clearImmediates = function () {\n    arrayEach(this.immediates, function (handler) {\n      clearImmediate(handler);\n    });\n  };\n  /**\n   * Refresh selection borders. This is temporary method relic after selection rewrite.\n   *\n   * @private\n   * @param {Boolean} [revertOriginal=false] If `true`, the previous value will be restored. Otherwise, the edited value will be saved.\n   * @param {Boolean} [prepareEditorIfNeeded=true] If `true` the editor under the selected cell will be prepared to open.\n   */\n\n  this._refreshBorders = function () {\n    var revertOriginal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var prepareEditorIfNeeded = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    editorManager.destroyEditor(revertOriginal);\n    instance.view.render();\n    if (prepareEditorIfNeeded && selection.isSelected()) {\n      editorManager.prepareEditor();\n    }\n  };\n  Hooks.getSingleton().run(instance, 'construct');\n}","map":{"version":3,"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","TypeError","Object","toString","call","_arr","_n","_d","_e","undefined","_i","_s","next","done","push","value","length","err","Array","isArray","_toConsumableArray","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","iter","from","arr2","addClass","empty","isChildOfWebComponentTable","removeClass","columnFactory","isFunction","warn","isDefined","isUndefined","isRegExp","_injectProductInfo","isEmpty","isMobileBrowser","DataMap","EditorManager","EventManager","deepClone","duckSchema","extend","isObject","isObjectEqual","deepObjectSize","hasOwnProperty","createObjectPropListener","objectEach","arrayFlatten","arrayMap","arrayEach","arrayReduce","instanceToHTML","getPlugin","getRenderer","getValidator","randomString","rangeEach","rangeEachReverse","TableView","DataSource","translateRowsToColumns","cellMethodLookupFactory","spreadsheetColumnLabel","getTranslator","registerAsRootInstance","hasValidParameter","isRootInstance","CellCoords","ViewportColumnsCalculator","Hooks","DefaultSettings","getCellType","getTranslatedPhrase","hasLanguageDictionary","warnUserAboutLanguageRegistration","applyLanguageSetting","normalizeLanguageCode","startObserving","keyStateStartObserving","stopObserving","keyStateStopObserving","Selection","activeGuid","Core","rootElement","userSettings","_this","rootInstanceSymbol","arguments","preventScrollingToCell","instance","GridSettings","eventManager","priv","datamap","dataSource","grid","editorManager","expandType","language","rootDocument","ownerDocument","rootWindow","defaultView","isDestroyed","isHotTableEnv","container","createElement","renderCall","insertBefore","firstChild","licenseKey","guid","concat","recordTranslator","id","substring","cellSettings","columnSettings","columnsSettingConflicts","settings","selRange","isPopulated","scrollable","firstRun","selection","countCols","countRows","propToCol","prop","isEditorOpened","getActiveEditor","isOpened","addLocalHook","cellCoords","runHooks","row","view","wt","wtTable","getFirstVisibleRow","col","getFirstVisibleColumn","preventScrolling","selectionRange","getSelectedRange","_selectionRange$curre","current","to","selectionLayerLevel","size","colToProp","isSelectedByAnyHeader","currentSelectedRange","selectedRange","scrollToCell","isTouched","isSelectedByRowHeader","isSelectedByColumnHeader","isMultiple","scrollViewport","scrollViewportVertically","scrollViewportHorizontally","_refreshBorders","cellRanges","_cellRanges$selection","changedIsMultiple","cellCoordsDelta","coords","rowTransformDir","colTransformDir","destroyEditor","totalRows","alter","totalCols","action","index","amount","source","keepEmptyRows","delta","spliceWith","data","startIndex","count","toInject","valueFactory","result","spliceArgs","unshift","splice","apply","normalizeIndexesGroup","indexes","sortedIndexes","sort","_ref","_ref2","_ref3","indexA","_ref4","indexB","normalizedIndexes","acc","_ref5","_ref6","groupIndex","groupAmount","previousItem","_previousItem","prevIndex","prevAmount","prevLastIndex","amountToAdd","Math","max","numberOfSourceRows","countSourceRows","getSettings","maxRows","createRow","isSelected","transformEnd","createCol","len","colHeaders","spliceArray","removeRow","offset","_ref7","_ref8","calcIndex","Number","isInteger","fixedRowsTop","min","fixedRowsBottom","adjustRowsAndCols","removeCol","_ref9","_ref10","visualColumnIndex","toPhysicalColumn","_row","_len","fixedColumnsLeft","Error","minRows","rows","r","minSpareRows","emptyRows","countEmptyRows","emptyCols","minCols","minSpareCols","countEmptyCols","columns","dataType","maxCols","rowCount","colCount","deselect","range","selectionChanged","fromRow","fromCol","toRow","toCol","selectCell","wtOverlays","adjustElementsSize","populateFromArray","start","input","end","method","direction","deltas","rlen","c","clen","setData","repeatCol","repeatRow","cmax","rmax","_instance","spliceCol","_instance2","_instance3","spliceRow","_instance4","selected","skippedRow","skippedColumn","pushData","cellMeta","getInputValue","rowValue","rowInputLength","rowSelectionLength","allowInsertRow","visualRow","colInputLength","colSelectionLength","getCellMeta","skipRowOnPaste","allowInsertColumn","skipColumnOnPaste","readOnly","visualColumn","orgValue","getDataAtCell","orgValueSchema","valueSchema","setDataAtCell","setLanguage","languageCode","normalizedLanguageCode","init","updateSettings","getInstance","forceFullRender","render","ValidatorsQueue","resolved","validatorsInQueue","valid","addValidatorToQueue","removeValidatorFormQueue","checkIfQueueIsEmpty","onQueueEmpty","getParsedNumber","numericData","unifiedNumericData","replace","isNaN","parseFloat","validateChanges","changes","callback","activeEditor","beforeChangeResult","shouldBeCanceled","cancelChanges","waitingForValidator","isNumericData","test","isValid","_changes$i","newValue","cellProperties","type","getCellValidator","validateCell","cellPropertiesReference","allowInvalid","cell","getCell","visualCol","invalidCellClassName","applyChanges","skipThisChange","numberOfCreatedRows","numberOfCreatedColumns","set","lockEditor","unlockEditor","refreshValue","validator","canBeValidated","hidden","td","nodeName","wtSettings","cellRenderer","expression","cellValue","validatorCallback","_registerImmediate","setDataInputToArray","propOrCol","column","changeSource","ilen","physicalRow","toPhysicalRow","getAtCell","setDataAtRowProp","listen","modifyDocumentFocus","_instance5","invalidActiveElement","activeElement","body","blur","focus","isListening","unlisten","revertOriginal","prepareEditorIfNeeded","endRow","endCol","_datamap","_len2","elements","_key","_datamap2","_len3","_key2","getSelected","_ref11","getSelectedLast","getSelectedRangeLast","emptySelectedCells","_this2","cellRange","topLeft","getTopLeftCorner","bottomRight","getBottomRightCorner","refreshDimensions","_instance$view$getLas","getLastSize","lastWidth","width","lastHeight","height","_instance$rootElement","getBoundingClientRect","isSizeChanged","isResizeBlocked","scrollableElement","setLastSize","loadData","dataSchema","destroy","getSchema","startRows","startCols","bind","clearCellSettingCache","getData","row2","column2","getAll","getRange","DESTINATION_RENDERER","getCopyableText","startRow","startCol","getCopyableData","getCopyable","columnsAsFunc","j","cols","getSingleton","getRegistered","indexOf","initialHook","addHook","createMap","columnSetting","countSourceCols","cells","proto","setCellMetaObject","className","currentHeight","style","parseInt","initialStyle","getAttribute","setAttribute","_initialStyle","overflow","clearLengthCache","wtViewport","resetHasOversizedColumnHeadersMarked","updateMainScrollableElements","getValue","sel","expandedType","clear","selectAll","topmost","getCellAtCoords","getCoords","element","toVisualRow","toVisualColumn","get","getDataAtRowProp","getDataAtCol","_ref12","getDataAtProp","_ref13","getSourceData","getByRange","getSourceDataArray","getSourceDataAtCol","getAtColumn","getSourceDataAtRow","getAtRow","getSourceDataAtCell","getDataAtRow","getDataType","rowFrom","columnFrom","rowTo","columnTo","_this3","rowStart","columnStart","rowEnd","columnEnd","previousType","currentType","isTypeEqual","cellType","removeCellMeta","key","_recordTranslator$toP","toPhysical","_recordTranslator$toP2","physicalColumn","cachedValue","hookResult","spliceCellsMeta","deleteAmount","_priv$cellSettings","_len4","items","_key3","_this4","setCellMeta","_recordTranslator$toP3","_recordTranslator$toP4","getCellsMeta","_recordTranslator$toP5","_recordTranslator$toP6","potentialPhysicalRow","getCellMetaAtRow","isColumnModificationAllowed","rendererLookup","getCellRenderer","getCellEditor","validatorLookup","validateCells","_validateCells","validateRows","validateColumns","getRowHeader","rowHeader","rowHeaders","hasRowHeaders","hasColHeaders","getColHeader","columnIndex","out","translateVisualIndexToColumns","columnsLen","baseCol","title","_getColWidthFromSettings","colWidths","getColWidth","DEFAULT_WIDTH","_getRowHeightFromSettings","rowHeights","getRowHeight","sourceLength","getLength","dataHasLength","dataLen","columnsIsFunction","columnLen","colToPropCache","rowOffset","getFirstRenderedRow","colOffset","getFirstRenderedColumn","countRenderedRows","drawn","getRenderedRowsCount","countVisibleRows","getVisibleRowsCount","countRenderedCols","getRenderedColumnsCount","countVisibleCols","getVisibleColumnsCount","ending","visualIndex","isEmptyRow","emptyColumns","isEmptyCol","endColumn","changeListener","selectCells","wasSelected","selectColumns","startColumn","selectRows","deselectCell","scrollViewportTo","snapToBottom","snapToRight","snapToTop","snapToLeft","_clearTimeouts","_clearImmediates","licenseInfo","querySelector","parentNode","removeChild","property","postMortem","pluginName","add","hasHook","has","addHookOnce","once","removeHook","remove","p1","p2","p3","p4","p5","p6","run","dictionaryKey","extraArguments","toHTML","toTableElement","tempElement","insertAdjacentHTML","firstElementChild","timeouts","_registerTimeout","handle","delay","handleFunc","setTimeout","handler","clearTimeout","immediates","setImmediate","clearImmediate","prepareEditor"],"sources":["C:/Users/mrezy/VSCode/internships-master/node_modules/handsontable/es/core.js"],"sourcesContent":["import \"core-js/modules/es.symbol\";\nimport \"core-js/modules/es.symbol.description\";\nimport \"core-js/modules/es.symbol.iterator\";\nimport \"core-js/modules/es.array.concat\";\nimport \"core-js/modules/es.array.from\";\nimport \"core-js/modules/es.array.index-of\";\nimport \"core-js/modules/es.array.iterator\";\nimport \"core-js/modules/es.array.sort\";\nimport \"core-js/modules/es.array.splice\";\nimport \"core-js/modules/es.number.constructor\";\nimport \"core-js/modules/es.number.is-integer\";\nimport \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.regexp.exec\";\nimport \"core-js/modules/es.regexp.to-string\";\nimport \"core-js/modules/es.string.iterator\";\nimport \"core-js/modules/es.string.replace\";\nimport \"core-js/modules/web.dom-collections.iterator\";\nimport \"core-js/modules/web.immediate\";\nimport \"core-js/modules/web.timers\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nimport { addClass, empty, isChildOfWebComponentTable, removeClass } from './helpers/dom/element';\nimport { columnFactory } from './helpers/setting';\nimport { isFunction } from './helpers/function';\nimport { warn } from './helpers/console';\nimport { isDefined, isUndefined, isRegExp, _injectProductInfo, isEmpty } from './helpers/mixed';\nimport { isMobileBrowser } from './helpers/browser';\nimport DataMap from './dataMap';\nimport EditorManager from './editorManager';\nimport EventManager from './eventManager';\nimport { deepClone, duckSchema, extend, isObject, isObjectEqual, deepObjectSize, hasOwnProperty, createObjectPropListener, objectEach } from './helpers/object';\nimport { arrayFlatten, arrayMap, arrayEach, arrayReduce } from './helpers/array';\nimport { instanceToHTML } from './utils/parseTable';\nimport { getPlugin } from './plugins';\nimport { getRenderer } from './renderers';\nimport { getValidator } from './validators';\nimport { randomString } from './helpers/string';\nimport { rangeEach, rangeEachReverse } from './helpers/number';\nimport TableView from './tableView';\nimport DataSource from './dataSource';\nimport { translateRowsToColumns, cellMethodLookupFactory, spreadsheetColumnLabel } from './helpers/data';\nimport { getTranslator } from './utils/recordTranslator';\nimport { registerAsRootInstance, hasValidParameter, isRootInstance } from './utils/rootInstance';\nimport { CellCoords, ViewportColumnsCalculator } from './3rdparty/walkontable/src';\nimport Hooks from './pluginHooks';\nimport DefaultSettings from './defaultSettings';\nimport { getCellType } from './cellTypes';\nimport { getTranslatedPhrase } from './i18n';\nimport { hasLanguageDictionary } from './i18n/dictionariesManager';\nimport { warnUserAboutLanguageRegistration, applyLanguageSetting, normalizeLanguageCode } from './i18n/utils';\nimport { startObserving as keyStateStartObserving, stopObserving as keyStateStopObserving } from './utils/keyStateObserver';\nimport { Selection } from './selection';\nvar activeGuid = null;\n/**\n * Handsontable constructor\n *\n * @core\n * @constructor Core\n * @description\n *\n * After Handsontable is constructed, you can modify the grid behavior using the available public methods.\n *\n * ---\n * ## How to call methods\n *\n * These are 2 equal ways to call a Handsontable method:\n *\n * ```js\n * // all following examples assume that you constructed Handsontable like this\n * const hot = new Handsontable(document.getElementById('example1'), options);\n *\n * // now, to use setDataAtCell method, you can either:\n * ht.setDataAtCell(0, 0, 'new value');\n * ```\n *\n * Alternatively, you can call the method using jQuery wrapper (__obsolete__, requires initialization using our jQuery guide\n * ```js\n *   $('#example1').handsontable('setDataAtCell', 0, 0, 'new value');\n * ```\n * ---\n */\n\nexport default function Core(rootElement, userSettings) {\n  var _this = this;\n\n  var rootInstanceSymbol = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var preventScrollingToCell = false;\n  var instance = this;\n\n  var GridSettings = function GridSettings() {};\n\n  var eventManager = new EventManager(instance);\n  var priv;\n  var datamap;\n  var dataSource;\n  var grid;\n  var editorManager;\n  extend(GridSettings.prototype, DefaultSettings.prototype); // create grid settings as a copy of default settings\n\n  extend(GridSettings.prototype, userSettings); // overwrite defaults with user settings\n\n  extend(GridSettings.prototype, expandType(userSettings));\n  applyLanguageSetting(GridSettings.prototype, userSettings.language);\n\n  if (hasValidParameter(rootInstanceSymbol)) {\n    registerAsRootInstance(this);\n  } // TODO: check if references to DOM elements should be move to UI layer (Walkontable)\n\n  /**\n   * Reference to the container element.\n   *\n   * @private\n   * @type {HTMLElement}\n   */\n\n\n  this.rootElement = rootElement;\n  /**\n   * The nearest document over container.\n   *\n   * @private\n   * @type {Document}\n   */\n\n  this.rootDocument = rootElement.ownerDocument;\n  /**\n   * Window object over container's document.\n   *\n   * @private\n   * @type {Window}\n   */\n\n  this.rootWindow = this.rootDocument.defaultView;\n  keyStateStartObserving(this.rootDocument);\n  this.isDestroyed = false;\n  this.isHotTableEnv = isChildOfWebComponentTable(this.rootElement);\n  EventManager.isHotTableEnv = this.isHotTableEnv;\n  this.container = this.rootDocument.createElement('div');\n  this.renderCall = false;\n  rootElement.insertBefore(this.container, rootElement.firstChild);\n\n  if (isRootInstance(this)) {\n    _injectProductInfo(userSettings.licenseKey, rootElement);\n  }\n\n  this.guid = \"ht_\".concat(randomString()); // this is the namespace for global events\n\n  var recordTranslator = getTranslator(instance);\n  dataSource = new DataSource(instance);\n\n  if (!this.rootElement.id || this.rootElement.id.substring(0, 3) === 'ht_') {\n    this.rootElement.id = this.guid; // if root element does not have an id, assign a random id\n  }\n\n  priv = {\n    cellSettings: [],\n    columnSettings: [],\n    columnsSettingConflicts: ['data', 'width', 'language'],\n    settings: new GridSettings(),\n    // current settings instance\n    selRange: null,\n    // exposed by public method `getSelectedRange`\n    isPopulated: null,\n    scrollable: null,\n    firstRun: true\n  };\n  var selection = new Selection(priv.settings, {\n    countCols: function countCols() {\n      return instance.countCols();\n    },\n    countRows: function countRows() {\n      return instance.countRows();\n    },\n    propToCol: function propToCol(prop) {\n      return datamap.propToCol(prop);\n    },\n    isEditorOpened: function isEditorOpened() {\n      return instance.getActiveEditor() ? instance.getActiveEditor().isOpened() : false;\n    }\n  });\n  this.selection = selection;\n  this.selection.addLocalHook('beforeSetRangeStart', function (cellCoords) {\n    _this.runHooks('beforeSetRangeStart', cellCoords);\n  });\n  this.selection.addLocalHook('beforeSetRangeStartOnly', function (cellCoords) {\n    _this.runHooks('beforeSetRangeStartOnly', cellCoords);\n  });\n  this.selection.addLocalHook('beforeSetRangeEnd', function (cellCoords) {\n    _this.runHooks('beforeSetRangeEnd', cellCoords);\n\n    if (cellCoords.row < 0) {\n      cellCoords.row = _this.view.wt.wtTable.getFirstVisibleRow();\n    }\n\n    if (cellCoords.col < 0) {\n      cellCoords.col = _this.view.wt.wtTable.getFirstVisibleColumn();\n    }\n  });\n  this.selection.addLocalHook('afterSetRangeEnd', function (cellCoords) {\n    var preventScrolling = createObjectPropListener(false);\n\n    var selectionRange = _this.selection.getSelectedRange();\n\n    var _selectionRange$curre = selectionRange.current(),\n        from = _selectionRange$curre.from,\n        to = _selectionRange$curre.to;\n\n    var selectionLayerLevel = selectionRange.size() - 1;\n\n    _this.runHooks('afterSelection', from.row, from.col, to.row, to.col, preventScrolling, selectionLayerLevel);\n\n    _this.runHooks('afterSelectionByProp', from.row, instance.colToProp(from.col), to.row, instance.colToProp(to.col), preventScrolling, selectionLayerLevel);\n\n    var isSelectedByAnyHeader = _this.selection.isSelectedByAnyHeader();\n\n    var currentSelectedRange = _this.selection.selectedRange.current();\n\n    var scrollToCell = true;\n\n    if (preventScrollingToCell) {\n      scrollToCell = false;\n    }\n\n    if (preventScrolling.isTouched()) {\n      scrollToCell = !preventScrolling.value;\n    }\n\n    var isSelectedByRowHeader = _this.selection.isSelectedByRowHeader();\n\n    var isSelectedByColumnHeader = _this.selection.isSelectedByColumnHeader();\n\n    if (scrollToCell !== false) {\n      if (!isSelectedByAnyHeader) {\n        if (currentSelectedRange && !_this.selection.isMultiple()) {\n          _this.view.scrollViewport(currentSelectedRange.from);\n        } else {\n          _this.view.scrollViewport(cellCoords);\n        }\n      } else if (isSelectedByRowHeader) {\n        _this.view.scrollViewportVertically(cellCoords.row);\n      } else if (isSelectedByColumnHeader) {\n        _this.view.scrollViewportHorizontally(cellCoords.col);\n      }\n    } // @TODO: These CSS classes are no longer needed anymore. They are used only as a indicator of the selected\n    // rows/columns in the MergedCells plugin (via border.js#L520 in the walkontable module). After fixing\n    // the Border class this should be removed.\n\n\n    if (isSelectedByRowHeader && isSelectedByColumnHeader) {\n      addClass(_this.rootElement, ['ht__selection--rows', 'ht__selection--columns']);\n    } else if (isSelectedByRowHeader) {\n      removeClass(_this.rootElement, 'ht__selection--columns');\n      addClass(_this.rootElement, 'ht__selection--rows');\n    } else if (isSelectedByColumnHeader) {\n      removeClass(_this.rootElement, 'ht__selection--rows');\n      addClass(_this.rootElement, 'ht__selection--columns');\n    } else {\n      removeClass(_this.rootElement, ['ht__selection--rows', 'ht__selection--columns']);\n    }\n\n    _this._refreshBorders(null);\n  });\n  this.selection.addLocalHook('afterSelectionFinished', function (cellRanges) {\n    var selectionLayerLevel = cellRanges.length - 1;\n    var _cellRanges$selection = cellRanges[selectionLayerLevel],\n        from = _cellRanges$selection.from,\n        to = _cellRanges$selection.to;\n\n    _this.runHooks('afterSelectionEnd', from.row, from.col, to.row, to.col, selectionLayerLevel);\n\n    _this.runHooks('afterSelectionEndByProp', from.row, instance.colToProp(from.col), to.row, instance.colToProp(to.col), selectionLayerLevel);\n  });\n  this.selection.addLocalHook('afterIsMultipleSelection', function (isMultiple) {\n    var changedIsMultiple = _this.runHooks('afterIsMultipleSelection', isMultiple.value);\n\n    if (isMultiple.value) {\n      isMultiple.value = changedIsMultiple;\n    }\n  });\n  this.selection.addLocalHook('beforeModifyTransformStart', function (cellCoordsDelta) {\n    _this.runHooks('modifyTransformStart', cellCoordsDelta);\n  });\n  this.selection.addLocalHook('afterModifyTransformStart', function (coords, rowTransformDir, colTransformDir) {\n    _this.runHooks('afterModifyTransformStart', coords, rowTransformDir, colTransformDir);\n  });\n  this.selection.addLocalHook('beforeModifyTransformEnd', function (cellCoordsDelta) {\n    _this.runHooks('modifyTransformEnd', cellCoordsDelta);\n  });\n  this.selection.addLocalHook('afterModifyTransformEnd', function (coords, rowTransformDir, colTransformDir) {\n    _this.runHooks('afterModifyTransformEnd', coords, rowTransformDir, colTransformDir);\n  });\n  this.selection.addLocalHook('afterDeselect', function () {\n    editorManager.destroyEditor();\n\n    _this._refreshBorders();\n\n    removeClass(_this.rootElement, ['ht__selection--rows', 'ht__selection--columns']);\n\n    _this.runHooks('afterDeselect');\n  });\n  this.selection.addLocalHook('insertRowRequire', function (totalRows) {\n    _this.alter('insert_row', totalRows, 1, 'auto');\n  });\n  this.selection.addLocalHook('insertColRequire', function (totalCols) {\n    _this.alter('insert_col', totalCols, 1, 'auto');\n  });\n  grid = {\n    /**\n     * Inserts or removes rows and columns.\n     *\n     * @memberof Core#\n     * @function alter\n     * @private\n     * @param {String} action Possible values: \"insert_row\", \"insert_col\", \"remove_row\", \"remove_col\".\n     * @param {Number|Array} index Row or column visual index which from the alter action will be triggered.\n     *                             Alter actions such as \"remove_row\" and \"remove_col\" support array indexes in the\n     *                             format `[[index, amount], [index, amount]...]` this can be used to remove\n     *                             non-consecutive columns or rows in one call.\n     * @param {Number} [amount=1] Ammount rows or columns to remove.\n     * @param {String} [source] Optional. Source of hook runner.\n     * @param {Boolean} [keepEmptyRows] Optional. Flag for preventing deletion of empty rows.\n     */\n    alter: function alter(action, index) {\n      var amount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      var source = arguments.length > 3 ? arguments[3] : undefined;\n      var keepEmptyRows = arguments.length > 4 ? arguments[4] : undefined;\n      var delta;\n\n      function spliceWith(data, startIndex, count, toInject) {\n        var valueFactory = function valueFactory() {\n          var result;\n\n          if (toInject === 'array') {\n            result = [];\n          } else if (toInject === 'object') {\n            result = {};\n          }\n\n          return result;\n        };\n\n        var spliceArgs = arrayMap(new Array(count), function () {\n          return valueFactory();\n        });\n        spliceArgs.unshift(startIndex, 0);\n        data.splice.apply(data, _toConsumableArray(spliceArgs));\n      }\n\n      var normalizeIndexesGroup = function normalizeIndexesGroup(indexes) {\n        if (indexes.length === 0) {\n          return [];\n        }\n\n        var sortedIndexes = _toConsumableArray(indexes); // Sort the indexes in ascending order.\n\n\n        sortedIndexes.sort(function (_ref, _ref2) {\n          var _ref3 = _slicedToArray(_ref, 1),\n              indexA = _ref3[0];\n\n          var _ref4 = _slicedToArray(_ref2, 1),\n              indexB = _ref4[0];\n\n          if (indexA === indexB) {\n            return 0;\n          }\n\n          return indexA > indexB ? 1 : -1;\n        }); // Normalize the {index, amount} groups into bigger groups.\n\n        var normalizedIndexes = arrayReduce(sortedIndexes, function (acc, _ref5) {\n          var _ref6 = _slicedToArray(_ref5, 2),\n              groupIndex = _ref6[0],\n              groupAmount = _ref6[1];\n\n          var previousItem = acc[acc.length - 1];\n\n          var _previousItem = _slicedToArray(previousItem, 2),\n              prevIndex = _previousItem[0],\n              prevAmount = _previousItem[1];\n\n          var prevLastIndex = prevIndex + prevAmount;\n\n          if (groupIndex <= prevLastIndex) {\n            var amountToAdd = Math.max(groupAmount - (prevLastIndex - groupIndex), 0);\n            previousItem[1] += amountToAdd;\n          } else {\n            acc.push([groupIndex, groupAmount]);\n          }\n\n          return acc;\n        }, [sortedIndexes[0]]);\n        return normalizedIndexes;\n      };\n      /* eslint-disable no-case-declarations */\n\n\n      switch (action) {\n        case 'insert_row':\n          var numberOfSourceRows = instance.countSourceRows();\n\n          if (instance.getSettings().maxRows === numberOfSourceRows) {\n            return;\n          } // eslint-disable-next-line no-param-reassign\n\n\n          index = isDefined(index) ? index : numberOfSourceRows;\n          delta = datamap.createRow(index, amount, source);\n          spliceWith(priv.cellSettings, index, amount, 'array');\n\n          if (delta) {\n            if (selection.isSelected() && selection.selectedRange.current().from.row >= index) {\n              selection.selectedRange.current().from.row += delta;\n              selection.transformEnd(delta, 0); // will call render() internally\n            } else {\n              instance._refreshBorders(); // it will call render and prepare methods\n\n            }\n          }\n\n          break;\n\n        case 'insert_col':\n          delta = datamap.createCol(index, amount, source);\n\n          for (var row = 0, len = instance.countSourceRows(); row < len; row++) {\n            if (priv.cellSettings[row]) {\n              spliceWith(priv.cellSettings[row], index, amount);\n            }\n          }\n\n          if (delta) {\n            if (Array.isArray(instance.getSettings().colHeaders)) {\n              var spliceArray = [index, 0];\n              spliceArray.length += delta; // inserts empty (undefined) elements at the end of an array\n\n              Array.prototype.splice.apply(instance.getSettings().colHeaders, spliceArray); // inserts empty (undefined) elements into the colHeader array\n            }\n\n            if (selection.isSelected() && selection.selectedRange.current().from.col >= index) {\n              selection.selectedRange.current().from.col += delta;\n              selection.transformEnd(0, delta); // will call render() internally\n            } else {\n              instance._refreshBorders(); // it will call render and prepare methods\n\n            }\n          }\n\n          break;\n\n        case 'remove_row':\n          var removeRow = function removeRow(indexes) {\n            var offset = 0; // Normalize the {index, amount} groups into bigger groups.\n\n            arrayEach(indexes, function (_ref7) {\n              var _ref8 = _slicedToArray(_ref7, 2),\n                  groupIndex = _ref8[0],\n                  groupAmount = _ref8[1];\n\n              var calcIndex = isEmpty(groupIndex) ? instance.countRows() - 1 : Math.max(groupIndex - offset, 0); // If the 'index' is an integer decrease it by 'offset' otherwise pass it through to make the value\n              // compatible with datamap.removeCol method.\n\n              if (Number.isInteger(groupIndex)) {\n                // eslint-disable-next-line no-param-reassign\n                groupIndex = Math.max(groupIndex - offset, 0);\n              } // TODO: for datamap.removeRow index should be passed as it is (with undefined and null values). If not, the logic\n              // inside the datamap.removeRow breaks the removing functionality.\n\n\n              datamap.removeRow(groupIndex, groupAmount, source);\n              priv.cellSettings.splice(calcIndex, amount);\n              var totalRows = instance.countRows();\n              var fixedRowsTop = instance.getSettings().fixedRowsTop;\n\n              if (fixedRowsTop >= calcIndex + 1) {\n                instance.getSettings().fixedRowsTop -= Math.min(groupAmount, fixedRowsTop - calcIndex);\n              }\n\n              var fixedRowsBottom = instance.getSettings().fixedRowsBottom;\n\n              if (fixedRowsBottom && calcIndex >= totalRows - fixedRowsBottom) {\n                instance.getSettings().fixedRowsBottom -= Math.min(groupAmount, fixedRowsBottom);\n              }\n\n              offset += groupAmount;\n            });\n          };\n\n          if (Array.isArray(index)) {\n            removeRow(normalizeIndexesGroup(index));\n          } else {\n            removeRow([[index, amount]]);\n          }\n\n          grid.adjustRowsAndCols();\n\n          instance._refreshBorders(); // it will call render and prepare methods\n\n\n          break;\n\n        case 'remove_col':\n          var removeCol = function removeCol(indexes) {\n            var offset = 0; // Normalize the {index, amount} groups into bigger groups.\n\n            arrayEach(indexes, function (_ref9) {\n              var _ref10 = _slicedToArray(_ref9, 2),\n                  groupIndex = _ref10[0],\n                  groupAmount = _ref10[1];\n\n              var calcIndex = isEmpty(groupIndex) ? instance.countCols() - 1 : Math.max(groupIndex - offset, 0);\n              var visualColumnIndex = recordTranslator.toPhysicalColumn(calcIndex); // If the 'index' is an integer decrease it by 'offset' otherwise pass it through to make the value\n              // compatible with datamap.removeCol method.\n\n              if (Number.isInteger(groupIndex)) {\n                // eslint-disable-next-line no-param-reassign\n                groupIndex = Math.max(groupIndex - offset, 0);\n              } // TODO: for datamap.removeCol index should be passed as it is (with undefined and null values). If not, the logic\n              // inside the datamap.removeCol breaks the removing functionality.\n\n\n              datamap.removeCol(groupIndex, groupAmount, source);\n\n              for (var _row = 0, _len = instance.countSourceRows(); _row < _len; _row++) {\n                if (priv.cellSettings[_row]) {\n                  // if row hasn't been rendered it wouldn't have cellSettings\n                  priv.cellSettings[_row].splice(visualColumnIndex, groupAmount);\n                }\n              }\n\n              var fixedColumnsLeft = instance.getSettings().fixedColumnsLeft;\n\n              if (fixedColumnsLeft >= calcIndex + 1) {\n                instance.getSettings().fixedColumnsLeft -= Math.min(groupAmount, fixedColumnsLeft - calcIndex);\n              }\n\n              if (Array.isArray(instance.getSettings().colHeaders)) {\n                if (typeof visualColumnIndex === 'undefined') {\n                  visualColumnIndex = -1;\n                }\n\n                instance.getSettings().colHeaders.splice(visualColumnIndex, groupAmount);\n              }\n\n              offset += groupAmount;\n            });\n          };\n\n          if (Array.isArray(index)) {\n            removeCol(normalizeIndexesGroup(index));\n          } else {\n            removeCol([[index, amount]]);\n          }\n\n          grid.adjustRowsAndCols();\n\n          instance._refreshBorders(); // it will call render and prepare methods\n\n\n          break;\n\n        default:\n          throw new Error(\"There is no such action \\\"\".concat(action, \"\\\"\"));\n      }\n\n      if (!keepEmptyRows) {\n        grid.adjustRowsAndCols(); // makes sure that we did not add rows that will be removed in next refresh\n      }\n    },\n\n    /**\n     * Makes sure there are empty rows at the bottom of the table\n     */\n    adjustRowsAndCols: function adjustRowsAndCols() {\n      if (priv.settings.minRows) {\n        // should I add empty rows to data source to meet minRows?\n        var rows = instance.countRows();\n\n        if (rows < priv.settings.minRows) {\n          for (var r = 0, minRows = priv.settings.minRows; r < minRows - rows; r++) {\n            datamap.createRow(instance.countRows(), 1, 'auto');\n          }\n        }\n      }\n\n      if (priv.settings.minSpareRows) {\n        var emptyRows = instance.countEmptyRows(true); // should I add empty rows to meet minSpareRows?\n\n        if (emptyRows < priv.settings.minSpareRows) {\n          for (; emptyRows < priv.settings.minSpareRows && instance.countSourceRows() < priv.settings.maxRows; emptyRows++) {\n            datamap.createRow(instance.countRows(), 1, 'auto');\n          }\n        }\n      }\n\n      {\n        var emptyCols; // count currently empty cols\n\n        if (priv.settings.minCols || priv.settings.minSpareCols) {\n          emptyCols = instance.countEmptyCols(true);\n        } // should I add empty cols to meet minCols?\n\n\n        if (priv.settings.minCols && !priv.settings.columns && instance.countCols() < priv.settings.minCols) {\n          for (; instance.countCols() < priv.settings.minCols; emptyCols++) {\n            datamap.createCol(instance.countCols(), 1, 'auto');\n          }\n        } // should I add empty cols to meet minSpareCols?\n\n\n        if (priv.settings.minSpareCols && !priv.settings.columns && instance.dataType === 'array' && emptyCols < priv.settings.minSpareCols) {\n          for (; emptyCols < priv.settings.minSpareCols && instance.countCols() < priv.settings.maxCols; emptyCols++) {\n            datamap.createCol(instance.countCols(), 1, 'auto');\n          }\n        }\n      }\n      var rowCount = instance.countRows();\n      var colCount = instance.countCols();\n\n      if (rowCount === 0 || colCount === 0) {\n        selection.deselect();\n      }\n\n      if (selection.isSelected()) {\n        arrayEach(selection.selectedRange, function (range) {\n          var selectionChanged = false;\n          var fromRow = range.from.row;\n          var fromCol = range.from.col;\n          var toRow = range.to.row;\n          var toCol = range.to.col; // if selection is outside, move selection to last row\n\n          if (fromRow > rowCount - 1) {\n            fromRow = rowCount - 1;\n            selectionChanged = true;\n\n            if (toRow > fromRow) {\n              toRow = fromRow;\n            }\n          } else if (toRow > rowCount - 1) {\n            toRow = rowCount - 1;\n            selectionChanged = true;\n\n            if (fromRow > toRow) {\n              fromRow = toRow;\n            }\n          } // if selection is outside, move selection to last row\n\n\n          if (fromCol > colCount - 1) {\n            fromCol = colCount - 1;\n            selectionChanged = true;\n\n            if (toCol > fromCol) {\n              toCol = fromCol;\n            }\n          } else if (toCol > colCount - 1) {\n            toCol = colCount - 1;\n            selectionChanged = true;\n\n            if (fromCol > toCol) {\n              fromCol = toCol;\n            }\n          }\n\n          if (selectionChanged) {\n            instance.selectCell(fromRow, fromCol, toRow, toCol);\n          }\n        });\n      }\n\n      if (instance.view) {\n        instance.view.wt.wtOverlays.adjustElementsSize();\n      }\n    },\n\n    /**\n     * Populate the data from the provided 2d array from the given cell coordinates.\n     *\n     * @private\n     * @param {Object} start Start selection position. Visual indexes.\n     * @param {Array} input 2d data array.\n     * @param {Object} [end] End selection position (only for drag-down mode). Visual indexes.\n     * @param {String} [source=\"populateFromArray\"] Source information string.\n     * @param {String} [method=\"overwrite\"] Populate method. Possible options: `shift_down`, `shift_right`, `overwrite`.\n     * @param {String} direction (left|right|up|down) String specifying the direction.\n     * @param {Array} deltas The deltas array. A difference between values of adjacent cells.\n     *                       Useful **only** when the type of handled cells is `numeric`.\n     * @returns {Object|undefined} ending td in pasted area (only if any cell was changed).\n     */\n    populateFromArray: function populateFromArray(start, input, end, source, method, direction, deltas) {\n      // TODO: either remove or implement the `direction` argument. Currently it's not working at all.\n      var r;\n      var rlen;\n      var c;\n      var clen;\n      var setData = [];\n      var current = {};\n      rlen = input.length;\n\n      if (rlen === 0) {\n        return false;\n      }\n\n      var repeatCol;\n      var repeatRow;\n      var cmax;\n      var rmax;\n      /* eslint-disable no-case-declarations */\n      // insert data with specified pasteMode method\n\n      switch (method) {\n        case 'shift_down':\n          repeatCol = end ? end.col - start.col + 1 : 0;\n          repeatRow = end ? end.row - start.row + 1 : 0; // eslint-disable-next-line no-param-reassign\n\n          input = translateRowsToColumns(input);\n\n          for (c = 0, clen = input.length, cmax = Math.max(clen, repeatCol); c < cmax; c++) {\n            if (c < clen) {\n              var _instance;\n\n              for (r = 0, rlen = input[c].length; r < repeatRow - rlen; r++) {\n                input[c].push(input[c][r % rlen]);\n              }\n\n              input[c].unshift(start.col + c, start.row, 0);\n\n              (_instance = instance).spliceCol.apply(_instance, _toConsumableArray(input[c]));\n            } else {\n              var _instance2;\n\n              input[c % clen][0] = start.col + c;\n\n              (_instance2 = instance).spliceCol.apply(_instance2, _toConsumableArray(input[c % clen]));\n            }\n          }\n\n          break;\n\n        case 'shift_right':\n          repeatCol = end ? end.col - start.col + 1 : 0;\n          repeatRow = end ? end.row - start.row + 1 : 0;\n\n          for (r = 0, rlen = input.length, rmax = Math.max(rlen, repeatRow); r < rmax; r++) {\n            if (r < rlen) {\n              var _instance3;\n\n              for (c = 0, clen = input[r].length; c < repeatCol - clen; c++) {\n                input[r].push(input[r][c % clen]);\n              }\n\n              input[r].unshift(start.row + r, start.col, 0);\n\n              (_instance3 = instance).spliceRow.apply(_instance3, _toConsumableArray(input[r]));\n            } else {\n              var _instance4;\n\n              input[r % rlen][0] = start.row + r;\n\n              (_instance4 = instance).spliceRow.apply(_instance4, _toConsumableArray(input[r % rlen]));\n            }\n          }\n\n          break;\n\n        case 'overwrite':\n        default:\n          // overwrite and other not specified options\n          current.row = start.row;\n          current.col = start.col;\n          var selected = {\n            // selected range\n            row: end && start ? end.row - start.row + 1 : 1,\n            col: end && start ? end.col - start.col + 1 : 1\n          };\n          var skippedRow = 0;\n          var skippedColumn = 0;\n          var pushData = true;\n          var cellMeta;\n\n          var getInputValue = function getInputValue(row) {\n            var col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n            var rowValue = input[row % input.length];\n\n            if (col !== null) {\n              return rowValue[col % rowValue.length];\n            }\n\n            return rowValue;\n          };\n\n          var rowInputLength = input.length;\n          var rowSelectionLength = end ? end.row - start.row + 1 : 0;\n\n          if (end) {\n            rlen = rowSelectionLength;\n          } else {\n            rlen = Math.max(rowInputLength, rowSelectionLength);\n          }\n\n          for (r = 0; r < rlen; r++) {\n            if (end && current.row > end.row && rowSelectionLength > rowInputLength || !priv.settings.allowInsertRow && current.row > instance.countRows() - 1 || current.row >= priv.settings.maxRows) {\n              break;\n            }\n\n            var visualRow = r - skippedRow;\n            var colInputLength = getInputValue(visualRow).length;\n            var colSelectionLength = end ? end.col - start.col + 1 : 0;\n\n            if (end) {\n              clen = colSelectionLength;\n            } else {\n              clen = Math.max(colInputLength, colSelectionLength);\n            }\n\n            current.col = start.col;\n            cellMeta = instance.getCellMeta(current.row, current.col);\n\n            if ((source === 'CopyPaste.paste' || source === 'Autofill.fill') && cellMeta.skipRowOnPaste) {\n              skippedRow += 1;\n              current.row += 1;\n              rlen += 1;\n              /* eslint-disable no-continue */\n\n              continue;\n            }\n\n            skippedColumn = 0;\n\n            for (c = 0; c < clen; c++) {\n              if (end && current.col > end.col && colSelectionLength > colInputLength || !priv.settings.allowInsertColumn && current.col > instance.countCols() - 1 || current.col >= priv.settings.maxCols) {\n                break;\n              }\n\n              cellMeta = instance.getCellMeta(current.row, current.col);\n\n              if ((source === 'CopyPaste.paste' || source === 'Autofill.fill') && cellMeta.skipColumnOnPaste) {\n                skippedColumn += 1;\n                current.col += 1;\n                clen += 1;\n                continue;\n              }\n\n              if (cellMeta.readOnly) {\n                current.col += 1;\n                /* eslint-disable no-continue */\n\n                continue;\n              }\n\n              var visualColumn = c - skippedColumn;\n              var value = getInputValue(visualRow, visualColumn);\n              var orgValue = instance.getDataAtCell(current.row, current.col);\n              var index = {\n                row: visualRow,\n                col: visualColumn\n              };\n\n              if (source === 'Autofill.fill') {\n                var result = instance.runHooks('beforeAutofillInsidePopulate', index, direction, input, deltas, {}, selected);\n\n                if (result) {\n                  value = isUndefined(result.value) ? value : result.value;\n                }\n              }\n\n              if (value !== null && _typeof(value) === 'object') {\n                // when 'value' is array and 'orgValue' is null, set 'orgValue' to\n                // an empty array so that the null value can be compared to 'value'\n                // as an empty value for the array context\n                if (Array.isArray(value) && orgValue === null) orgValue = [];\n\n                if (orgValue === null || _typeof(orgValue) !== 'object') {\n                  pushData = false;\n                } else {\n                  var orgValueSchema = duckSchema(Array.isArray(orgValue) ? orgValue : orgValue[0] || orgValue);\n                  var valueSchema = duckSchema(Array.isArray(value) ? value : value[0] || value);\n                  /* eslint-disable max-depth */\n\n                  if (isObjectEqual(orgValueSchema, valueSchema)) {\n                    value = deepClone(value);\n                  } else {\n                    pushData = false;\n                  }\n                }\n              } else if (orgValue !== null && _typeof(orgValue) === 'object') {\n                pushData = false;\n              }\n\n              if (pushData) {\n                setData.push([current.row, current.col, value]);\n              }\n\n              pushData = true;\n              current.col += 1;\n            }\n\n            current.row += 1;\n          }\n\n          instance.setDataAtCell(setData, null, null, source || 'populateFromArray');\n          break;\n      }\n    }\n  };\n  /**\n   * Internal function to set `language` key of settings.\n   *\n   * @private\n   * @param {String} languageCode Language code for specific language i.e. 'en-US', 'pt-BR', 'de-DE'\n   * @fires Hooks#afterLanguageChange\n   */\n\n  function setLanguage(languageCode) {\n    var normalizedLanguageCode = normalizeLanguageCode(languageCode);\n\n    if (hasLanguageDictionary(normalizedLanguageCode)) {\n      instance.runHooks('beforeLanguageChange', normalizedLanguageCode);\n      GridSettings.prototype.language = normalizedLanguageCode;\n      instance.runHooks('afterLanguageChange', normalizedLanguageCode);\n    } else {\n      warnUserAboutLanguageRegistration(languageCode);\n    }\n  }\n\n  this.init = function () {\n    dataSource.setData(priv.settings.data);\n    instance.runHooks('beforeInit');\n\n    if (isMobileBrowser()) {\n      addClass(instance.rootElement, 'mobile');\n    }\n\n    this.updateSettings(priv.settings, true);\n    this.view = new TableView(this);\n    editorManager = EditorManager.getInstance(instance, priv, selection, datamap);\n    this.forceFullRender = true; // used when data was changed\n\n    instance.runHooks('init');\n    this.view.render();\n\n    if (_typeof(priv.firstRun) === 'object') {\n      instance.runHooks('afterChange', priv.firstRun[0], priv.firstRun[1]);\n      priv.firstRun = false;\n    }\n\n    instance.runHooks('afterInit');\n  };\n\n  function ValidatorsQueue() {\n    // moved this one level up so it can be used in any function here. Probably this should be moved to a separate file\n    var resolved = false;\n    return {\n      validatorsInQueue: 0,\n      valid: true,\n      addValidatorToQueue: function addValidatorToQueue() {\n        this.validatorsInQueue += 1;\n        resolved = false;\n      },\n      removeValidatorFormQueue: function removeValidatorFormQueue() {\n        this.validatorsInQueue = this.validatorsInQueue - 1 < 0 ? 0 : this.validatorsInQueue - 1;\n        this.checkIfQueueIsEmpty();\n      },\n      onQueueEmpty: function onQueueEmpty() {},\n      checkIfQueueIsEmpty: function checkIfQueueIsEmpty() {\n        if (this.validatorsInQueue === 0 && resolved === false) {\n          resolved = true;\n          this.onQueueEmpty(this.valid);\n        }\n      }\n    };\n  }\n  /**\n   * Get parsed number from numeric string.\n   *\n   * @private\n   * @param {String} numericData Float (separated by a dot or a comma) or integer.\n   * @returns {Number} Number if we get data in parsable format, not changed value otherwise.\n   */\n\n\n  function getParsedNumber(numericData) {\n    // Unifying \"float like\" string. Change from value with comma determiner to value with dot determiner,\n    // for example from `450,65` to `450.65`.\n    var unifiedNumericData = numericData.replace(',', '.');\n\n    if (isNaN(parseFloat(unifiedNumericData)) === false) {\n      return parseFloat(unifiedNumericData);\n    }\n\n    return numericData;\n  }\n\n  function validateChanges(changes, source, callback) {\n    if (!changes.length) {\n      return;\n    }\n\n    var activeEditor = instance.getActiveEditor();\n    var beforeChangeResult = instance.runHooks('beforeChange', changes, source || 'edit');\n    var shouldBeCanceled = true;\n\n    if (isFunction(beforeChangeResult)) {\n      warn('Your beforeChange callback returns a function. It\\'s not supported since Handsontable 0.12.1 (and the returned function will not be executed).');\n    } else if (beforeChangeResult === false) {\n      if (activeEditor) {\n        activeEditor.cancelChanges();\n      }\n\n      return;\n    }\n\n    var waitingForValidator = new ValidatorsQueue();\n\n    var isNumericData = function isNumericData(value) {\n      return value.length > 0 && /^\\s*[+-.]?\\s*(?:(?:\\d+(?:(\\.|,)\\d+)?(?:e[+-]?\\d+)?)|(?:0x[a-f\\d]+))\\s*$/.test(value);\n    };\n\n    waitingForValidator.onQueueEmpty = function (isValid) {\n      if (activeEditor && shouldBeCanceled) {\n        activeEditor.cancelChanges();\n      }\n\n      callback(isValid); // called when async validators are resolved and beforeChange was not async\n    };\n\n    for (var i = changes.length - 1; i >= 0; i--) {\n      if (changes[i] === null) {\n        changes.splice(i, 1);\n      } else {\n        var _changes$i = _slicedToArray(changes[i], 4),\n            row = _changes$i[0],\n            prop = _changes$i[1],\n            newValue = _changes$i[3];\n\n        var col = datamap.propToCol(prop);\n        var cellProperties = instance.getCellMeta(row, col);\n\n        if (cellProperties.type === 'numeric' && typeof newValue === 'string' && isNumericData(newValue)) {\n          changes[i][3] = getParsedNumber(newValue);\n        }\n        /* eslint-disable no-loop-func */\n\n\n        if (instance.getCellValidator(cellProperties)) {\n          waitingForValidator.addValidatorToQueue();\n          instance.validateCell(changes[i][3], cellProperties, function (index, cellPropertiesReference) {\n            return function (result) {\n              if (typeof result !== 'boolean') {\n                throw new Error('Validation error: result is not boolean');\n              }\n\n              if (result === false && cellPropertiesReference.allowInvalid === false) {\n                shouldBeCanceled = false;\n                changes.splice(index, 1); // cancel the change\n\n                cellPropertiesReference.valid = true; // we cancelled the change, so cell value is still valid\n\n                var cell = instance.getCell(cellPropertiesReference.visualRow, cellPropertiesReference.visualCol);\n\n                if (cell !== null) {\n                  removeClass(cell, instance.getSettings().invalidCellClassName);\n                } // index -= 1;\n\n              }\n\n              waitingForValidator.removeValidatorFormQueue();\n            };\n          }(i, cellProperties), source);\n        }\n      }\n    }\n\n    waitingForValidator.checkIfQueueIsEmpty();\n  }\n  /**\n   * Internal function to apply changes. Called after validateChanges\n   *\n   * @private\n   * @param {Array} changes Array in form of [row, prop, oldValue, newValue]\n   * @param {String} source String that identifies how this change will be described in changes array (useful in onChange callback)\n   * @fires Hooks#beforeChangeRender\n   * @fires Hooks#afterChange\n   */\n\n\n  function applyChanges(changes, source) {\n    var i = changes.length - 1;\n\n    if (i < 0) {\n      return;\n    }\n\n    for (; i >= 0; i--) {\n      var skipThisChange = false;\n\n      if (changes[i] === null) {\n        changes.splice(i, 1);\n        /* eslint-disable no-continue */\n\n        continue;\n      }\n\n      if ((changes[i][2] === null || changes[i][2] === void 0) && (changes[i][3] === null || changes[i][3] === void 0)) {\n        /* eslint-disable no-continue */\n        continue;\n      }\n\n      if (priv.settings.allowInsertRow) {\n        while (changes[i][0] > instance.countRows() - 1) {\n          var numberOfCreatedRows = datamap.createRow(void 0, void 0, source);\n\n          if (numberOfCreatedRows === 0) {\n            skipThisChange = true;\n            break;\n          }\n        }\n      }\n\n      if (instance.dataType === 'array' && (!priv.settings.columns || priv.settings.columns.length === 0) && priv.settings.allowInsertColumn) {\n        while (datamap.propToCol(changes[i][1]) > instance.countCols() - 1) {\n          var numberOfCreatedColumns = datamap.createCol(void 0, void 0, source);\n\n          if (numberOfCreatedColumns === 0) {\n            skipThisChange = true;\n            break;\n          }\n        }\n      }\n\n      if (skipThisChange) {\n        /* eslint-disable no-continue */\n        continue;\n      }\n\n      datamap.set(changes[i][0], changes[i][1], changes[i][3]);\n    }\n\n    instance.forceFullRender = true; // used when data was changed\n\n    grid.adjustRowsAndCols();\n    instance.runHooks('beforeChangeRender', changes, source);\n    editorManager.lockEditor();\n\n    instance._refreshBorders(null);\n\n    editorManager.unlockEditor();\n    instance.view.wt.wtOverlays.adjustElementsSize();\n    instance.runHooks('afterChange', changes, source || 'edit');\n    var activeEditor = instance.getActiveEditor();\n\n    if (activeEditor && isDefined(activeEditor.refreshValue)) {\n      activeEditor.refreshValue();\n    }\n  }\n  /**\n   * Validate a single cell.\n   *\n   * @param {String|Number} value\n   * @param cellProperties\n   * @param callback\n   * @param source\n   */\n\n\n  this.validateCell = function (value, cellProperties, callback, source) {\n    var validator = instance.getCellValidator(cellProperties); // the `canBeValidated = false` argument suggests, that the cell passes validation by default.\n\n    function done(valid) {\n      var canBeValidated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      // Fixes GH#3903\n      if (!canBeValidated || cellProperties.hidden === true) {\n        callback(valid);\n        return;\n      }\n\n      var col = cellProperties.visualCol;\n      var row = cellProperties.visualRow;\n      var td = instance.getCell(row, col, true);\n\n      if (td && td.nodeName !== 'TH') {\n        instance.view.wt.wtSettings.settings.cellRenderer(row, col, td);\n      }\n\n      callback(valid);\n    }\n\n    if (isRegExp(validator)) {\n      validator = function (expression) {\n        return function (cellValue, validatorCallback) {\n          validatorCallback(expression.test(cellValue));\n        };\n      }(validator);\n    }\n\n    if (isFunction(validator)) {\n      // eslint-disable-next-line no-param-reassign\n      value = instance.runHooks('beforeValidate', value, cellProperties.visualRow, cellProperties.prop, source); // To provide consistent behaviour, validation should be always asynchronous\n\n      instance._registerImmediate(function () {\n        validator.call(cellProperties, value, function (valid) {\n          if (!instance) {\n            return;\n          } // eslint-disable-next-line no-param-reassign\n\n\n          valid = instance.runHooks('afterValidate', valid, value, cellProperties.visualRow, cellProperties.prop, source);\n          cellProperties.valid = valid;\n          done(valid);\n          instance.runHooks('postAfterValidate', valid, value, cellProperties.visualRow, cellProperties.prop, source);\n        });\n      });\n    } else {\n      // resolve callback even if validator function was not found\n      instance._registerImmediate(function () {\n        cellProperties.valid = true;\n        done(cellProperties.valid, false);\n      });\n    }\n  };\n\n  function setDataInputToArray(row, propOrCol, value) {\n    if (_typeof(row) === 'object') {\n      // is it an array of changes\n      return row;\n    }\n\n    return [[row, propOrCol, value]];\n  }\n  /**\n   * @description\n   * Set new value to a cell. To change many cells at once (recommended way), pass an array of `changes` in format\n   * `[[row, col, value],...]` as the first argument.\n   *\n   * @memberof Core#\n   * @function setDataAtCell\n   * @param {Number|Array} row Visual row index or array of changes in format `[[row, col, value],...]`.\n   * @param {Number} [column] Visual column index.\n   * @param {String} [value] New value.\n   * @param {String} [source] String that identifies how this change will be described in the changes array (useful in onAfterChange or onBeforeChange callback).\n   */\n\n\n  this.setDataAtCell = function (row, column, value, source) {\n    var input = setDataInputToArray(row, column, value);\n    var changes = [];\n    var changeSource = source;\n    var i;\n    var ilen;\n    var prop;\n\n    for (i = 0, ilen = input.length; i < ilen; i++) {\n      if (_typeof(input[i]) !== 'object') {\n        throw new Error('Method `setDataAtCell` accepts row number or changes array of arrays as its first parameter');\n      }\n\n      if (typeof input[i][1] !== 'number') {\n        throw new Error('Method `setDataAtCell` accepts row and column number as its parameters. If you want to use object property name, use method `setDataAtRowProp`');\n      }\n\n      var physicalRow = recordTranslator.toPhysicalRow(input[i][0]);\n      prop = datamap.colToProp(input[i][1]);\n      changes.push([input[i][0], prop, dataSource.getAtCell(physicalRow, input[i][1]), input[i][2]]);\n    }\n\n    if (!changeSource && _typeof(row) === 'object') {\n      changeSource = column;\n    }\n\n    instance.runHooks('afterSetDataAtCell', changes, changeSource);\n    validateChanges(changes, changeSource, function () {\n      applyChanges(changes, changeSource);\n    });\n  };\n  /**\n   * @description\n   * Set new value to a cell. To change many cells at once (recommended way), pass an array of `changes` in format\n   * `[[row, prop, value],...]` as the first argument.\n   *\n   * @memberof Core#\n   * @function setDataAtRowProp\n   * @param {Number|Array} row Visual row index or array of changes in format `[[row, prop, value], ...]`.\n   * @param {String} prop Property name or the source string (e.g. `'first.name'` or `'0'`).\n   * @param {String} value Value to be set.\n   * @param {String} [source] String that identifies how this change will be described in changes array (useful in onChange callback).\n   */\n\n\n  this.setDataAtRowProp = function (row, prop, value, source) {\n    var input = setDataInputToArray(row, prop, value);\n    var changes = [];\n    var changeSource = source;\n    var i;\n    var ilen;\n\n    for (i = 0, ilen = input.length; i < ilen; i++) {\n      var physicalRow = recordTranslator.toPhysicalRow(input[i][0]);\n      changes.push([input[i][0], input[i][1], dataSource.getAtCell(physicalRow, input[i][1]), input[i][2]]);\n    }\n\n    if (!changeSource && _typeof(row) === 'object') {\n      changeSource = prop;\n    }\n\n    instance.runHooks('afterSetDataAtRowProp', changes, changeSource);\n    validateChanges(changes, changeSource, function () {\n      applyChanges(changes, changeSource);\n    });\n  };\n  /**\n   * Listen to the keyboard input on document body. This allows Handsontable to capture keyboard events and respond\n   * in the right way.\n   *\n   * @memberof Core#\n   * @function listen\n   * @param {Boolean} [modifyDocumentFocus=true] If `true`, currently focused element will be blured (which returns focus\n   *                                             to the document.body). Otherwise the active element does not lose its focus.\n   * @fires Hooks#afterListen\n   */\n\n\n  this.listen = function () {\n    var modifyDocumentFocus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    var _instance5 = instance,\n        rootDocument = _instance5.rootDocument;\n\n    if (modifyDocumentFocus) {\n      var invalidActiveElement = !rootDocument.activeElement || rootDocument.activeElement && rootDocument.activeElement.nodeName === void 0;\n\n      if (rootDocument.activeElement && rootDocument.activeElement !== rootDocument.body && !invalidActiveElement) {\n        rootDocument.activeElement.blur();\n      } else if (invalidActiveElement) {\n        // IE\n        rootDocument.body.focus();\n      }\n    }\n\n    if (instance && !instance.isListening()) {\n      activeGuid = instance.guid;\n      instance.runHooks('afterListen');\n    }\n  };\n  /**\n   * Stop listening to keyboard input on the document body. Calling this method makes the Handsontable inactive for\n   * any keyboard events.\n   *\n   * @memberof Core#\n   * @function unlisten\n   */\n\n\n  this.unlisten = function () {\n    if (this.isListening()) {\n      activeGuid = null;\n      instance.runHooks('afterUnlisten');\n    }\n  };\n  /**\n   * Returns `true` if the current Handsontable instance is listening to keyboard input on document body.\n   *\n   * @memberof Core#\n   * @function isListening\n   * @returns {Boolean} `true` if the instance is listening, `false` otherwise.\n   */\n\n\n  this.isListening = function () {\n    return activeGuid === instance.guid;\n  };\n  /**\n   * Destroys the current editor, render the table and prepares the editor of the newly selected cell.\n   *\n   * @memberof Core#\n   * @function destroyEditor\n   * @param {Boolean} [revertOriginal=false] If `true`, the previous value will be restored. Otherwise, the edited value will be saved.\n   * @param {Boolean} [prepareEditorIfNeeded=true] If `true` the editor under the selected cell will be prepared to open.\n   */\n\n\n  this.destroyEditor = function () {\n    var revertOriginal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var prepareEditorIfNeeded = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    instance._refreshBorders(revertOriginal, prepareEditorIfNeeded);\n  };\n  /**\n   * Populate cells at position with 2D input array (e.g. `[[1, 2], [3, 4]]`). Use `endRow`, `endCol` when you\n   * want to cut input when a certain row is reached.\n   *\n   * Optional `method` argument has the same effect as pasteMode option (see {@link Options#pasteMode}).\n   *\n   * @memberof Core#\n   * @function populateFromArray\n   * @param {Number} row Start visual row index.\n   * @param {Number} column Start visual column index.\n   * @param {Array} input 2d array\n   * @param {Number} [endRow] End visual row index (use when you want to cut input when certain row is reached).\n   * @param {Number} [endCol] End visual column index (use when you want to cut input when certain column is reached).\n   * @param {String} [source=populateFromArray] Used to identify this call in the resulting events (beforeChange, afterChange).\n   * @param {String} [method=overwrite] Populate method, possible values: `'shift_down'`, `'shift_right'`, `'overwrite'`.\n   * @param {String} direction Populate direction, possible values: `'left'`, `'right'`, `'up'`, `'down'`.\n   * @param {Array} deltas The deltas array. A difference between values of adjacent cells.\n   *                       Useful **only** when the type of handled cells is `numeric`.\n   */\n\n\n  this.populateFromArray = function (row, column, input, endRow, endCol, source, method, direction, deltas) {\n    if (!(_typeof(input) === 'object' && _typeof(input[0]) === 'object')) {\n      throw new Error('populateFromArray parameter `input` must be an array of arrays'); // API changed in 0.9-beta2, let's check if you use it correctly\n    }\n\n    var c = typeof endRow === 'number' ? new CellCoords(endRow, endCol) : null;\n    return grid.populateFromArray(new CellCoords(row, column), input, c, source, method, direction, deltas);\n  };\n  /**\n   * Adds/removes data from the column. This method works the same as Array.splice for arrays (see {@link DataMap#spliceCol}).\n   *\n   * @memberof Core#\n   * @function spliceCol\n   * @param {Number} column Index of the column in which do you want to do splice.\n   * @param {Number} index Index at which to start changing the array. If negative, will begin that many elements from the end.\n   * @param {Number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed.\n   * @param {...Number} [elements] The elements to add to the array. If you don't specify any elements, spliceCol simply removes elements from the array.\n   */\n\n\n  this.spliceCol = function (column, index, amount) {\n    var _datamap;\n\n    for (var _len2 = arguments.length, elements = new Array(_len2 > 3 ? _len2 - 3 : 0), _key = 3; _key < _len2; _key++) {\n      elements[_key - 3] = arguments[_key];\n    }\n\n    return (_datamap = datamap).spliceCol.apply(_datamap, [column, index, amount].concat(elements));\n  };\n  /**\n   * Adds/removes data from the row. This method works the same as Array.splice for arrays (see {@link DataMap#spliceRow}).\n   *\n   * @memberof Core#\n   * @function spliceRow\n   * @param {Number} row Index of column in which do you want to do splice.\n   * @param {Number} index Index at which to start changing the array. If negative, will begin that many elements from the end.\n   * @param {Number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed.\n   * @param {...Number} [elements] The elements to add to the array. If you don't specify any elements, spliceCol simply removes elements from the array.\n   */\n\n\n  this.spliceRow = function (row, index, amount) {\n    var _datamap2;\n\n    for (var _len3 = arguments.length, elements = new Array(_len3 > 3 ? _len3 - 3 : 0), _key2 = 3; _key2 < _len3; _key2++) {\n      elements[_key2 - 3] = arguments[_key2];\n    }\n\n    return (_datamap2 = datamap).spliceRow.apply(_datamap2, [row, index, amount].concat(elements));\n  };\n  /**\n   * Returns indexes of the currently selected cells as an array of arrays `[[startRow, startCol, endRow, endCol],...]`.\n   *\n   * Start row and start column are the coordinates of the active cell (where the selection was started).\n   *\n   * The version 0.36.0 adds a non-consecutive selection feature. Since this version, the method returns an array of arrays.\n   * Additionally to collect the coordinates of the currently selected area (as it was previously done by the method)\n   * you need to use `getSelectedLast` method.\n   *\n   * @memberof Core#\n   * @function getSelected\n   * @returns {Array[]|undefined} An array of arrays of the selection's coordinates.\n   */\n\n\n  this.getSelected = function () {\n    // https://github.com/handsontable/handsontable/issues/44  //cjl\n    if (selection.isSelected()) {\n      return arrayMap(selection.getSelectedRange(), function (_ref11) {\n        var from = _ref11.from,\n            to = _ref11.to;\n        return [from.row, from.col, to.row, to.col];\n      });\n    }\n  };\n  /**\n   * Returns the last coordinates applied to the table as a an array `[startRow, startCol, endRow, endCol]`.\n   *\n   * @since 0.36.0\n   * @memberof Core#\n   * @function getSelectedLast\n   * @returns {Array|undefined} An array of the selection's coordinates.\n   */\n\n\n  this.getSelectedLast = function () {\n    var selected = this.getSelected();\n    var result;\n\n    if (selected && selected.length > 0) {\n      result = selected[selected.length - 1];\n    }\n\n    return result;\n  };\n  /**\n   * Returns the current selection as an array of CellRange objects.\n   *\n   * The version 0.36.0 adds a non-consecutive selection feature. Since this version, the method returns an array of arrays.\n   * Additionally to collect the coordinates of the currently selected area (as it was previously done by the method)\n   * you need to use `getSelectedRangeLast` method.\n   *\n   * @memberof Core#\n   * @function getSelectedRange\n   * @returns {CellRange[]|undefined} Selected range object or undefined if there is no selection.\n   */\n\n\n  this.getSelectedRange = function () {\n    // https://github.com/handsontable/handsontable/issues/44  //cjl\n    if (selection.isSelected()) {\n      return Array.from(selection.getSelectedRange());\n    }\n  };\n  /**\n  * Returns the last coordinates applied to the table as a CellRange object.\n  *\n  * @memberof Core#\n  * @function getSelectedRangeLast\n  * @since 0.36.0\n  * @returns {CellRange|undefined} Selected range object or undefined` if there is no selection.\n   */\n\n\n  this.getSelectedRangeLast = function () {\n    var selectedRange = this.getSelectedRange();\n    var result;\n\n    if (selectedRange && selectedRange.length > 0) {\n      result = selectedRange[selectedRange.length - 1];\n    }\n\n    return result;\n  };\n  /**\n   * Erases content from cells that have been selected in the table.\n   *\n   * @memberof Core#\n   * @function emptySelectedCells\n   * @param {String} [source] String that identifies how this change will be described in the changes array (useful in onAfterChange or onBeforeChange callback).\n   * @since 0.36.0\n   */\n\n\n  this.emptySelectedCells = function (source) {\n    var _this2 = this;\n\n    if (!selection.isSelected()) {\n      return;\n    }\n\n    var changes = [];\n    arrayEach(selection.getSelectedRange(), function (cellRange) {\n      var topLeft = cellRange.getTopLeftCorner();\n      var bottomRight = cellRange.getBottomRightCorner();\n      rangeEach(topLeft.row, bottomRight.row, function (row) {\n        rangeEach(topLeft.col, bottomRight.col, function (column) {\n          if (!_this2.getCellMeta(row, column).readOnly) {\n            changes.push([row, column, null]);\n          }\n        });\n      });\n    });\n\n    if (changes.length > 0) {\n      this.setDataAtCell(changes, source);\n    }\n  };\n  /**\n   * Rerender the table. Calling this method starts the process of recalculating, redrawing and applying the changes\n   * to the DOM. While rendering the table all cell renderers are recalled.\n   *\n   * Calling this method manually is not recommended. Handsontable tries to render itself by choosing the most\n   * optimal moments in its lifecycle.\n   *\n   * @memberof Core#\n   * @function render\n   */\n\n\n  this.render = function () {\n    if (instance.view) {\n      instance.renderCall = true;\n      instance.forceFullRender = true; // used when data was changed\n\n      editorManager.lockEditor();\n\n      instance._refreshBorders(null);\n\n      editorManager.unlockEditor();\n    }\n  };\n\n  this.refreshDimensions = function () {\n    if (!instance.view) {\n      return;\n    }\n\n    var _instance$view$getLas = instance.view.getLastSize(),\n        lastWidth = _instance$view$getLas.width,\n        lastHeight = _instance$view$getLas.height;\n\n    var _instance$rootElement = instance.rootElement.getBoundingClientRect(),\n        width = _instance$rootElement.width,\n        height = _instance$rootElement.height;\n\n    var isSizeChanged = width !== lastWidth || height !== lastHeight;\n    var isResizeBlocked = instance.runHooks('beforeRefreshDimensions', {\n      width: lastWidth,\n      height: lastHeight\n    }, {\n      width: width,\n      height: height\n    }, isSizeChanged) === false;\n\n    if (isResizeBlocked) {\n      return;\n    }\n\n    if (isSizeChanged || instance.view.wt.wtOverlays.scrollableElement === instance.rootWindow) {\n      instance.view.setLastSize(width, height);\n      instance.render();\n    }\n\n    instance.runHooks('afterRefreshDimensions', {\n      width: lastWidth,\n      height: lastHeight\n    }, {\n      width: width,\n      height: height\n    }, isSizeChanged);\n  };\n  /**\n   * Loads new data to Handsontable. Loading new data resets the cell meta.\n   *\n   * @memberof Core#\n   * @function loadData\n   * @param {Array} data Array of arrays or array of objects containing data.\n   * @fires Hooks#afterLoadData\n   * @fires Hooks#afterChange\n   */\n\n\n  this.loadData = function (data) {\n    if (Array.isArray(priv.settings.dataSchema)) {\n      instance.dataType = 'array';\n    } else if (isFunction(priv.settings.dataSchema)) {\n      instance.dataType = 'function';\n    } else {\n      instance.dataType = 'object';\n    }\n\n    if (datamap) {\n      datamap.destroy();\n    }\n\n    datamap = new DataMap(instance, priv, GridSettings);\n\n    if (_typeof(data) === 'object' && data !== null) {\n      if (!(data.push && data.splice)) {\n        // check if data is array. Must use duck-type check so Backbone Collections also pass it\n        // when data is not an array, attempt to make a single-row array of it\n        // eslint-disable-next-line no-param-reassign\n        data = [data];\n      }\n    } else if (data === null) {\n      var dataSchema = datamap.getSchema(); // eslint-disable-next-line no-param-reassign\n\n      data = [];\n      var row;\n      var r = 0;\n      var rlen = 0;\n\n      for (r = 0, rlen = priv.settings.startRows; r < rlen; r++) {\n        if ((instance.dataType === 'object' || instance.dataType === 'function') && priv.settings.dataSchema) {\n          row = deepClone(dataSchema);\n          data.push(row);\n        } else if (instance.dataType === 'array') {\n          row = deepClone(dataSchema[0]);\n          data.push(row);\n        } else {\n          row = [];\n\n          for (var c = 0, clen = priv.settings.startCols; c < clen; c++) {\n            row.push(null);\n          }\n\n          data.push(row);\n        }\n      }\n    } else {\n      throw new Error(\"loadData only accepts array of objects or array of arrays (\".concat(_typeof(data), \" given)\"));\n    }\n\n    priv.isPopulated = false;\n    GridSettings.prototype.data = data;\n\n    if (Array.isArray(data[0])) {\n      instance.dataType = 'array';\n    }\n\n    datamap.dataSource = data;\n    dataSource.data = data;\n    dataSource.dataType = instance.dataType;\n    dataSource.colToProp = datamap.colToProp.bind(datamap);\n    dataSource.propToCol = datamap.propToCol.bind(datamap);\n    clearCellSettingCache();\n    grid.adjustRowsAndCols();\n    instance.runHooks('afterLoadData', priv.firstRun);\n\n    if (priv.firstRun) {\n      priv.firstRun = [null, 'loadData'];\n    } else {\n      instance.runHooks('afterChange', null, 'loadData');\n      instance.render();\n    }\n\n    priv.isPopulated = true;\n\n    function clearCellSettingCache() {\n      priv.cellSettings.length = 0;\n    }\n  };\n  /**\n   * Returns the current data object (the same one that was passed by `data` configuration option or `loadData` method,\n   * unless the `modifyRow` hook was used to trim some of the rows. If that's the case - use the {@link Core#getSourceData} method.).\n   *\n   * Optionally you can provide cell range by defining `row`, `column`, `row2`, `column2` to get only a fragment of table data.\n   *\n   * @memberof Core#\n   * @function getData\n   * @param {Number} [row] From visual row index.\n   * @param {Number} [column] From visual column index.\n   * @param {Number} [row2] To visual row index.\n   * @param {Number} [column2] To visual column index.\n   * @returns {Array[]} Array with the data.\n   * @example\n   * ```js\n   * // Get all data (in order how it is rendered in the table).\n   * hot.getData();\n   * // Get data fragment (from top-left 0, 0 to bottom-right 3, 3).\n   * hot.getData(3, 3);\n   * // Get data fragment (from top-left 2, 1 to bottom-right 3, 3).\n   * hot.getData(2, 1, 3, 3);\n   * ```\n   */\n\n\n  this.getData = function (row, column, row2, column2) {\n    if (isUndefined(row)) {\n      return datamap.getAll();\n    }\n\n    return datamap.getRange(new CellCoords(row, column), new CellCoords(row2, column2), datamap.DESTINATION_RENDERER);\n  };\n  /**\n   * Returns a string value of the selected range. Each column is separated by tab, each row is separated by a new\n   * line character (see {@link DataMap#getCopyableText}).\n   *\n   * @memberof Core#\n   * @function getCopyableText\n   * @param {Number} startRow From visual row index.\n   * @param {Number} startCol From visual column index.\n   * @param {Number} endRow To visual row index.\n   * @param {Number} endCol To visual column index.\n   * @returns {String}\n   */\n\n\n  this.getCopyableText = function (startRow, startCol, endRow, endCol) {\n    return datamap.getCopyableText(new CellCoords(startRow, startCol), new CellCoords(endRow, endCol));\n  };\n  /**\n   * Returns the data's copyable value at specified `row` and `column` index (see {@link DataMap#getCopyable}).\n   *\n   * @memberof Core#\n   * @function getCopyableData\n   * @param {Number} row Visual row index.\n   * @param {Number} column Visual column index.\n   * @returns {String}\n   */\n\n\n  this.getCopyableData = function (row, column) {\n    return datamap.getCopyable(row, datamap.colToProp(column));\n  };\n  /**\n   * Returns schema provided by constructor settings. If it doesn't exist then it returns the schema based on the data\n   * structure in the first row.\n   *\n   * @memberof Core#\n   * @function getSchema\n   * @returns {Object} Schema object.\n   */\n\n\n  this.getSchema = function () {\n    return datamap.getSchema();\n  };\n  /**\n   * Use it if you need to change configuration after initialization. The `settings` argument is an object containing the new\n   * settings, declared the same way as in the initial settings object.\n   *\n   * __Note__, that although the `updateSettings` method doesn't overwrite the previously declared settings, it might reset\n   * the settings made post-initialization. (for example - ignore changes made using the columnResize feature).\n   *\n   * @memberof Core#\n   * @function updateSettings\n   * @param {Object} settings New settings object (see {@link Options}).\n   * @param {Boolean} [init=false] Internally used for in initialization mode.\n   * @example\n   * ```js\n   * hot.updateSettings({\n   *    contextMenu: true,\n   *    colHeaders: true,\n   *    fixedRowsTop: 2\n   * });\n   * ```\n   * @fires Hooks#afterCellMetaReset\n   * @fires Hooks#afterUpdateSettings\n   */\n\n\n  this.updateSettings = function (settings) {\n    var init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var columnsAsFunc = false;\n    var i;\n    var j;\n    var clen;\n\n    if (isDefined(settings.rows)) {\n      throw new Error('\"rows\" setting is no longer supported. do you mean startRows, minRows or maxRows?');\n    }\n\n    if (isDefined(settings.cols)) {\n      throw new Error('\"cols\" setting is no longer supported. do you mean startCols, minCols or maxCols?');\n    } // eslint-disable-next-line no-restricted-syntax\n\n\n    for (i in settings) {\n      if (i === 'data') {\n        /* eslint-disable-next-line no-continue */\n        continue; // loadData will be triggered later\n      } else if (i === 'language') {\n        setLanguage(settings.language);\n        /* eslint-disable-next-line no-continue */\n\n        continue;\n      } else if (Hooks.getSingleton().getRegistered().indexOf(i) > -1) {\n        if (isFunction(settings[i]) || Array.isArray(settings[i])) {\n          settings[i].initialHook = true;\n          instance.addHook(i, settings[i]);\n        }\n      } else if (!init && hasOwnProperty(settings, i)) {\n        // Update settings\n        GridSettings.prototype[i] = settings[i];\n      }\n    } // Load data or create data map\n\n\n    if (settings.data === void 0 && priv.settings.data === void 0) {\n      instance.loadData(null); // data source created just now\n    } else if (settings.data !== void 0) {\n      instance.loadData(settings.data); // data source given as option\n    } else if (settings.columns !== void 0) {\n      datamap.createMap();\n    }\n\n    clen = instance.countCols();\n    var columnSetting = settings.columns || GridSettings.prototype.columns; // Init columns constructors configuration\n\n    if (columnSetting && isFunction(columnSetting)) {\n      clen = instance.countSourceCols();\n      columnsAsFunc = true;\n    } // Clear cellSettings cache\n\n\n    if (settings.cell !== void 0 || settings.cells !== void 0 || settings.columns !== void 0) {\n      priv.cellSettings.length = 0;\n    }\n\n    if (clen > 0) {\n      var proto;\n      var column;\n\n      for (i = 0, j = 0; i < clen; i++) {\n        if (columnsAsFunc && !columnSetting(i)) {\n          /* eslint-disable no-continue */\n          continue;\n        }\n\n        priv.columnSettings[j] = columnFactory(GridSettings, priv.columnsSettingConflicts); // shortcut for prototype\n\n        proto = priv.columnSettings[j].prototype; // Use settings provided by user\n\n        if (columnSetting) {\n          if (columnsAsFunc) {\n            column = columnSetting(i);\n          } else {\n            column = columnSetting[j];\n          }\n\n          if (column) {\n            extend(proto, column);\n            extend(proto, expandType(column));\n          }\n        }\n\n        j += 1;\n      }\n    }\n\n    if (isDefined(settings.cell)) {\n      objectEach(settings.cell, function (cell) {\n        instance.setCellMetaObject(cell.row, cell.col, cell);\n      });\n    }\n\n    instance.runHooks('afterCellMetaReset');\n\n    if (isDefined(settings.className)) {\n      if (GridSettings.prototype.className) {\n        removeClass(instance.rootElement, GridSettings.prototype.className);\n      }\n\n      if (settings.className) {\n        addClass(instance.rootElement, settings.className);\n      }\n    }\n\n    var currentHeight = instance.rootElement.style.height;\n\n    if (currentHeight !== '') {\n      currentHeight = parseInt(instance.rootElement.style.height, 10);\n    }\n\n    var height = settings.height;\n\n    if (isFunction(height)) {\n      height = height();\n    }\n\n    if (init) {\n      var initialStyle = instance.rootElement.getAttribute('style');\n\n      if (initialStyle) {\n        instance.rootElement.setAttribute('data-initialstyle', instance.rootElement.getAttribute('style'));\n      }\n    }\n\n    if (height === null) {\n      var _initialStyle = instance.rootElement.getAttribute('data-initialstyle');\n\n      if (_initialStyle && (_initialStyle.indexOf('height') > -1 || _initialStyle.indexOf('overflow') > -1)) {\n        instance.rootElement.setAttribute('style', _initialStyle);\n      } else {\n        instance.rootElement.style.height = '';\n        instance.rootElement.style.overflow = '';\n      }\n    } else if (height !== void 0) {\n      instance.rootElement.style.height = isNaN(height) ? \"\".concat(height) : \"\".concat(height, \"px\");\n      instance.rootElement.style.overflow = 'hidden';\n    }\n\n    if (typeof settings.width !== 'undefined') {\n      var width = settings.width;\n\n      if (isFunction(width)) {\n        width = width();\n      }\n\n      instance.rootElement.style.width = isNaN(width) ? \"\".concat(width) : \"\".concat(width, \"px\");\n    }\n\n    if (!init) {\n      datamap.clearLengthCache(); // force clear cache length on updateSettings() #3416\n\n      if (instance.view) {\n        instance.view.wt.wtViewport.resetHasOversizedColumnHeadersMarked();\n      }\n\n      instance.runHooks('afterUpdateSettings', settings);\n    }\n\n    grid.adjustRowsAndCols();\n\n    if (instance.view && !priv.firstRun) {\n      instance.forceFullRender = true; // used when data was changed\n\n      editorManager.lockEditor();\n\n      instance._refreshBorders(null);\n\n      editorManager.unlockEditor();\n    }\n\n    if (!init && instance.view && (currentHeight === '' || height === '' || height === void 0) && currentHeight !== height) {\n      instance.view.wt.wtOverlays.updateMainScrollableElements();\n    }\n  };\n  /**\n   * Get value from the selected cell.\n   *\n   * @memberof Core#\n   * @function getValue\n   * @returns {*} Value of selected cell.\n   */\n\n\n  this.getValue = function () {\n    var sel = instance.getSelectedLast();\n\n    if (GridSettings.prototype.getValue) {\n      if (isFunction(GridSettings.prototype.getValue)) {\n        return GridSettings.prototype.getValue.call(instance);\n      } else if (sel) {\n        return instance.getData()[sel[0][0]][GridSettings.prototype.getValue];\n      }\n    } else if (sel) {\n      return instance.getDataAtCell(sel[0], sel[1]);\n    }\n  };\n\n  function expandType(obj) {\n    if (!hasOwnProperty(obj, 'type')) {\n      // ignore obj.prototype.type\n      return;\n    }\n\n    var expandedType = {};\n    var type;\n\n    if (_typeof(obj.type) === 'object') {\n      type = obj.type;\n    } else if (typeof obj.type === 'string') {\n      type = getCellType(obj.type);\n    } // eslint-disable-next-line no-restricted-syntax\n\n\n    for (var i in type) {\n      if (hasOwnProperty(type, i) && !hasOwnProperty(obj, i)) {\n        expandedType[i] = type[i];\n      }\n    }\n\n    return expandedType;\n  }\n  /**\n   * Returns the object settings.\n   *\n   * @memberof Core#\n   * @function getSettings\n   * @returns {Object} Object containing the current table settings.\n   */\n\n\n  this.getSettings = function () {\n    return priv.settings;\n  };\n  /**\n   * Clears the data from the table (the table settings remain intact).\n   *\n   * @memberof Core#\n   * @function clear\n   */\n\n\n  this.clear = function () {\n    this.selectAll();\n    this.emptySelectedCells();\n  };\n  /**\n   * Allows altering the table structure by either inserting/removing rows or columns.\n   *\n   * @memberof Core#\n   * @function alter\n   * @param {String} action Possible alter operations:\n   *  * `'insert_row'`\n   *  * `'insert_col'`\n   *  * `'remove_row'`\n   *  * `'remove_col'`\n   * @param {Number|Number[]} index Visual index of the row/column before which the new row/column will be\n   *                                inserted/removed or an array of arrays in format `[[index, amount],...]`.\n   * @param {Number} [amount=1] Amount of rows/columns to be inserted or removed.\n   * @param {String} [source] Source indicator.\n   * @param {Boolean} [keepEmptyRows] Flag for preventing deletion of empty rows.\n   * @example\n   * ```js\n   * // Insert new row above the row at given visual index.\n   * hot.alter('insert_row', 10);\n   * // Insert 3 new columns before 10th column.\n   * hot.alter('insert_col', 10, 3);\n   * // Remove 2 rows starting from 10th row.\n   * hot.alter('remove_row', 10, 2);\n   * // Remove 5 non-contiquous rows (it removes 3 rows from visual index 1 and 2 rows from visual index 5).\n   * hot.alter('remove_row', [[1, 3], [5, 2]]);\n   * ```\n   */\n\n\n  this.alter = function (action, index, amount, source, keepEmptyRows) {\n    grid.alter(action, index, amount, source, keepEmptyRows);\n  };\n  /**\n   * Returns a TD element for the given `row` and `column` arguments, if it is rendered on screen.\n   * Returns `null` if the TD is not rendered on screen (probably because that part of the table is not visible).\n   *\n   * @memberof Core#\n   * @function getCell\n   * @param {Number} row Visual row index.\n   * @param {Number} column Visual column index.\n   * @param {Boolean} [topmost=false] If set to `true`, it returns the TD element from the topmost overlay. For example,\n   * if the wanted cell is in the range of fixed rows, it will return a TD element from the `top` overlay.\n   * @returns {HTMLTableCellElement|null} The cell's TD element.\n   */\n\n\n  this.getCell = function (row, column) {\n    var topmost = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    return instance.view.getCellAtCoords(new CellCoords(row, column), topmost);\n  };\n  /**\n   * Returns the coordinates of the cell, provided as a HTML table cell element.\n   *\n   * @memberof Core#\n   * @function getCoords\n   * @param {HTMLTableCellElement} element The HTML Element representing the cell.\n   * @returns {CellCoords} Visual coordinates object.\n   * @example\n   * ```js\n   * hot.getCoords(hot.getCell(1, 1));\n   * // it returns CellCoords object instance with props row: 1 and col: 1.\n   * ```\n   */\n\n\n  this.getCoords = function (element) {\n    return this.view.wt.wtTable.getCoords.call(this.view.wt.wtTable, element);\n  };\n  /**\n   * Returns the property name that corresponds with the given column index (see {@link DataMap#colToProp}).\n   * If the data source is an array of arrays, it returns the columns index.\n   *\n   * @memberof Core#\n   * @function colToProp\n   * @param {Number} column Visual column index.\n   * @returns {String|Number} Column property or physical column index.\n   */\n\n\n  this.colToProp = function (column) {\n    return datamap.colToProp(column);\n  };\n  /**\n   * Returns column index that corresponds with the given property (see {@link DataMap#propToCol}).\n   *\n   * @memberof Core#\n   * @function propToCol\n   * @param {String|Number} prop Property name or physical column index.\n   * @returns {Number} Visual column index.\n   */\n\n\n  this.propToCol = function (prop) {\n    return datamap.propToCol(prop);\n  };\n  /**\n   * Translate physical row index into visual.\n   *\n   * This method is useful when you want to retrieve visual row index which can be reordered, moved or trimmed\n   * based on a physical index\n   *\n   * @memberof Core#\n   * @function toVisualRow\n   * @param {Number} row Physical row index.\n   * @returns {Number} Returns visual row index.\n   */\n\n\n  this.toVisualRow = function (row) {\n    return recordTranslator.toVisualRow(row);\n  };\n  /**\n   * Translate physical column index into visual.\n   *\n   * This method is useful when you want to retrieve visual column index which can be reordered, moved or trimmed\n   * based on a physical index\n   *\n   * @memberof Core#\n   * @function toVisualColumn\n   * @param {Number} column Physical column index.\n   * @returns {Number} Returns visual column index.\n   */\n\n\n  this.toVisualColumn = function (column) {\n    return recordTranslator.toVisualColumn(column);\n  };\n  /**\n   * Translate visual row index into physical.\n   *\n   * This method is useful when you want to retrieve physical row index based on a visual index which can be\n   * reordered, moved or trimmed.\n   *\n   * @memberof Core#\n   * @function toPhysicalRow\n   * @param {Number} row Visual row index.\n   * @returns {Number} Returns physical row index.\n   */\n\n\n  this.toPhysicalRow = function (row) {\n    return recordTranslator.toPhysicalRow(row);\n  };\n  /**\n   * Translate visual column index into physical.\n   *\n   * This method is useful when you want to retrieve physical column index based on a visual index which can be\n   * reordered, moved or trimmed.\n   *\n   * @memberof Core#\n   * @function toPhysicalColumn\n   * @param {Number} column Visual column index.\n   * @returns {Number} Returns physical column index.\n   */\n\n\n  this.toPhysicalColumn = function (column) {\n    return recordTranslator.toPhysicalColumn(column);\n  };\n  /**\n   * @description\n   * Returns the cell value at `row`, `column`.\n   *\n   * __Note__: If data is reordered, sorted or trimmed, the currently visible order will be used.\n   *\n   * @memberof Core#\n   * @function getDataAtCell\n   * @param {Number} row Visual row index.\n   * @param {Number} column Visual column index.\n   * @returns {*} Data at cell.\n   */\n\n\n  this.getDataAtCell = function (row, column) {\n    return datamap.get(row, datamap.colToProp(column));\n  };\n  /**\n   * Returns value at visual `row` and `prop` indexes (see {@link DataMap#get}).\n   *\n   * __Note__: If data is reordered, sorted or trimmed, the currently visible order will be used.\n   *\n   * @memberof Core#\n   * @function getDataAtRowProp\n   * @param {Number} row Visual row index.\n   * @param {String} prop Property name.\n   * @returns {*} Cell value.\n   */\n\n\n  this.getDataAtRowProp = function (row, prop) {\n    return datamap.get(row, prop);\n  };\n  /**\n   * @description\n   * Returns array of column values from the data source.\n   *\n   * __Note__: If columns were reordered or sorted, the currently visible order will be used.\n   *\n   * @memberof Core#\n   * @function getDataAtCol\n   * @param {Number} column Visual column index.\n   * @returns {Array} Array of cell values.\n   */\n\n\n  this.getDataAtCol = function (column) {\n    var _ref12;\n\n    return (_ref12 = []).concat.apply(_ref12, _toConsumableArray(datamap.getRange(new CellCoords(0, column), new CellCoords(priv.settings.data.length - 1, column), datamap.DESTINATION_RENDERER)));\n  };\n  /**\n   * Given the object property name (e.g. `'first.name'` or `'0'`), returns an array of column's values from the table data.\n   * You can also provide a column index as the first argument.\n   *\n   * @memberof Core#\n   * @function getDataAtProp\n   * @param {String|Number} prop Property name or physical column index.\n   * @returns {Array} Array of cell values.\n   */\n  // TODO: Getting data from `datamap` should work on visual indexes.\n\n\n  this.getDataAtProp = function (prop) {\n    var _ref13;\n\n    var range = datamap.getRange(new CellCoords(0, datamap.propToCol(prop)), new CellCoords(priv.settings.data.length - 1, datamap.propToCol(prop)), datamap.DESTINATION_RENDERER);\n    return (_ref13 = []).concat.apply(_ref13, _toConsumableArray(range));\n  };\n  /**\n   * Returns the source data object (the same that was passed by `data` configuration option or `loadData` method).\n   * Optionally you can provide a cell range by using the `row`, `column`, `row2`, `column2` arguments, to get only a\n   * fragment of the table data.\n   *\n   * __Note__: This method does not participate in data transformation. If the visual data of the table is reordered,\n   * sorted or trimmed only physical indexes are correct.\n   *\n   * @memberof Core#\n   * @function getSourceData\n   * @param {Number} [row] From physical row index.\n   * @param {Number} [column] From physical column index (or visual index, if data type is an array of objects).\n   * @param {Number} [row2] To physical row index.\n   * @param {Number} [column2] To physical column index (or visual index, if data type is an array of objects).\n   * @returns {Array[]|Object[]} The table data.\n   */\n\n\n  this.getSourceData = function (row, column, row2, column2) {\n    var data;\n\n    if (row === void 0) {\n      data = dataSource.getData();\n    } else {\n      data = dataSource.getByRange(new CellCoords(row, column), new CellCoords(row2, column2));\n    }\n\n    return data;\n  };\n  /**\n   * Returns the source data object as an arrays of arrays format even when source data was provided in another format.\n   * Optionally you can provide a cell range by using the `row`, `column`, `row2`, `column2` arguments, to get only a\n   * fragment of the table data.\n   *\n   * __Note__: This method does not participate in data transformation. If the visual data of the table is reordered,\n   * sorted or trimmed only physical indexes are correct.\n   *\n   * @memberof Core#\n   * @function getSourceDataArray\n   * @param {Number} [row] From physical row index.\n   * @param {Number} [column] From physical column index (or visual index, if data type is an array of objects).\n   * @param {Number} [row2] To physical row index.\n   * @param {Number} [column2] To physical column index (or visual index, if data type is an array of objects).\n   * @returns {Array} An array of arrays.\n   */\n\n\n  this.getSourceDataArray = function (row, column, row2, column2) {\n    var data;\n\n    if (row === void 0) {\n      data = dataSource.getData(true);\n    } else {\n      data = dataSource.getByRange(new CellCoords(row, column), new CellCoords(row2, column2), true);\n    }\n\n    return data;\n  };\n  /**\n   * Returns an array of column values from the data source.\n   *\n   * @memberof Core#\n   * @function getSourceDataAtCol\n   * @param {Number} column Visual column index.\n   * @returns {Array} Array of the column's cell values.\n   */\n  // TODO: Getting data from `sourceData` should work always on physical indexes.\n\n\n  this.getSourceDataAtCol = function (column) {\n    return dataSource.getAtColumn(column);\n  };\n  /**\n   * Returns a single row of the data (array or object, depending on what data format you use).\n   *\n   * __Note__: This method does not participate in data transformation. If the visual data of the table is reordered,\n   * sorted or trimmed only physical indexes are correct.\n   *\n   * @memberof Core#\n   * @function getSourceDataAtRow\n   * @param {Number} row Physical row index.\n   * @returns {Array|Object} Single row of data.\n   */\n\n\n  this.getSourceDataAtRow = function (row) {\n    return dataSource.getAtRow(row);\n  };\n  /**\n   * Returns a single value from the data source.\n   *\n   * @memberof Core#\n   * @function getSourceDataAtCell\n   * @param {Number} row Physical row index.\n   * @param {Number} column Visual column index.\n   * @returns {*} Cell data.\n   */\n  // TODO: Getting data from `sourceData` should work always on physical indexes.\n\n\n  this.getSourceDataAtCell = function (row, column) {\n    return dataSource.getAtCell(row, column);\n  };\n  /**\n   * @description\n   * Returns a single row of the data.\n   *\n   * __Note__: If rows were reordered, sorted or trimmed, the currently visible order will be used.\n   *\n   * @memberof Core#\n   * @function getDataAtRow\n   * @param {Number} row Visual row index.\n   * @returns {Array} Array of row's cell data.\n   */\n\n\n  this.getDataAtRow = function (row) {\n    var data = datamap.getRange(new CellCoords(row, 0), new CellCoords(row, this.countCols() - 1), datamap.DESTINATION_RENDERER);\n    return data[0] || [];\n  };\n  /**\n   * @description\n   * Returns a data type defined in the Handsontable settings under the `type` key ([Options#type](http://docs.handsontable.com/Options.html#type)).\n   * If there are cells with different types in the selected range, it returns `'mixed'`.\n   *\n   * __Note__: If data is reordered, sorted or trimmed, the currently visible order will be used.\n   *\n   * @memberof Core#\n   * @function getDataType\n   * @param {Number} rowFrom From visual row index.\n   * @param {Number} columnFrom From visual column index.\n   * @param {Number} rowTo To visual row index.\n   * @param {Number} columnTo To visual column index.\n   * @returns {String} Cell type (e.q: `'mixed'`, `'text'`, `'numeric'`, `'autocomplete'`).\n   */\n\n\n  this.getDataType = function (rowFrom, columnFrom, rowTo, columnTo) {\n    var _this3 = this;\n\n    var coords = rowFrom === void 0 ? [0, 0, this.countRows(), this.countCols()] : [rowFrom, columnFrom, rowTo, columnTo];\n    var rowStart = coords[0],\n        columnStart = coords[1];\n    var rowEnd = coords[2],\n        columnEnd = coords[3];\n    var previousType = null;\n    var currentType = null;\n\n    if (rowEnd === void 0) {\n      rowEnd = rowStart;\n    }\n\n    if (columnEnd === void 0) {\n      columnEnd = columnStart;\n    }\n\n    var type = 'mixed';\n    rangeEach(Math.min(rowStart, rowEnd), Math.max(rowStart, rowEnd), function (row) {\n      var isTypeEqual = true;\n      rangeEach(Math.min(columnStart, columnEnd), Math.max(columnStart, columnEnd), function (column) {\n        var cellType = _this3.getCellMeta(row, column);\n\n        currentType = cellType.type;\n\n        if (previousType) {\n          isTypeEqual = previousType === currentType;\n        } else {\n          previousType = currentType;\n        }\n\n        return isTypeEqual;\n      });\n      type = isTypeEqual ? currentType : 'mixed';\n      return isTypeEqual;\n    });\n    return type;\n  };\n  /**\n   * Remove a property defined by the `key` argument from the cell meta object for the provided `row` and `column` coordinates.\n   *\n   * @memberof Core#\n   * @function removeCellMeta\n   * @param {Number} row Visual row index.\n   * @param {Number} column Visual column index.\n   * @param {String} key Property name.\n   * @fires Hooks#beforeRemoveCellMeta\n   * @fires Hooks#afterRemoveCellMeta\n   */\n\n\n  this.removeCellMeta = function (row, column, key) {\n    var _recordTranslator$toP = recordTranslator.toPhysical(row, column),\n        _recordTranslator$toP2 = _slicedToArray(_recordTranslator$toP, 2),\n        physicalRow = _recordTranslator$toP2[0],\n        physicalColumn = _recordTranslator$toP2[1];\n\n    var cachedValue = priv.cellSettings[physicalRow][physicalColumn][key];\n    var hookResult = instance.runHooks('beforeRemoveCellMeta', row, column, key, cachedValue);\n\n    if (hookResult !== false) {\n      delete priv.cellSettings[physicalRow][physicalColumn][key];\n      instance.runHooks('afterRemoveCellMeta', row, column, key, cachedValue);\n    }\n\n    cachedValue = null;\n  };\n  /**\n   * Remove one or more rows from the cell meta object.\n   *\n   * @since 0.30.0\n   * @param {Number} index An integer that specifies at what position to add/remove items, Use negative values to specify the position from the end of the array.\n   * @param {Number} deleteAmount The number of items to be removed. If set to 0, no items will be removed.\n   * @param {Array} items The new items to be added to the array.\n   */\n\n\n  this.spliceCellsMeta = function (index, deleteAmount) {\n    var _priv$cellSettings;\n\n    for (var _len4 = arguments.length, items = new Array(_len4 > 2 ? _len4 - 2 : 0), _key3 = 2; _key3 < _len4; _key3++) {\n      items[_key3 - 2] = arguments[_key3];\n    }\n\n    (_priv$cellSettings = priv.cellSettings).splice.apply(_priv$cellSettings, [index, deleteAmount].concat(items));\n  };\n  /**\n   * Set cell meta data object defined by `prop` to the corresponding params `row` and `column`.\n   *\n   * @memberof Core#\n   * @function setCellMetaObject\n   * @param {Number} row Visual row index.\n   * @param {Number} column Visual column index.\n   * @param {Object} prop Meta object.\n   */\n\n\n  this.setCellMetaObject = function (row, column, prop) {\n    var _this4 = this;\n\n    if (_typeof(prop) === 'object') {\n      objectEach(prop, function (value, key) {\n        _this4.setCellMeta(row, column, key, value);\n      });\n    }\n  };\n  /**\n   * Sets a property defined by the `key` property to the meta object of a cell corresponding to params `row` and `column`.\n   *\n   * @memberof Core#\n   * @function setCellMeta\n   * @param {Number} row Visual row index.\n   * @param {Number} column Visual column index.\n   * @param {String} key Property name.\n   * @param {String} value Property value.\n   * @fires Hooks#afterSetCellMeta\n   */\n\n\n  this.setCellMeta = function (row, column, key, value) {\n    var _recordTranslator$toP3 = recordTranslator.toPhysical(row, column),\n        _recordTranslator$toP4 = _slicedToArray(_recordTranslator$toP3, 2),\n        physicalRow = _recordTranslator$toP4[0],\n        physicalColumn = _recordTranslator$toP4[1];\n\n    if (!priv.columnSettings[physicalColumn]) {\n      priv.columnSettings[physicalColumn] = columnFactory(GridSettings, priv.columnsSettingConflicts);\n    }\n\n    if (!priv.cellSettings[physicalRow]) {\n      priv.cellSettings[physicalRow] = [];\n    }\n\n    if (!priv.cellSettings[physicalRow][physicalColumn]) {\n      priv.cellSettings[physicalRow][physicalColumn] = new priv.columnSettings[physicalColumn]();\n    }\n\n    priv.cellSettings[physicalRow][physicalColumn][key] = value;\n    instance.runHooks('afterSetCellMeta', row, column, key, value);\n  };\n  /**\n   * Get all the cells meta settings at least once generated in the table (in order of cell initialization).\n   *\n   * @memberof Core#\n   * @function getCellsMeta\n   * @returns {Array} Returns an array of ColumnSettings object instances.\n   */\n\n\n  this.getCellsMeta = function () {\n    return arrayFlatten(priv.cellSettings);\n  };\n  /**\n   * Returns the cell properties object for the given `row` and `column` coordinates.\n   *\n   * @memberof Core#\n   * @function getCellMeta\n   * @param {Number} row Visual row index.\n   * @param {Number} column Visual column index.\n   * @returns {Object} The cell properties object.\n   * @fires Hooks#beforeGetCellMeta\n   * @fires Hooks#afterGetCellMeta\n   */\n\n\n  this.getCellMeta = function (row, column) {\n    var prop = datamap.colToProp(column);\n\n    var _recordTranslator$toP5 = recordTranslator.toPhysical(row, column),\n        _recordTranslator$toP6 = _slicedToArray(_recordTranslator$toP5, 2),\n        potentialPhysicalRow = _recordTranslator$toP6[0],\n        physicalColumn = _recordTranslator$toP6[1];\n\n    var physicalRow = potentialPhysicalRow; // Workaround for #11. Connected also with #3849. It should be fixed within #4497.\n\n    if (physicalRow === null) {\n      physicalRow = row;\n    }\n\n    if (!priv.columnSettings[physicalColumn]) {\n      priv.columnSettings[physicalColumn] = columnFactory(GridSettings, priv.columnsSettingConflicts);\n    }\n\n    if (!priv.cellSettings[physicalRow]) {\n      priv.cellSettings[physicalRow] = [];\n    }\n\n    if (!priv.cellSettings[physicalRow][physicalColumn]) {\n      priv.cellSettings[physicalRow][physicalColumn] = new priv.columnSettings[physicalColumn]();\n    }\n\n    var cellProperties = priv.cellSettings[physicalRow][physicalColumn]; // retrieve cellProperties from cache\n\n    cellProperties.row = physicalRow;\n    cellProperties.col = physicalColumn;\n    cellProperties.visualRow = row;\n    cellProperties.visualCol = column;\n    cellProperties.prop = prop;\n    cellProperties.instance = instance;\n    instance.runHooks('beforeGetCellMeta', row, column, cellProperties);\n    extend(cellProperties, expandType(cellProperties)); // for `type` added in beforeGetCellMeta\n\n    if (cellProperties.cells) {\n      var settings = cellProperties.cells.call(cellProperties, physicalRow, physicalColumn, prop);\n\n      if (settings) {\n        extend(cellProperties, settings);\n        extend(cellProperties, expandType(settings)); // for `type` added in cells\n      }\n    }\n\n    instance.runHooks('afterGetCellMeta', row, column, cellProperties);\n    return cellProperties;\n  };\n  /**\n   * Returns an array of cell meta objects for specyfied physical row index.\n   *\n   * @memberof Core#\n   * @function getCellMetaAtRow\n   * @param {Number} row Physical row index.\n   * @returns {Array}\n   */\n\n\n  this.getCellMetaAtRow = function (row) {\n    return priv.cellSettings[row];\n  };\n  /**\n   * Checks if the data format and config allows user to modify the column structure.\n   *\n   * @memberof Core#\n   * @function isColumnModificationAllowed\n   * @returns {Boolean}\n   */\n\n\n  this.isColumnModificationAllowed = function () {\n    return !(instance.dataType === 'object' || instance.getSettings().columns);\n  };\n\n  var rendererLookup = cellMethodLookupFactory('renderer');\n  /**\n   * Returns the cell renderer function by given `row` and `column` arguments.\n   *\n   * @memberof Core#\n   * @function getCellRenderer\n   * @param {Number|Object} row Visual row index or cell meta object (see {@link Core#getCellMeta}).\n   * @param {Number} column Visual column index.\n   * @returns {Function} The renderer function.\n   * @example\n   * ```js\n   * // Get cell renderer using `row` and `column` coordinates.\n   * hot.getCellRenderer(1, 1);\n   * // Get cell renderer using cell meta object.\n   * hot.getCellRenderer(hot.getCellMeta(1, 1));\n   * ```\n   */\n\n  this.getCellRenderer = function (row, column) {\n    return getRenderer(rendererLookup.call(this, row, column));\n  };\n  /**\n   * Returns the cell editor class by the provided `row` and `column` arguments.\n   *\n   * @memberof Core#\n   * @function getCellEditor\n   * @param {Number} row Visual row index or cell meta object (see {@link Core#getCellMeta}).\n   * @param {Number} column Visual column index.\n   * @returns {Function} The editor class.\n   * @example\n   * ```js\n   * // Get cell editor class using `row` and `column` coordinates.\n   * hot.getCellEditor(1, 1);\n   * // Get cell editor class using cell meta object.\n   * hot.getCellEditor(hot.getCellMeta(1, 1));\n   * ```\n   */\n\n\n  this.getCellEditor = cellMethodLookupFactory('editor');\n  var validatorLookup = cellMethodLookupFactory('validator');\n  /**\n   * Returns the cell validator by `row` and `column`.\n   *\n   * @memberof Core#\n   * @function getCellValidator\n   * @param {Number|Object} row Visual row index or cell meta object (see {@link Core#getCellMeta}).\n   * @param {Number} column Visual column index.\n   * @returns {Function|RegExp|undefined} The validator function.\n   * @example\n   * ```js\n   * // Get cell valiator using `row` and `column` coordinates.\n   * hot.getCellValidator(1, 1);\n   * // Get cell valiator using cell meta object.\n   * hot.getCellValidator(hot.getCellMeta(1, 1));\n   * ```\n   */\n\n  this.getCellValidator = function (row, column) {\n    var validator = validatorLookup.call(this, row, column);\n\n    if (typeof validator === 'string') {\n      validator = getValidator(validator);\n    }\n\n    return validator;\n  };\n  /**\n   * Validates all cells using their validator functions and calls callback when finished.\n   *\n   * If one of the cells is invalid, the callback will be fired with `'valid'` arguments as `false` - otherwise it\n   * would equal `true`.\n   *\n   * @memberof Core#\n   * @function validateCells\n   * @param {Function} [callback] The callback function.\n   * @example\n   * ```js\n   * hot.validateCells((valid) => {\n   *   if (valid) {\n   *     // ... code for validated cells\n   *   }\n   * })\n   * ```\n   */\n\n\n  this.validateCells = function (callback) {\n    this._validateCells(callback);\n  };\n  /**\n   * Validates rows using their validator functions and calls callback when finished.\n   *\n   * If one of the cells is invalid, the callback will be fired with `'valid'` arguments as `false` - otherwise it\n   *  would equal `true`.\n   *\n   * @memberof Core#\n   * @function validateRows\n   * @param {Array} [rows] Array of validation target visual row indexes.\n   * @param {Function} [callback] The callback function.\n   * @example\n   * ```js\n   * hot.validateRows([3, 4, 5], (valid) => {\n   *   if (valid) {\n   *     // ... code for validated rows\n   *   }\n   * })\n   * ```\n   */\n\n\n  this.validateRows = function (rows, callback) {\n    if (!Array.isArray(rows)) {\n      throw new Error('validateRows parameter `rows` must be an array');\n    }\n\n    this._validateCells(callback, rows);\n  };\n  /**\n   * Validates columns using their validator functions and calls callback when finished.\n   *\n   * If one of the cells is invalid, the callback will be fired with `'valid'` arguments as `false` - otherwise it\n   *  would equal `true`.\n   *\n   * @memberof Core#\n   * @function validateColumns\n   * @param {Array} [columns] Array of validation target visual columns indexes.\n   * @param {Function} [callback] The callback function.\n   * @example\n   * ```js\n   * hot.validateColumns([3, 4, 5], (valid) => {\n   *   if (valid) {\n   *     // ... code for validated columns\n   *   }\n   * })\n   * ```\n   */\n\n\n  this.validateColumns = function (columns, callback) {\n    if (!Array.isArray(columns)) {\n      throw new Error('validateColumns parameter `columns` must be an array');\n    }\n\n    this._validateCells(callback, undefined, columns);\n  };\n  /**\n   * Validates all cells using their validator functions and calls callback when finished.\n   *\n   * If one of the cells is invalid, the callback will be fired with `'valid'` arguments as `false` - otherwise it would equal `true`.\n   *\n   * Private use intended.\n   *\n   * @private\n   * @memberof Core#\n   * @function _validateCells\n   * @param {Function} [callback] The callback function.\n   * @param {Array} [rows] An array of validation target visual row indexes.\n   * @param {Array} [columns] An array of validation target visual column indexes.\n   */\n\n\n  this._validateCells = function (callback, rows, columns) {\n    var waitingForValidator = new ValidatorsQueue();\n\n    if (callback) {\n      waitingForValidator.onQueueEmpty = callback;\n    }\n\n    var i = instance.countRows() - 1;\n\n    while (i >= 0) {\n      if (rows !== undefined && rows.indexOf(i) === -1) {\n        i -= 1;\n        continue;\n      }\n\n      var j = instance.countCols() - 1;\n\n      while (j >= 0) {\n        if (columns !== undefined && columns.indexOf(j) === -1) {\n          j -= 1;\n          continue;\n        }\n\n        waitingForValidator.addValidatorToQueue();\n        instance.validateCell(instance.getDataAtCell(i, j), instance.getCellMeta(i, j), function (result) {\n          if (typeof result !== 'boolean') {\n            throw new Error('Validation error: result is not boolean');\n          }\n\n          if (result === false) {\n            waitingForValidator.valid = false;\n          }\n\n          waitingForValidator.removeValidatorFormQueue();\n        }, 'validateCells');\n        j -= 1;\n      }\n\n      i -= 1;\n    }\n\n    waitingForValidator.checkIfQueueIsEmpty();\n  };\n  /**\n   * Returns an array of row headers' values (if they are enabled). If param `row` was given, it returns the header of the given row as a string.\n   *\n   * @memberof Core#\n   * @function getRowHeader\n   * @param {Number} [row] Visual row index.\n   * @fires Hooks#modifyRowHeader\n   * @returns {Array|String|Number} Array of header values / single header value.\n   */\n\n\n  this.getRowHeader = function (row) {\n    var rowHeader = priv.settings.rowHeaders;\n    var physicalRow = row;\n\n    if (physicalRow !== void 0) {\n      physicalRow = instance.runHooks('modifyRowHeader', physicalRow);\n    }\n\n    if (physicalRow === void 0) {\n      rowHeader = [];\n      rangeEach(instance.countRows() - 1, function (i) {\n        rowHeader.push(instance.getRowHeader(i));\n      });\n    } else if (Array.isArray(rowHeader) && rowHeader[physicalRow] !== void 0) {\n      rowHeader = rowHeader[physicalRow];\n    } else if (isFunction(rowHeader)) {\n      rowHeader = rowHeader(physicalRow);\n    } else if (rowHeader && typeof rowHeader !== 'string' && typeof rowHeader !== 'number') {\n      rowHeader = physicalRow + 1;\n    }\n\n    return rowHeader;\n  };\n  /**\n   * Returns information about if this table is configured to display row headers.\n   *\n   * @memberof Core#\n   * @function hasRowHeaders\n   * @returns {Boolean} `true` if the instance has the row headers enabled, `false` otherwise.\n   */\n\n\n  this.hasRowHeaders = function () {\n    return !!priv.settings.rowHeaders;\n  };\n  /**\n   * Returns information about if this table is configured to display column headers.\n   *\n   * @memberof Core#\n   * @function hasColHeaders\n   * @returns {Boolean} `true` if the instance has the column headers enabled, `false` otherwise.\n   */\n\n\n  this.hasColHeaders = function () {\n    if (priv.settings.colHeaders !== void 0 && priv.settings.colHeaders !== null) {\n      // Polymer has empty value = null\n      return !!priv.settings.colHeaders;\n    }\n\n    for (var i = 0, ilen = instance.countCols(); i < ilen; i++) {\n      if (instance.getColHeader(i)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Returns an array of column headers (in string format, if they are enabled). If param `column` is given, it\n   * returns the header at the given column.\n   *\n   * @memberof Core#\n   * @function getColHeader\n   * @param {Number} [column] Visual column index.\n   * @fires Hooks#modifyColHeader\n   * @returns {Array|String|Number} The column header(s).\n   */\n\n\n  this.getColHeader = function (column) {\n    var columnsAsFunc = priv.settings.columns && isFunction(priv.settings.columns);\n    var columnIndex = instance.runHooks('modifyColHeader', column);\n    var result = priv.settings.colHeaders;\n\n    if (columnIndex === void 0) {\n      var out = [];\n      var ilen = columnsAsFunc ? instance.countSourceCols() : instance.countCols();\n\n      for (var i = 0; i < ilen; i++) {\n        out.push(instance.getColHeader(i));\n      }\n\n      result = out;\n    } else {\n      var translateVisualIndexToColumns = function translateVisualIndexToColumns(visualColumnIndex) {\n        var arr = [];\n        var columnsLen = instance.countSourceCols();\n        var index = 0;\n\n        for (; index < columnsLen; index++) {\n          if (isFunction(instance.getSettings().columns) && instance.getSettings().columns(index)) {\n            arr.push(index);\n          }\n        }\n\n        return arr[visualColumnIndex];\n      };\n\n      var baseCol = columnIndex;\n      var physicalColumn = instance.runHooks('modifyCol', baseCol);\n      var prop = translateVisualIndexToColumns(physicalColumn);\n\n      if (priv.settings.colHeaders === false) {\n        result = null;\n      } else if (priv.settings.columns && isFunction(priv.settings.columns) && priv.settings.columns(prop) && priv.settings.columns(prop).title) {\n        result = priv.settings.columns(prop).title;\n      } else if (priv.settings.columns && priv.settings.columns[physicalColumn] && priv.settings.columns[physicalColumn].title) {\n        result = priv.settings.columns[physicalColumn].title;\n      } else if (Array.isArray(priv.settings.colHeaders) && priv.settings.colHeaders[physicalColumn] !== void 0) {\n        result = priv.settings.colHeaders[physicalColumn];\n      } else if (isFunction(priv.settings.colHeaders)) {\n        result = priv.settings.colHeaders(physicalColumn);\n      } else if (priv.settings.colHeaders && typeof priv.settings.colHeaders !== 'string' && typeof priv.settings.colHeaders !== 'number') {\n        result = spreadsheetColumnLabel(baseCol); // see #1458\n      }\n    }\n\n    return result;\n  };\n  /**\n   * Return column width from settings (no guessing). Private use intended.\n   *\n   * @private\n   * @memberof Core#\n   * @function _getColWidthFromSettings\n   * @param {Number} col Visual col index.\n   * @returns {Number}\n   */\n\n\n  this._getColWidthFromSettings = function (col) {\n    var cellProperties = instance.getCellMeta(0, col);\n    var width = cellProperties.width;\n\n    if (width === void 0 || width === priv.settings.width) {\n      width = cellProperties.colWidths;\n    }\n\n    if (width !== void 0 && width !== null) {\n      switch (_typeof(width)) {\n        case 'object':\n          // array\n          width = width[col];\n          break;\n\n        case 'function':\n          width = width(col);\n          break;\n\n        default:\n          break;\n      }\n\n      if (typeof width === 'string') {\n        width = parseInt(width, 10);\n      }\n    }\n\n    return width;\n  };\n  /**\n   * Returns the width of the requested column.\n   *\n   * @memberof Core#\n   * @function getColWidth\n   * @param {Number} column Visual column index.\n   * @returns {Number} Column width.\n   * @fires Hooks#modifyColWidth\n   */\n\n\n  this.getColWidth = function (column) {\n    var width = instance._getColWidthFromSettings(column);\n\n    width = instance.runHooks('modifyColWidth', width, column);\n\n    if (width === void 0) {\n      width = ViewportColumnsCalculator.DEFAULT_WIDTH;\n    }\n\n    return width;\n  };\n  /**\n   * Return row height from settings (no guessing). Private use intended.\n   *\n   * @private\n   * @memberof Core#\n   * @function _getRowHeightFromSettings\n   * @param {Number} row Visual row index.\n   * @returns {Number}\n   */\n\n\n  this._getRowHeightFromSettings = function (row) {\n    // let cellProperties = instance.getCellMeta(row, 0);\n    // let height = cellProperties.height;\n    //\n    // if (height === void 0 || height === priv.settings.height) {\n    //  height = cellProperties.rowHeights;\n    // }\n    var height = priv.settings.rowHeights;\n\n    if (height !== void 0 && height !== null) {\n      switch (_typeof(height)) {\n        case 'object':\n          // array\n          height = height[row];\n          break;\n\n        case 'function':\n          height = height(row);\n          break;\n\n        default:\n          break;\n      }\n\n      if (typeof height === 'string') {\n        height = parseInt(height, 10);\n      }\n    }\n\n    return height;\n  };\n  /**\n   * Returns the row height.\n   *\n   * @memberof Core#\n   * @function getRowHeight\n   * @param {Number} row Visual row index.\n   * @returns {Number} The given row's height.\n   * @fires Hooks#modifyRowHeight\n   */\n\n\n  this.getRowHeight = function (row) {\n    var height = instance._getRowHeightFromSettings(row);\n\n    height = instance.runHooks('modifyRowHeight', height, row);\n    return height;\n  };\n  /**\n   * Returns the total number of rows in the data source.\n   *\n   * @memberof Core#\n   * @function countSourceRows\n   * @returns {Number} Total number of rows.\n   */\n\n\n  this.countSourceRows = function () {\n    var sourceLength = instance.runHooks('modifySourceLength');\n    return sourceLength || (instance.getSourceData() ? instance.getSourceData().length : 0);\n  };\n  /**\n   * Returns the total number of columns in the data source.\n   *\n   * @memberof Core#\n   * @function countSourceCols\n   * @returns {Number} Total number of columns.\n   */\n\n\n  this.countSourceCols = function () {\n    var len = 0;\n    var obj = instance.getSourceData() && instance.getSourceData()[0] ? instance.getSourceData()[0] : [];\n\n    if (isObject(obj)) {\n      len = deepObjectSize(obj);\n    } else {\n      len = obj.length || 0;\n    }\n\n    return len;\n  };\n  /**\n   * Returns the total number of visual rows in the table.\n   *\n   * @memberof Core#\n   * @function countRows\n   * @returns {Number} Total number of rows.\n   */\n\n\n  this.countRows = function () {\n    return datamap.getLength();\n  };\n  /**\n   * Returns the total number of visible columns in the table.\n   *\n   * @memberof Core#\n   * @function countCols\n   * @returns {Number} Total number of columns.\n   */\n\n\n  this.countCols = function () {\n    var maxCols = this.getSettings().maxCols;\n    var dataHasLength = false;\n    var dataLen = 0;\n\n    if (instance.dataType === 'array') {\n      dataHasLength = priv.settings.data && priv.settings.data[0] && priv.settings.data[0].length;\n    }\n\n    if (dataHasLength) {\n      dataLen = priv.settings.data[0].length;\n    }\n\n    if (priv.settings.columns) {\n      var columnsIsFunction = isFunction(priv.settings.columns);\n\n      if (columnsIsFunction) {\n        if (instance.dataType === 'array') {\n          var columnLen = 0;\n\n          for (var i = 0; i < dataLen; i++) {\n            if (priv.settings.columns(i)) {\n              columnLen += 1;\n            }\n          }\n\n          dataLen = columnLen;\n        } else if (instance.dataType === 'object' || instance.dataType === 'function') {\n          dataLen = datamap.colToPropCache.length;\n        }\n      } else {\n        dataLen = priv.settings.columns.length;\n      }\n    } else if (instance.dataType === 'object' || instance.dataType === 'function') {\n      dataLen = datamap.colToPropCache.length;\n    }\n\n    return Math.min(maxCols, dataLen);\n  };\n  /**\n   * Returns an visual index of the first rendered row.\n   * Returns -1 if no row is rendered.\n   *\n   * @memberof Core#\n   * @function rowOffset\n   * @returns {Number} Visual index of first rendered row.\n   */\n\n\n  this.rowOffset = function () {\n    return instance.view.wt.wtTable.getFirstRenderedRow();\n  };\n  /**\n   * Returns the visual index of the first rendered column.\n   * Returns -1 if no column is rendered.\n   *\n   * @memberof Core#\n   * @function colOffset\n   * @returns {Number} Visual index of the first visible column.\n   */\n\n\n  this.colOffset = function () {\n    return instance.view.wt.wtTable.getFirstRenderedColumn();\n  };\n  /**\n   * Returns the number of rendered rows (including rows partially or fully rendered outside viewport).\n   *\n   * @memberof Core#\n   * @function countRenderedRows\n   * @returns {Number} Returns -1 if table is not visible.\n   */\n\n\n  this.countRenderedRows = function () {\n    return instance.view.wt.drawn ? instance.view.wt.wtTable.getRenderedRowsCount() : -1;\n  };\n  /**\n   * Returns the number of visible rows (rendered rows that fully fit inside viewport).\n   *\n   * @memberof Core#\n   * @function countVisibleRows\n   * @returns {Number} Number of visible rows or -1.\n   */\n\n\n  this.countVisibleRows = function () {\n    return instance.view.wt.drawn ? instance.view.wt.wtTable.getVisibleRowsCount() : -1;\n  };\n  /**\n   * Returns the number of rendered columns (including columns partially or fully rendered outside viewport).\n   *\n   * @memberof Core#\n   * @function countRenderedCols\n   * @returns {Number} Returns -1 if table is not visible.\n   */\n\n\n  this.countRenderedCols = function () {\n    return instance.view.wt.drawn ? instance.view.wt.wtTable.getRenderedColumnsCount() : -1;\n  };\n  /**\n   * Returns the number of visible columns. Returns -1 if table is not visible\n   *\n   * @memberof Core#\n   * @function countVisibleCols\n   * @return {Number} Number of visible columns or -1.\n   */\n\n\n  this.countVisibleCols = function () {\n    return instance.view.wt.drawn ? instance.view.wt.wtTable.getVisibleColumnsCount() : -1;\n  };\n  /**\n   * Returns the number of empty rows. If the optional ending parameter is `true`, returns the\n   * number of empty rows at the bottom of the table.\n   *\n   * @memberof Core#\n   * @function countEmptyRows\n   * @param {Boolean} [ending=false] If `true`, will only count empty rows at the end of the data source.\n   * @returns {Number} Count empty rows.\n   */\n\n\n  this.countEmptyRows = function () {\n    var ending = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var emptyRows = 0;\n    rangeEachReverse(instance.countRows() - 1, function (visualIndex) {\n      if (instance.isEmptyRow(visualIndex)) {\n        emptyRows += 1;\n      } else if (ending === true) {\n        return false;\n      }\n    });\n    return emptyRows;\n  };\n  /**\n   * Returns the number of empty columns. If the optional ending parameter is `true`, returns the number of empty\n   * columns at right hand edge of the table.\n   *\n   * @memberof Core#\n   * @function countEmptyCols\n   * @param {Boolean} [ending=false] If `true`, will only count empty columns at the end of the data source row.\n   * @returns {Number} Count empty cols.\n   */\n\n\n  this.countEmptyCols = function () {\n    var ending = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    if (instance.countRows() < 1) {\n      return 0;\n    }\n\n    var emptyColumns = 0;\n    rangeEachReverse(instance.countCols() - 1, function (visualIndex) {\n      if (instance.isEmptyCol(visualIndex)) {\n        emptyColumns += 1;\n      } else if (ending === true) {\n        return false;\n      }\n    });\n    return emptyColumns;\n  };\n  /**\n   * Check if all cells in the row declared by the `row` argument are empty.\n   *\n   * @memberof Core#\n   * @function isEmptyRow\n   * @param {Number} row Visual row index.\n   * @returns {Boolean} `true` if the row at the given `row` is empty, `false` otherwise.\n   */\n\n\n  this.isEmptyRow = function (row) {\n    return priv.settings.isEmptyRow.call(instance, row);\n  };\n  /**\n   * Check if all cells in the the column declared by the `column` argument are empty.\n   *\n   * @memberof Core#\n   * @function isEmptyCol\n   * @param {Number} column Column index.\n   * @returns {Boolean} `true` if the column at the given `col` is empty, `false` otherwise.\n   */\n\n\n  this.isEmptyCol = function (column) {\n    return priv.settings.isEmptyCol.call(instance, column);\n  };\n  /**\n   * Select cell specified by `row` and `column` values or a range of cells finishing at `endRow`, `endCol`. If the table\n   * was configured to support data column properties that properties can be used to making a selection.\n   *\n   * By default, viewport will be scrolled to the selection. After the `selectCell` method had finished, the instance\n   * will be listening to keyboard input on the document.\n   *\n   * @example\n   * ```js\n   * // select a single cell\n   * hot.selectCell(2, 4);\n   * // select a single cell using column property\n   * hot.selectCell(2, 'address');\n   * // select a range of cells\n   * hot.selectCell(2, 4, 3, 5);\n   * // select a range of cells using column properties\n   * hot.selectCell(2, 'address', 3, 'phone_number');\n   * // select a range of cells without scrolling to them\n   * hot.selectCell(2, 'address', 3, 'phone_number', false);\n   * ```\n   *\n   * @memberof Core#\n   * @function selectCell\n   * @param {Number} row Visual row index.\n   * @param {Number|String} column Visual column index or column property.\n   * @param {Number} [endRow] Visual end row index (if selecting a range).\n   * @param {Number|String} [endColumn] Visual end column index or column property (if selecting a range).\n   * @param {Boolean} [scrollToCell=true] If `true`, the viewport will be scrolled to the selection.\n   * @param {Boolean} [changeListener=true] If `false`, Handsontable will not change keyboard events listener to himself.\n   * @returns {Boolean} `true` if selection was successful, `false` otherwise.\n   */\n\n\n  this.selectCell = function (row, column, endRow, endColumn) {\n    var scrollToCell = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    var changeListener = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n\n    if (isUndefined(row) || isUndefined(column)) {\n      return false;\n    }\n\n    return this.selectCells([[row, column, endRow, endColumn]], scrollToCell, changeListener);\n  };\n  /**\n   * Make multiple, non-contiguous selection specified by `row` and `column` values or a range of cells\n   * finishing at `endRow`, `endColumn`. The method supports two input formats which are the same as that\n   * produces by `getSelected` and `getSelectedRange` methods.\n   *\n   * By default, viewport will be scrolled to selection. After the `selectCells` method had finished, the instance\n   * will be listening to keyboard input on the document.\n   *\n   * @example\n   * ```js\n   * // Using an array of arrays.\n   * hot.selectCells([[1, 1, 2, 2], [3, 3], [6, 2, 0, 2]]);\n   * // Using an array of arrays with defined columns as props.\n   * hot.selectCells([[1, 'id', 2, 'first_name'], [3, 'full_name'], [6, 'last_name', 0, 'first_name']]);\n   * // Using an array of CellRange objects (produced by `.getSelectedRange()` method).\n   * const selected = hot.getSelectedRange();\n   *\n   * selected[0].from.row = 0;\n   * selected[0].from.col = 0;\n   *\n   * hot.selectCells(selected);\n   * ```\n   *\n   * @memberof Core#\n   * @since 0.38.0\n   * @function selectCells\n   * @param {Array[]|CellRange[]} coords Visual coords passed as an array of array (`[[rowStart, columnStart, rowEnd, columnEnd], ...]`)\n   *                                     the same format as `getSelected` method returns or as an CellRange objects\n   *                                     which is the same format what `getSelectedRange` method returns.\n   * @param {Boolean} [scrollToCell=true] If `true`, the viewport will be scrolled to the selection.\n   * @param {Boolean} [changeListener=true] If `false`, Handsontable will not change keyboard events listener to himself.\n   * @returns {Boolean} `true` if selection was successful, `false` otherwise.\n   */\n\n\n  this.selectCells = function () {\n    var coords = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [[]];\n    var scrollToCell = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var changeListener = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n    if (scrollToCell === false) {\n      preventScrollingToCell = true;\n    }\n\n    var wasSelected = selection.selectCells(coords);\n\n    if (wasSelected && changeListener) {\n      instance.listen();\n    }\n\n    preventScrollingToCell = false;\n    return wasSelected;\n  };\n  /**\n   * Select column specified by `startColumn` visual index, column property or a range of columns finishing at `endColumn`.\n   *\n   * @example\n   * ```js\n   * // Select column using visual index.\n   * hot.selectColumns(1);\n   * // Select column using column property.\n   * hot.selectColumns('id');\n   * // Select range of columns using visual indexes.\n   * hot.selectColumns(1, 4);\n   * // Select range of columns using column properties.\n   * hot.selectColumns('id', 'last_name');\n   * ```\n   *\n   * @memberof Core#\n   * @since 0.38.0\n   * @function selectColumns\n   * @param {Number} startColumn The visual column index from which the selection starts.\n   * @param {Number} [endColumn=startColumn] The visual column index to which the selection finishes. If `endColumn`\n   *                                         is not defined the column defined by `startColumn` will be selected.\n   * @returns {Boolean} `true` if selection was successful, `false` otherwise.\n   */\n\n\n  this.selectColumns = function (startColumn) {\n    var endColumn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startColumn;\n    return selection.selectColumns(startColumn, endColumn);\n  };\n  /**\n   * Select row specified by `startRow` visual index or a range of rows finishing at `endRow`.\n   *\n   * @example\n   * ```js\n   * // Select row using visual index.\n   * hot.selectRows(1);\n   * // Select range of rows using visual indexes.\n   * hot.selectRows(1, 4);\n   * ```\n   *\n   * @memberof Core#\n   * @since 0.38.0\n   * @function selectRows\n   * @param {Number} startRow The visual row index from which the selection starts.\n   * @param {Number} [endRow=startRow] The visual row index to which the selection finishes. If `endRow`\n   *                                   is not defined the row defined by `startRow` will be selected.\n   * @returns {Boolean} `true` if selection was successful, `false` otherwise.\n   */\n\n\n  this.selectRows = function (startRow) {\n    var endRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startRow;\n    return selection.selectRows(startRow, endRow);\n  };\n  /**\n   * Deselects the current cell selection on the table.\n   *\n   * @memberof Core#\n   * @function deselectCell\n   */\n\n\n  this.deselectCell = function () {\n    selection.deselect();\n  };\n  /**\n   * Select the whole table. The previous selection will be overwritten.\n   *\n   * @since 0.38.2\n   * @memberof Core#\n   * @function selectAll\n   */\n\n\n  this.selectAll = function () {\n    preventScrollingToCell = true;\n    selection.selectAll();\n    preventScrollingToCell = false;\n  };\n  /**\n   * Scroll viewport to coordinates specified by the `row` and `column` arguments.\n   *\n   * @memberof Core#\n   * @function scrollViewportTo\n   * @param {Number} [row] Visual row index.\n   * @param {Number} [column] Visual column index.\n   * @param {Boolean} [snapToBottom = false] If `true`, viewport is scrolled to show the cell on the bottom of the table.\n   * @param {Boolean} [snapToRight = false] If `true`, viewport is scrolled to show the cell on the right side of the table.\n   * @returns {Boolean} `true` if scroll was successful, `false` otherwise.\n   */\n\n\n  this.scrollViewportTo = function (row, column) {\n    var snapToBottom = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var snapToRight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var snapToTop = !snapToBottom;\n    var snapToLeft = !snapToRight;\n    var result = false;\n\n    if (row !== void 0 && column !== void 0) {\n      result = instance.view.scrollViewport(new CellCoords(row, column), snapToTop, snapToRight, snapToBottom, snapToLeft);\n    }\n\n    if (typeof row === 'number' && typeof column !== 'number') {\n      result = instance.view.scrollViewportVertically(row, snapToTop, snapToBottom);\n    }\n\n    if (typeof column === 'number' && typeof row !== 'number') {\n      result = instance.view.scrollViewportHorizontally(column, snapToRight, snapToLeft);\n    }\n\n    return result;\n  };\n  /**\n   * Removes the table from the DOM and destroys the instance of the Handsontable.\n   *\n   * @memberof Core#\n   * @function destroy\n   * @fires Hooks#afterDestroy\n   */\n\n\n  this.destroy = function () {\n    instance._clearTimeouts();\n\n    instance._clearImmediates();\n\n    if (instance.view) {\n      // in case HT is destroyed before initialization has finished\n      instance.view.destroy();\n    }\n\n    if (dataSource) {\n      dataSource.destroy();\n    }\n\n    dataSource = null;\n    keyStateStopObserving();\n\n    if (isRootInstance(instance)) {\n      var licenseInfo = this.rootDocument.querySelector('#hot-display-license-info');\n\n      if (licenseInfo) {\n        licenseInfo.parentNode.removeChild(licenseInfo);\n      }\n    }\n\n    empty(instance.rootElement);\n    eventManager.destroy();\n\n    if (editorManager) {\n      editorManager.destroy();\n    }\n\n    instance.runHooks('afterDestroy');\n    Hooks.getSingleton().destroy(instance);\n    objectEach(instance, function (property, key, obj) {\n      // replace instance methods with post mortem\n      if (isFunction(property)) {\n        obj[key] = postMortem(key);\n      } else if (key !== 'guid') {\n        // replace instance properties with null (restores memory)\n        // it should not be necessary but this prevents a memory leak side effects that show itself in Jasmine tests\n        obj[key] = null;\n      }\n    });\n    instance.isDestroyed = true; // replace private properties with null (restores memory)\n    // it should not be necessary but this prevents a memory leak side effects that show itself in Jasmine tests\n\n    if (datamap) {\n      datamap.destroy();\n    }\n\n    datamap = null;\n    priv = null;\n    grid = null;\n    selection = null;\n    editorManager = null;\n    instance = null;\n    GridSettings = null;\n  };\n  /**\n   * Replacement for all methods after Handsotnable was destroyed.\n   *\n   * @private\n   */\n\n\n  function postMortem(method) {\n    return function () {\n      throw new Error(\"The \\\"\".concat(method, \"\\\" method cannot be called because this Handsontable instance has been destroyed\"));\n    };\n  }\n  /**\n   * Returns the active editor class instance.\n   *\n   * @memberof Core#\n   * @function getActiveEditor\n   * @returns {BaseEditor} The active editor instance.\n   */\n\n\n  this.getActiveEditor = function () {\n    return editorManager.getActiveEditor();\n  };\n  /**\n   * Returns plugin instance by provided its name.\n   *\n   * @memberof Core#\n   * @function getPlugin\n   * @param {String} pluginName The plugin name.\n   * @returns {BasePlugin} The plugin instance.\n   */\n\n\n  this.getPlugin = function (pluginName) {\n    return getPlugin(this, pluginName);\n  };\n  /**\n   * Returns the Handsontable instance.\n   *\n   * @memberof Core#\n   * @function getInstance\n   * @returns {Handsontable} The Handsontable instance.\n   */\n\n\n  this.getInstance = function () {\n    return instance;\n  };\n  /**\n   * Adds listener to the specified hook name (only for this Handsontable instance).\n   *\n   * @memberof Core#\n   * @function addHook\n   * @see Hooks#add\n   * @param {String} key Hook name (see {@link Hooks}).\n   * @param {Function|Array} callback Function or array of functions.\n   * @example\n   * ```js\n   * hot.addHook('beforeInit', myCallback);\n   * ```\n   */\n\n\n  this.addHook = function (key, callback) {\n    Hooks.getSingleton().add(key, callback, instance);\n  };\n  /**\n   * Check if for a specified hook name there are added listeners (only for this Handsontable instance). All available\n   * hooks you will find {@link Hooks}.\n   *\n   * @memberof Core#\n   * @function hasHook\n   * @see Hooks#has\n   * @param {String} key Hook name\n   * @return {Boolean}\n   *\n   * @example\n   * ```js\n   * const hasBeforeInitListeners = hot.hasHook('beforeInit');\n   * ```\n   */\n\n\n  this.hasHook = function (key) {\n    return Hooks.getSingleton().has(key, instance);\n  };\n  /**\n   * Adds listener to specified hook name (only for this Handsontable instance). After the listener is triggered,\n   * it will be automatically removed.\n   *\n   * @memberof Core#\n   * @function addHookOnce\n   * @see Hooks#once\n   * @param {String} key Hook name (see {@link Hooks}).\n   * @param {Function|Array} callback Function or array of functions.\n   * @example\n   * ```js\n   * hot.addHookOnce('beforeInit', myCallback);\n   * ```\n   */\n\n\n  this.addHookOnce = function (key, callback) {\n    Hooks.getSingleton().once(key, callback, instance);\n  };\n  /**\n   * Removes the hook listener previously registered with {@link Core#addHook}.\n   *\n   * @memberof Core#\n   * @function removeHook\n   * @see Hooks#remove\n   * @param {String} key Hook name.\n   * @param {Function} callback Reference to the function which has been registered using {@link Core#addHook}.\n   *\n   * @example\n   * ```js\n   * hot.removeHook('beforeInit', myCallback);\n   * ```\n   */\n\n\n  this.removeHook = function (key, callback) {\n    Hooks.getSingleton().remove(key, callback, instance);\n  };\n  /**\n   * Run the callbacks for the hook provided in the `key` argument using the parameters given in the other arguments.\n   *\n   * @memberof Core#\n   * @function runHooks\n   * @see Hooks#run\n   * @param {String} key Hook name.\n   * @param {*} [p1] Argument passed to the callback.\n   * @param {*} [p2] Argument passed to the callback.\n   * @param {*} [p3] Argument passed to the callback.\n   * @param {*} [p4] Argument passed to the callback.\n   * @param {*} [p5] Argument passed to the callback.\n   * @param {*} [p6] Argument passed to the callback.\n   * @returns {*}\n   *\n   * @example\n   * ```js\n   * // Run built-in hook\n   * hot.runHooks('beforeInit');\n   * // Run custom hook\n   * hot.runHooks('customAction', 10, 'foo');\n   * ```\n   */\n\n\n  this.runHooks = function (key, p1, p2, p3, p4, p5, p6) {\n    return Hooks.getSingleton().run(instance, key, p1, p2, p3, p4, p5, p6);\n  };\n  /**\n   * Get language phrase for specified dictionary key.\n   *\n   * @memberof Core#\n   * @function getTranslatedPhrase\n   * @since 0.35.0\n   * @param {String} dictionaryKey Constant which is dictionary key.\n   * @param {*} extraArguments Arguments which will be handled by formatters.\n   * @returns {String}\n   */\n\n\n  this.getTranslatedPhrase = function (dictionaryKey, extraArguments) {\n    return getTranslatedPhrase(priv.settings.language, dictionaryKey, extraArguments);\n  };\n  /**\n   * Converts instance into outerHTML of HTMLTableElement.\n   *\n   * @memberof Core#\n   * @function toHTML\n   * @since 7.1.0\n   * @returns {String}\n   */\n\n\n  this.toHTML = function () {\n    return instanceToHTML(_this);\n  };\n  /**\n   * Converts instance into HTMLTableElement.\n   *\n   * @memberof Core#\n   * @function toTableElement\n   * @since 7.1.0\n   * @returns {HTMLTableElement}\n   */\n\n\n  this.toTableElement = function () {\n    var tempElement = _this.rootDocument.createElement('div');\n\n    tempElement.insertAdjacentHTML('afterbegin', instanceToHTML(_this));\n    return tempElement.firstElementChild;\n  };\n\n  this.timeouts = [];\n  /**\n   * Sets timeout. Purpose of this method is to clear all known timeouts when `destroy` method is called.\n   *\n   * @param {Number|Function} handle Handler returned from setTimeout or function to execute (it will be automatically wraped\n   *                                 by setTimeout function).\n   * @param {Number} [delay=0] If first argument is passed as a function this argument set delay of the execution of that function.\n   * @private\n   */\n\n  this._registerTimeout = function (handle) {\n    var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var handleFunc = handle;\n\n    if (typeof handleFunc === 'function') {\n      handleFunc = setTimeout(handleFunc, delay);\n    }\n\n    this.timeouts.push(handleFunc);\n  };\n  /**\n   * Clears all known timeouts.\n   *\n   * @private\n   */\n\n\n  this._clearTimeouts = function () {\n    arrayEach(this.timeouts, function (handler) {\n      clearTimeout(handler);\n    });\n  };\n\n  this.immediates = [];\n  /**\n   * Execute function execution to the next event loop cycle. Purpose of this method is to clear all known timeouts when `destroy` method is called.\n   *\n   * @param {Function} callback Function to be delayed in execution.\n   * @private\n   */\n\n  this._registerImmediate = function (callback) {\n    this.immediates.push(setImmediate(callback));\n  };\n  /**\n   * Clears all known timeouts.\n   *\n   * @private\n   */\n\n\n  this._clearImmediates = function () {\n    arrayEach(this.immediates, function (handler) {\n      clearImmediate(handler);\n    });\n  };\n  /**\n   * Refresh selection borders. This is temporary method relic after selection rewrite.\n   *\n   * @private\n   * @param {Boolean} [revertOriginal=false] If `true`, the previous value will be restored. Otherwise, the edited value will be saved.\n   * @param {Boolean} [prepareEditorIfNeeded=true] If `true` the editor under the selected cell will be prepared to open.\n   */\n\n\n  this._refreshBorders = function () {\n    var revertOriginal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var prepareEditorIfNeeded = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    editorManager.destroyEditor(revertOriginal);\n    instance.view.render();\n\n    if (prepareEditorIfNeeded && selection.isSelected()) {\n      editorManager.prepareEditor();\n    }\n  };\n\n  Hooks.getSingleton().run(instance, 'construct');\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}