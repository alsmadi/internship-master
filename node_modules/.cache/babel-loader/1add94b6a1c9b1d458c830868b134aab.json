{"ast":null,"code":"function _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nimport { addClass, hasClass } from './../../../helpers/dom/element';\nimport Border from './border';\nimport CellCoords from './cell/coords';\nimport CellRange from './cell/range';\n/**\n * @class Selection\n */\n\nvar Selection = /*#__PURE__*/\nfunction () {\n  /**\n   * @param {Object} settings\n   * @param {CellRange} cellRange\n   */\n  function Selection(settings, cellRange) {\n    _classCallCheck(this, Selection);\n    this.settings = settings;\n    this.cellRange = cellRange || null;\n    this.instanceBorders = {};\n    this.classNames = [this.settings.className];\n    this.classNameGenerator = this.linearClassNameGenerator(this.settings.className, this.settings.layerLevel);\n  }\n  /**\n   * Each Walkontable clone requires it's own border for every selection. This method creates and returns selection\n   * borders per instance\n   *\n   * @param {Walkontable} wotInstance\n   * @returns {Border}\n   */\n\n  _createClass(Selection, [{\n    key: \"getBorder\",\n    value: function getBorder(wotInstance) {\n      if (!this.instanceBorders[wotInstance.guid]) {\n        this.instanceBorders[wotInstance.guid] = new Border(wotInstance, this.settings);\n      }\n      return this.instanceBorders[wotInstance.guid];\n    }\n    /**\n     * Checks if selection is empty\n     *\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this.cellRange === null;\n    }\n    /**\n     * Adds a cell coords to the selection\n     *\n     * @param {CellCoords} coords\n     */\n  }, {\n    key: \"add\",\n    value: function add(coords) {\n      if (this.isEmpty()) {\n        this.cellRange = new CellRange(coords);\n      } else {\n        this.cellRange.expand(coords);\n      }\n      return this;\n    }\n    /**\n     * If selection range from or to property equals oldCoords, replace it with newCoords. Return boolean\n     * information about success\n     *\n     * @param {CellCoords} oldCoords\n     * @param {CellCoords} newCoords\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"replace\",\n    value: function replace(oldCoords, newCoords) {\n      if (!this.isEmpty()) {\n        if (this.cellRange.from.isEqual(oldCoords)) {\n          this.cellRange.from = newCoords;\n          return true;\n        }\n        if (this.cellRange.to.isEqual(oldCoords)) {\n          this.cellRange.to = newCoords;\n          return true;\n        }\n      }\n      return false;\n    }\n    /**\n     * Clears selection\n     *\n     * @returns {Selection}\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.cellRange = null;\n      return this;\n    }\n    /**\n     * Returns the top left (TL) and bottom right (BR) selection coordinates\n     *\n     * @returns {Array} Returns array of coordinates for example `[1, 1, 5, 5]`\n     */\n  }, {\n    key: \"getCorners\",\n    value: function getCorners() {\n      var topLeft = this.cellRange.getTopLeftCorner();\n      var bottomRight = this.cellRange.getBottomRightCorner();\n      return [topLeft.row, topLeft.col, bottomRight.row, bottomRight.col];\n    }\n    /**\n     * Adds class name to cell element at given coords\n     *\n     * @param {Walkontable} wotInstance Walkontable instance\n     * @param {Number} sourceRow Cell row coord\n     * @param {Number} sourceColumn Cell column coord\n     * @param {String} className Class name\n     * @param {Boolean} [markIntersections=false] If `true`, linear className generator will be used to add CSS classes\n     *                                            in a continuous way.\n     * @returns {Selection}\n     */\n  }, {\n    key: \"addClassAtCoords\",\n    value: function addClassAtCoords(wotInstance, sourceRow, sourceColumn, className) {\n      var markIntersections = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      var TD = wotInstance.wtTable.getCell(new CellCoords(sourceRow, sourceColumn));\n      if (_typeof(TD) === 'object') {\n        var cellClassName = className;\n        if (markIntersections) {\n          cellClassName = this.classNameGenerator(TD);\n          if (!this.classNames.includes(cellClassName)) {\n            this.classNames.push(cellClassName);\n          }\n        }\n        addClass(TD, cellClassName);\n      }\n      return this;\n    }\n    /**\n     * Generate helper for calculating classNames based on previously added base className.\n     * The generated className is always generated as a continuation of the previous className. For example, when\n     * the currently checked element has 'area-2' className the generated new className will be 'area-3'. When\n     * the element doesn't have any classNames than the base className will be returned ('area');\n     *\n     * @param {String} baseClassName Base className to be used.\n     * @param {Number} layerLevelOwner Layer level which the instance of the Selection belongs to.\n     * @return {Function}\n     */\n  }, {\n    key: \"linearClassNameGenerator\",\n    value: function linearClassNameGenerator(baseClassName, layerLevelOwner) {\n      // TODO: Make this recursive function Proper Tail Calls (TCO/PTC) friendly.\n      return function calcClassName(element) {\n        var previousIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n        if (layerLevelOwner === 0 || previousIndex === 0) {\n          return baseClassName;\n        }\n        var index = previousIndex >= 0 ? previousIndex : layerLevelOwner;\n        var className = baseClassName;\n        index -= 1;\n        var previousClassName = index === 0 ? baseClassName : \"\".concat(baseClassName, \"-\").concat(index);\n        if (hasClass(element, previousClassName)) {\n          var currentLayer = index + 1;\n          className = \"\".concat(baseClassName, \"-\").concat(currentLayer);\n        } else {\n          className = calcClassName(element, index);\n        }\n        return className;\n      };\n    }\n    /**\n     * @param wotInstance\n     */\n  }, {\n    key: \"draw\",\n    value: function draw(wotInstance) {\n      if (this.isEmpty()) {\n        if (this.settings.border) {\n          this.getBorder(wotInstance).disappear();\n        }\n        return;\n      }\n      var renderedRows = wotInstance.wtTable.getRenderedRowsCount();\n      var renderedColumns = wotInstance.wtTable.getRenderedColumnsCount();\n      var corners = this.getCorners();\n      var _corners = _slicedToArray(corners, 4),\n        topRow = _corners[0],\n        topColumn = _corners[1],\n        bottomRow = _corners[2],\n        bottomColumn = _corners[3];\n      for (var column = 0; column < renderedColumns; column += 1) {\n        var sourceCol = wotInstance.wtTable.columnFilter.renderedToSource(column);\n        if (sourceCol >= topColumn && sourceCol <= bottomColumn) {\n          var TH = wotInstance.wtTable.getColumnHeader(sourceCol);\n          if (TH) {\n            var newClasses = [];\n            if (this.settings.highlightHeaderClassName) {\n              newClasses.push(this.settings.highlightHeaderClassName);\n            }\n            if (this.settings.highlightColumnClassName) {\n              newClasses.push(this.settings.highlightColumnClassName);\n            }\n            addClass(TH, newClasses);\n          }\n        }\n      }\n      for (var row = 0; row < renderedRows; row += 1) {\n        var sourceRow = wotInstance.wtTable.rowFilter.renderedToSource(row);\n        if (sourceRow >= topRow && sourceRow <= bottomRow) {\n          var _TH = wotInstance.wtTable.getRowHeader(sourceRow);\n          if (_TH) {\n            var _newClasses = [];\n            if (this.settings.highlightHeaderClassName) {\n              _newClasses.push(this.settings.highlightHeaderClassName);\n            }\n            if (this.settings.highlightRowClassName) {\n              _newClasses.push(this.settings.highlightRowClassName);\n            }\n            addClass(_TH, _newClasses);\n          }\n        }\n        for (var _column = 0; _column < renderedColumns; _column += 1) {\n          var _sourceCol = wotInstance.wtTable.columnFilter.renderedToSource(_column);\n          if (sourceRow >= topRow && sourceRow <= bottomRow && _sourceCol >= topColumn && _sourceCol <= bottomColumn) {\n            // selected cell\n            if (this.settings.className) {\n              this.addClassAtCoords(wotInstance, sourceRow, _sourceCol, this.settings.className, this.settings.markIntersections);\n            }\n          } else if (sourceRow >= topRow && sourceRow <= bottomRow) {\n            // selection is in this row\n            if (this.settings.highlightRowClassName) {\n              this.addClassAtCoords(wotInstance, sourceRow, _sourceCol, this.settings.highlightRowClassName);\n            }\n          } else if (_sourceCol >= topColumn && _sourceCol <= bottomColumn) {\n            // selection is in this column\n            if (this.settings.highlightColumnClassName) {\n              this.addClassAtCoords(wotInstance, sourceRow, _sourceCol, this.settings.highlightColumnClassName);\n            }\n          }\n          var additionalSelectionClass = wotInstance.getSetting('onAfterDrawSelection', sourceRow, _sourceCol, corners, this.settings.layerLevel);\n          if (typeof additionalSelectionClass === 'string') {\n            this.addClassAtCoords(wotInstance, sourceRow, _sourceCol, additionalSelectionClass);\n          }\n        }\n      }\n      wotInstance.getSetting('onBeforeDrawBorders', corners, this.settings.className);\n      if (this.settings.border) {\n        // warning! border.appear modifies corners!\n        this.getBorder(wotInstance).appear(corners);\n      }\n    }\n    /**\n     * Cleans up all the DOM state related to a Selection instance. Call this prior to deleting a Selection instance.\n     */\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      Object.values(this.instanceBorders).forEach(function (border) {\n        return border.destroy();\n      });\n    }\n  }]);\n  return Selection;\n}();\nexport default Selection;","map":{"version":3,"names":["_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","TypeError","Symbol","iterator","Object","prototype","toString","call","_arr","_n","_d","_e","undefined","_i","_s","next","done","push","value","length","err","Array","isArray","_typeof","obj","constructor","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","addClass","hasClass","Border","CellCoords","CellRange","Selection","settings","cellRange","instanceBorders","classNames","className","classNameGenerator","linearClassNameGenerator","layerLevel","getBorder","wotInstance","guid","isEmpty","add","coords","expand","replace","oldCoords","newCoords","from","isEqual","to","clear","getCorners","topLeft","getTopLeftCorner","bottomRight","getBottomRightCorner","row","col","addClassAtCoords","sourceRow","sourceColumn","markIntersections","arguments","TD","wtTable","getCell","cellClassName","includes","baseClassName","layerLevelOwner","calcClassName","element","previousIndex","index","previousClassName","concat","currentLayer","draw","border","disappear","renderedRows","getRenderedRowsCount","renderedColumns","getRenderedColumnsCount","corners","_corners","topRow","topColumn","bottomRow","bottomColumn","column","sourceCol","columnFilter","renderedToSource","TH","getColumnHeader","newClasses","highlightHeaderClassName","highlightColumnClassName","rowFilter","_TH","getRowHeader","_newClasses","highlightRowClassName","_column","_sourceCol","additionalSelectionClass","getSetting","appear","destroy","values","forEach"],"sources":["C:/Users/mrezy/VSCode/internships-master/node_modules/handsontable/es/3rdparty/walkontable/src/selection.js"],"sourcesContent":["import \"core-js/modules/es.symbol\";\nimport \"core-js/modules/es.symbol.description\";\nimport \"core-js/modules/es.symbol.iterator\";\nimport \"core-js/modules/es.array.concat\";\nimport \"core-js/modules/es.array.for-each\";\nimport \"core-js/modules/es.array.includes\";\nimport \"core-js/modules/es.array.iterator\";\nimport \"core-js/modules/es.object.to-string\";\nimport \"core-js/modules/es.object.values\";\nimport \"core-js/modules/es.regexp.to-string\";\nimport \"core-js/modules/es.string.includes\";\nimport \"core-js/modules/es.string.iterator\";\nimport \"core-js/modules/web.dom-collections.for-each\";\nimport \"core-js/modules/web.dom-collections.iterator\";\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport { addClass, hasClass } from './../../../helpers/dom/element';\nimport Border from './border';\nimport CellCoords from './cell/coords';\nimport CellRange from './cell/range';\n/**\n * @class Selection\n */\n\nvar Selection =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {Object} settings\n   * @param {CellRange} cellRange\n   */\n  function Selection(settings, cellRange) {\n    _classCallCheck(this, Selection);\n\n    this.settings = settings;\n    this.cellRange = cellRange || null;\n    this.instanceBorders = {};\n    this.classNames = [this.settings.className];\n    this.classNameGenerator = this.linearClassNameGenerator(this.settings.className, this.settings.layerLevel);\n  }\n  /**\n   * Each Walkontable clone requires it's own border for every selection. This method creates and returns selection\n   * borders per instance\n   *\n   * @param {Walkontable} wotInstance\n   * @returns {Border}\n   */\n\n\n  _createClass(Selection, [{\n    key: \"getBorder\",\n    value: function getBorder(wotInstance) {\n      if (!this.instanceBorders[wotInstance.guid]) {\n        this.instanceBorders[wotInstance.guid] = new Border(wotInstance, this.settings);\n      }\n\n      return this.instanceBorders[wotInstance.guid];\n    }\n    /**\n     * Checks if selection is empty\n     *\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this.cellRange === null;\n    }\n    /**\n     * Adds a cell coords to the selection\n     *\n     * @param {CellCoords} coords\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(coords) {\n      if (this.isEmpty()) {\n        this.cellRange = new CellRange(coords);\n      } else {\n        this.cellRange.expand(coords);\n      }\n\n      return this;\n    }\n    /**\n     * If selection range from or to property equals oldCoords, replace it with newCoords. Return boolean\n     * information about success\n     *\n     * @param {CellCoords} oldCoords\n     * @param {CellCoords} newCoords\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"replace\",\n    value: function replace(oldCoords, newCoords) {\n      if (!this.isEmpty()) {\n        if (this.cellRange.from.isEqual(oldCoords)) {\n          this.cellRange.from = newCoords;\n          return true;\n        }\n\n        if (this.cellRange.to.isEqual(oldCoords)) {\n          this.cellRange.to = newCoords;\n          return true;\n        }\n      }\n\n      return false;\n    }\n    /**\n     * Clears selection\n     *\n     * @returns {Selection}\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.cellRange = null;\n      return this;\n    }\n    /**\n     * Returns the top left (TL) and bottom right (BR) selection coordinates\n     *\n     * @returns {Array} Returns array of coordinates for example `[1, 1, 5, 5]`\n     */\n\n  }, {\n    key: \"getCorners\",\n    value: function getCorners() {\n      var topLeft = this.cellRange.getTopLeftCorner();\n      var bottomRight = this.cellRange.getBottomRightCorner();\n      return [topLeft.row, topLeft.col, bottomRight.row, bottomRight.col];\n    }\n    /**\n     * Adds class name to cell element at given coords\n     *\n     * @param {Walkontable} wotInstance Walkontable instance\n     * @param {Number} sourceRow Cell row coord\n     * @param {Number} sourceColumn Cell column coord\n     * @param {String} className Class name\n     * @param {Boolean} [markIntersections=false] If `true`, linear className generator will be used to add CSS classes\n     *                                            in a continuous way.\n     * @returns {Selection}\n     */\n\n  }, {\n    key: \"addClassAtCoords\",\n    value: function addClassAtCoords(wotInstance, sourceRow, sourceColumn, className) {\n      var markIntersections = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      var TD = wotInstance.wtTable.getCell(new CellCoords(sourceRow, sourceColumn));\n\n      if (_typeof(TD) === 'object') {\n        var cellClassName = className;\n\n        if (markIntersections) {\n          cellClassName = this.classNameGenerator(TD);\n\n          if (!this.classNames.includes(cellClassName)) {\n            this.classNames.push(cellClassName);\n          }\n        }\n\n        addClass(TD, cellClassName);\n      }\n\n      return this;\n    }\n    /**\n     * Generate helper for calculating classNames based on previously added base className.\n     * The generated className is always generated as a continuation of the previous className. For example, when\n     * the currently checked element has 'area-2' className the generated new className will be 'area-3'. When\n     * the element doesn't have any classNames than the base className will be returned ('area');\n     *\n     * @param {String} baseClassName Base className to be used.\n     * @param {Number} layerLevelOwner Layer level which the instance of the Selection belongs to.\n     * @return {Function}\n     */\n\n  }, {\n    key: \"linearClassNameGenerator\",\n    value: function linearClassNameGenerator(baseClassName, layerLevelOwner) {\n      // TODO: Make this recursive function Proper Tail Calls (TCO/PTC) friendly.\n      return function calcClassName(element) {\n        var previousIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n\n        if (layerLevelOwner === 0 || previousIndex === 0) {\n          return baseClassName;\n        }\n\n        var index = previousIndex >= 0 ? previousIndex : layerLevelOwner;\n        var className = baseClassName;\n        index -= 1;\n        var previousClassName = index === 0 ? baseClassName : \"\".concat(baseClassName, \"-\").concat(index);\n\n        if (hasClass(element, previousClassName)) {\n          var currentLayer = index + 1;\n          className = \"\".concat(baseClassName, \"-\").concat(currentLayer);\n        } else {\n          className = calcClassName(element, index);\n        }\n\n        return className;\n      };\n    }\n    /**\n     * @param wotInstance\n     */\n\n  }, {\n    key: \"draw\",\n    value: function draw(wotInstance) {\n      if (this.isEmpty()) {\n        if (this.settings.border) {\n          this.getBorder(wotInstance).disappear();\n        }\n\n        return;\n      }\n\n      var renderedRows = wotInstance.wtTable.getRenderedRowsCount();\n      var renderedColumns = wotInstance.wtTable.getRenderedColumnsCount();\n      var corners = this.getCorners();\n\n      var _corners = _slicedToArray(corners, 4),\n          topRow = _corners[0],\n          topColumn = _corners[1],\n          bottomRow = _corners[2],\n          bottomColumn = _corners[3];\n\n      for (var column = 0; column < renderedColumns; column += 1) {\n        var sourceCol = wotInstance.wtTable.columnFilter.renderedToSource(column);\n\n        if (sourceCol >= topColumn && sourceCol <= bottomColumn) {\n          var TH = wotInstance.wtTable.getColumnHeader(sourceCol);\n\n          if (TH) {\n            var newClasses = [];\n\n            if (this.settings.highlightHeaderClassName) {\n              newClasses.push(this.settings.highlightHeaderClassName);\n            }\n\n            if (this.settings.highlightColumnClassName) {\n              newClasses.push(this.settings.highlightColumnClassName);\n            }\n\n            addClass(TH, newClasses);\n          }\n        }\n      }\n\n      for (var row = 0; row < renderedRows; row += 1) {\n        var sourceRow = wotInstance.wtTable.rowFilter.renderedToSource(row);\n\n        if (sourceRow >= topRow && sourceRow <= bottomRow) {\n          var _TH = wotInstance.wtTable.getRowHeader(sourceRow);\n\n          if (_TH) {\n            var _newClasses = [];\n\n            if (this.settings.highlightHeaderClassName) {\n              _newClasses.push(this.settings.highlightHeaderClassName);\n            }\n\n            if (this.settings.highlightRowClassName) {\n              _newClasses.push(this.settings.highlightRowClassName);\n            }\n\n            addClass(_TH, _newClasses);\n          }\n        }\n\n        for (var _column = 0; _column < renderedColumns; _column += 1) {\n          var _sourceCol = wotInstance.wtTable.columnFilter.renderedToSource(_column);\n\n          if (sourceRow >= topRow && sourceRow <= bottomRow && _sourceCol >= topColumn && _sourceCol <= bottomColumn) {\n            // selected cell\n            if (this.settings.className) {\n              this.addClassAtCoords(wotInstance, sourceRow, _sourceCol, this.settings.className, this.settings.markIntersections);\n            }\n          } else if (sourceRow >= topRow && sourceRow <= bottomRow) {\n            // selection is in this row\n            if (this.settings.highlightRowClassName) {\n              this.addClassAtCoords(wotInstance, sourceRow, _sourceCol, this.settings.highlightRowClassName);\n            }\n          } else if (_sourceCol >= topColumn && _sourceCol <= bottomColumn) {\n            // selection is in this column\n            if (this.settings.highlightColumnClassName) {\n              this.addClassAtCoords(wotInstance, sourceRow, _sourceCol, this.settings.highlightColumnClassName);\n            }\n          }\n\n          var additionalSelectionClass = wotInstance.getSetting('onAfterDrawSelection', sourceRow, _sourceCol, corners, this.settings.layerLevel);\n\n          if (typeof additionalSelectionClass === 'string') {\n            this.addClassAtCoords(wotInstance, sourceRow, _sourceCol, additionalSelectionClass);\n          }\n        }\n      }\n\n      wotInstance.getSetting('onBeforeDrawBorders', corners, this.settings.className);\n\n      if (this.settings.border) {\n        // warning! border.appear modifies corners!\n        this.getBorder(wotInstance).appear(corners);\n      }\n    }\n    /**\n     * Cleans up all the DOM state related to a Selection instance. Call this prior to deleting a Selection instance.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      Object.values(this.instanceBorders).forEach(function (border) {\n        return border.destroy();\n      });\n    }\n  }]);\n\n  return Selection;\n}();\n\nexport default Selection;"],"mappings":"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"},"metadata":{},"sourceType":"module"}